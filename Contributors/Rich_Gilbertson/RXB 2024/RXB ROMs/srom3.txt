************************************************************
       AORG >6000
       TITL 'RXB ROM3'
************************************************************
* EQUATES
BIAS   EQU  >6000
PAD    EQU  >8300       * TEMP
PAD1   EQU  >8301       * TEMP
PAD2   EQU  >8302       * VDP ADDRESS
PAD3   EQU  >8303       * TEMP
PAD4   EQU  >8304       * TEMP
PAD5   EQU  >8305       * TEMP
PAD6   EQU  >8306       * TEMP BUFFER FOR COINSP
PAD8   EQU  >8308       * SPRITE 1
PADA   EQU  >830A       * SPRITE 2
BYTES  EQU  >830C       * STRING LENGTH
PAD10  EQU  >8310       * CHAR ROUTINE
PAD12  EQU  >8312       * CHAR ROUTINE
VAR7   EQU  >8312       * CHAR ROUTINE
VAR9   EQU  >8314       * CHAR ROUTINE
VARA   EQU  >8316       * CHAR ROUTINE
PAD16  EQU  >8316       * CHAR ROUTINE
SREF   EQU  >831C       * STRING POINTER
FAC    EQU  >834A       * RAM line buffer
FAC1   EQU  >834B       * GCHAR buffer
FAC4   EQU  >834E       * String Address
FAC6   EQU  >8350       * String Length
FAC8   EQU  >8352       * Copy String pointer
ARG    EQU  >835C       * ARGUMENT FOR ERRORS
ARG2   EQU  >835E       * CHAR FLAG
STATUS EQU  >837C       * GPL STATUS BYTE
ISR    EQU  >83C4       * ISR INTERUPT HOOK
GR0LB  EQU  >83E1       * GPLWS R0 LSB
GR4LB  EQU  >83E9       * GPLWS R4 LSB
VDPRD  EQU  >8800       * VDP Read Data address
VDPWD  EQU  >8C00       * VDP Write Data address
************************************************************
* VDP EQUATES
VBUFF  EQU  >03C0       * line buffer in VRAM
************************************************************
UNUSED DATA >0000,>0000,>0000,>0000
       DATA >0000,>0000,>0000,>0000
******************************************************************
* XML table number 7 for RXB ROM3 - must have                    *
*     it's origin at >6010                                       *
******************************************************************
*             0     1     2     3     4     5     6      7   
       DATA RROLL,LROLL,UROLL,DROLL,HCHAR,VCHAR,ASCHEX,HPUT
*             8    9      A    B    C      D     E     F
       DATA VPUT,CLEARP,HGET,VGET,>0000,>0000,ALPHA,CHRLDR
*****************************************************************
* XML table number 8 for RXB ROM3 - must have                   *
*     it's origin at >6030                                      *
*****************************************************************
*             0      1     2      3      4     5     6     7
       DATA COLLSP,DCHAR,CHRPAT,SPSPD5,SPDEL,>0000,>0000,>0000
*             8     9     A      B     C      D      E     F
       DATA >0000,>0000,EAINIT,CINIT,XISRON,XISROF,>0000,>0000
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Write VRAM address
*     Expects address in R0
*
* BL here for writing data
*
VWADD  ORI  R0,>4000    * set to write VRAM data
*
* BL here for reading data
*
VWADDA MOVB @GR0LB,*R15 * write LSB of R0 to VDPWA
       MOVB R0,*R15     * write MSB of R0 to VDPWA
       ANDI R0,>3FFF    * ensure R0 returned intact
       RT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* The following utilities expect 
*     R0 = VRAM address of row
*     R1 = RAM buffer address
*
* R2 and R10 will be destroyed
* 
* Copy 1 row of 32 bytes from VDP (R0) to RAM (R1)
*
VRROW  MOV  R11,R10   * save return
       BL   @VWADDA   * write out VDP read address
       LI   R2,32     * read 1 row
       LI   R8,VDPRD  * Register faster then address
VRROW1 MOVB *R8,*R1+  * read next VDP byte to RAM
       MOVB *R8,*R1+  * read next VDP byte to RAM
       DECT R2        * dec count by 2
       JNE  VRROW1    * repeat if not done
       B    *R10      * return to caller
* 
* Copy 1 row of 32 bytes from RAM (R1) to VDP (R0)
*
VWROW  MOV  R11,R10   * save return
       BL   @VWADD    * write out VDP write address
       LI   R2,32     * write one row
       LI   R8,VDPWD  * Register faster then address
VWROW1 MOVB *R1+,*R8  * write next VDP byte from RAM
       MOVB *R1+,*R8  * write next VDP byte from RAM
       DECT R2        * dec count by 2
       JNE  VWROW1    * repeat if not done
       B    *R10      * return to caller
*********************************************************
* CALL ROLLRIGHT(repetion)                              *
*********************************************************
RROLL  MOV  R11,R9    * save return address
       CLR  R0        * set to screen start
       LI   R3,24     * rows to roll
* Write row to RAM buffer
RROLLP LI   R1,FAC+1  * RAM buffer+1 for roll-right positions
       BL   @VRROW    * copy row to RAM buffer 2 bytes at a time
* Copy last column before first in RAM buffer
       MOVB @FAC+32,@FAC * copy roll-out byte to roll-in position
* Copy rolled row back to screen (R0 still has correct location)
       LI   R1,FAC    * reset RAM buffer pointer
       BL   @VWROW    * copy rolled line          
* Process next row
       AI   R0,32     * next row                   
       DEC  R3        * dec row count
       JNE  RROLLP    * roll next row if not done
       B    @PAGER    * return to XB
*********************************************************
* CALL ROLLLEFT(repetion)                               *
*********************************************************
LROLL  MOV  R11,R9    * save return address
       CLR  R0        * set to screen start
       LI   R3,24     * rows to roll
* Write row to RAM buffer
LROLLP LI   R1,FAC    * RAM buffer+1 for roll-left positions
       BL   @VRROW    * copy row to RAM buffer 2 bytes at a time
* Copy first column after last in RAM buffer
       MOVB @FAC,@FAC+32 * copy roll-out byte to roll-in position
* Copy rolled row back to screen (R0 still has correct location)
       LI   R1,FAC+1  * reset RAM buffer pointer
       BL   @VWROW    * copy rolled line 2 bytes at a time
* Process next row
       AI   R0,32     * next row                   
       DEC  R3        * dec row count
       JNE  LROLLP    * roll next row if not done
       B    @PAGER     * return to XB
*********************************************************
* CALL ROLLUP(repetion)                                 *
*********************************************************
UROLL  MOV  R11,R9    * save return address
       CLR  R0        * set to screen start
       LI   R3,23     * rows to roll (all but 1st)
* Write first row to RAM buffer
       LI   R1,FAC    * set RAM buffer
       BL   @VRROW    * copy row to RAM buffer 2 bytes at a time
* Copy RAM buffer to VRAM buffer
       LI   R0,VBUFF  * set VRAM dest to VBUFF
       LI   R1,FAC    * set RAM buffer
       BL   @VWROW    * copy row to VBUFF 2 bytes at a time
* Start copy loop at 2nd row
       LI   R0,32     * point to 2nd row
* Write row to RAM buffer
UROLLP LI   R1,FAC    * set RAM buffer
       BL   @VRROW    * copy row to RAM buffer 2 bytes at a time
* Copy to previous row
       AI   R0,-32    * back up 1 row
       LI   R1,FAC    * reset RAM buffer pointer
       BL   @VWROW    * copy to previous row 2 bytes at a time
* Process next row
       AI   R0,64     * next row
       DEC  R3        * dec row count
       JNE  UROLLP    * roll next row if not done
* Copy saved row to RAM
       LI   R0,VBUFF  * set VRAM source
       LI   R1,FAC    * set RAM buffer
       BL   @VRROW    * copy row to RAM buffer 2 bytes at a time
* Copy saved row to last row
       LI   R0,736    * point to last row
       LI   R1,FAC    * reset RAM buffer pointer
       BL   @VWROW    * copy to last row 2 bytes at a time
       B    @PAGER    * return to XB
*********************************************************
* CALL ROLLDOWN(repetion)                               *
*********************************************************
DROLL  MOV  R11,R9    * save return address
       LI   R0,736    * set to last row
       LI   R3,23     * rows to roll (all but last)
* Write last row to RAM buffer
       LI   R1,FAC    * set RAM buffer
       BL   @VRROW    * copy row to RAM buffer 2 bytes at a time
* Copy RAM buffer to VRAM buffer
       LI   R0,VBUFF  * set VRAM dest to VBUFF
       LI   R1,FAC    * set RAM buffer
       BL   @VWROW    * copy row to VBUFF 2 bytes at a time
* Start copy loop at 2nd-to-last row
       LI   R0,704    *  point to row 22
* Write row to RAM buffer
DROLLP LI   R1,FAC    * set RAM buffer
       BL   @VRROW    * copy row to RAM buffer 2 bytes at a time
* Copy to next row
       AI   R0,32     * down 1 row
       LI   R1,FAC    * reset RAM buffer pointer
       BL   @VWROW    * copy to next row 2 bytes at a time
* Process next row
       AI   R0,-64    * back up 2 rows
       DEC  R3        * dec row count
       JNE  DROLLP    * roll next row if not done
* Copy saved row to RAM
       LI   R0,VBUFF  * set VRAM source
       LI   R1,FAC    * set RAM buffer
       BL   @VRROW    * copy row to RAM buffer 
*                     *  2 bytes at a time
* Copy saved row to first row
       CLR  R0        * point to first row
       LI   R1,FAC    * reset RAM buffer pointer
       BL   @VWROW    * copy to first row 2 bytes at a time
       B    @PAGER    * return to caller
***********************************************************
* CALL HCHAR(row,column,character#,repetition[,...])      *
***********************************************************
* R0 VDP ADDRESS = PAD2
* R1 CHARACTER   = PAD 
* R3 COUNTER     - FAC
*
HCHAR  MOV  R11,R9      * save return address
       LI   R8,VDPWD    * put VDPWD in R8 for faster loop
       MOV  @PAD2,R0    * VRAM start address for HCHAR4
       MOV  @PAD,R1     * ASCII char code is in MSB
       MOV  @FAC,R3     * repetition to R3..
       MOV  R3,R7       * .. and to R4 for manipulation
       LI   R5,768      * get screen end = 768 to a register..
       MOV  R5,R6       * ..and to R6 for screen size
       C    R6,R7       * scrn_size > cnt, i.e., cnt OK?
       JGT  HCHAR1      * yes; jump
       MOV  R6,R7       * no; cnt = scrn_size
HCHAR1 C    R0,R5       * VRAM address outside screen?
       JHE  HCHARX      * error if so..just exit
       S    R0,R5       * bytes to end of screen
HCHAR2 MOV  R7,R3       * put cnt in R3 for HCHAR4
       JGT  HCHAR3      * are we done?
       JMP  HCHARX      * yup; we're outta here!
HCHAR3 S    R5,R7       * no; do we wrap to screen start?
       JLT  HCHAR4      * no
       MOV  R5,R3       * yes, just go to screen end
HCHAR4 BL   @VWADD      * write out VRAM write address
       LI   R8,VDPWD    * put VDPWD in R8 for faster loop
HCHAR5 MOVB R1,*R8      * Write a byte to next VRAM location
       DEC  R3          * decrement count
       JNE  HCHAR5      * Not done, fill another
       CLR  R0          * wrap for next round
       MOV  R6,R5       * scrn_size to bytes-to-end-of-screen
       JMP  HCHAR2      * see if more
HCHARX B    @PAGER      * return to caller
***********************************************************
* CALL VCHAR(row,column,character#,repetition[,...])      *
***********************************************************
* CALL VCHAR(row,column,character#,repetition)
* R0 VDP ADDRESS = PAD2
* R1 CHARACTER   = PAD 
* R3 COUNTER     = FAC
VCHAR   MOV  R11,R9     * save return address
        MOV  @PAD2,R0   * VDP ADDRESS 
        MOV  R0,R7      * Copy VDP ADDRESS
VCHART  CI   R7,31      * VDP ADDRESS>=31 top?
        JLE  VCHARD     * column<=31 top found
        AI   R7,-32     * VDP ADDRESS-32
        JMP  VCHART     * Loop
VCHARD  CI   R7,31      * column=31?
        JNE  VCHARR     * 0 to 30
        CLR  R7         * Reset column to 0
        JMP  VCHARZ
VCHARR  INC  R7         * column+1
VCHARZ  MOV  @PAD,R1    * Character to display 
        MOV  @FAC,R3    * Repetition  
VCHAR1  BL   @VWADD     * write out VRAM write address
        LI   R8,VDPWD   * Register faster then @
        MOVB R1,*R8     * write next VRAM byte from R1
        CI   R0,768     * End of screen?
        JEQ  VCHARE     * Yes
        CI   R0,735     * next to last ROW?
        JLE  VCHAR3     * Yes
VCHARE  MOV  R7,R0      * VDP ADDRESS=COPY VDP ADDRESS 
        INC  R7         * column+1 
        CI   R7,31      * Next row past last column? 
        JLE  VCHAR2     * No
        CLR  R7         * Wrap Column back
VCHAR2  DEC  R3         * repetition-1
        JNE  VCHAR1     * No done yet
        JMP  VCHAR4     * Exit
VCHAR3  AI   R0,32      * ROW+1
        CI   R0,768     * Off screen?
        JHE  VCHARE     * Yes reset
        DEC  R3         * REPETITION-1
        JNE  VCHAR1     * No loop
VCHAR4  B    @PAGER     * RETURN TO XB
**********************************************************
* CALL HPUT(row,column,$variable,...)                    *
* CALL HPUT(row,column,number-variable,...)              *
**********************************************************
* CALL HPUT(row,column,string or number)
* R0 VDP SCREEN ADDRESS = PAD2 R5,R0
* R4 VDP STRING ADDRESS = FAC4 R4,R0
* R3 COUNTER            = FAC6 R3
*
HPUT    MOV  R11,R9     * save return address
        MOV  @PAD2,R5   * VDP SCREEN ADDRESS
        MOV  @FAC4,R4   * String address or number
        MOV  @FAC6,R3   * Length
        LI   R7,BIAS    * Get Screen bias off set 
        LI   R1,VDPWD   * Register faster then @
        LI   R8,VDPRD   * Register faster then @
        CI   R3,0       * Length=0? 
        JEQ  HPUT2      * Yes
HPUT0   MOV  R4,R0      * Get String/number address
        BL   @VWADDA    * read out VDP address R4
        MOVB *R8,R6     * Get $/# from R4 byte into R6
        AB   R7,R6      * Add bias
        MOV  R0,R4      * Get new update into R4
        INC  R4         * STRING ADDRESS+1
        MOV  R5,R0      * Get SCREEN ADDRESS
        BL   @VWADD     * write out VDP write address R5
        MOVB R6,*R1     * Put R6 onto screen address R0 
        MOV  R0,R5      * Get new update into R5
        INC  R5         * SCREEN ADDRESS+1
        CI   R5,768     * Last row:col?
        JNE  HPUT1      * No, so continue loop
        CLR  R5         * Reset back to top row:col
HPUT1   DEC  R3         * count by -1
        JNE  HPUT0      * count=0? Restart at top row:col
HPUT2   B    @PAGER     * return to caller
**********************************************************
* CALL VPUT(row,column,$variable,...)                    *
* CALL VPUT(row,column,number-variable,...)              *
**********************************************************
* CALL VPUT(row,column,string or number)
* R0 VDP SCREEN ADDRESS = PAD2 R5,R0
* R4 VDP STRING ADDRESS = FAC4 R4,R0
* R3 COUNTER            = FAC6 R3
*
VPUT    MOV  R11,R9     * save return address
        MOV  @PAD2,R5   * VDP ADDRESS
        MOV  @FAC4,R4   * String address or number
        MOV  @FAC6,R3   * Length
        LI   R7,BIAS    * Get Screen bias off set 
        LI   R1,VDPWD   * Register faster then @
        LI   R8,VDPRD   * Register faster then @
        CI   R3,0       * Length=0? 
        JEQ  VPUT2      * Yes
VPUT0   MOV  R4,R0      * Get String/number address
        BL   @VWADDA    * read out VDP address R4
        MOVB *R8,R6     * Get $/# from R4 byte into R6
        AB   R7,R6      * Add bias
        MOV  R0,R4      * Get new update into R4
        INC  R4         * STRING ADDRESS+1
        MOV  R5,R0      * Get SCREEN ADDRESS
        BL   @VWADD     * write out VDP write address R5
        MOVB R6,*R1     * Put R6 onto screen address R0 
        MOV  R0,R5      * Get new update into R5
        CI   R5,767     * OFF SCREEN?
        JEQ  VPUT3      * Yes
        CI   R5,735     * Last ROW?
        JGT  VPUT4      * Yes
        AI   R5,32      * ROW+1
VPUT1   DEC  R3         * Length-1
        JNE  VPUT0      * No loop
VPUT2   B    @PAGER     * return to XB
VPUT3   CLR  R5         * RESET TO TOP LEFT CHARACTER
        JMP  VPUT1      * Always loop
VPUT4   AI   R5,-735    * Reset back to top ROW
        JMP  VPUT1      * Always loop
**********************************************************
* CALL HGET(row,column,length,$variable)                 *
**********************************************************
* R0 VDP SCREEN ADDRESS = PAD2  R5,R0
* R4 VDP STRING ADDRESS = PAD4  R4,R0
* R3 Length             = PAD6  R3
*
HGET    MOV  R11,R9     * save return address
        MOV  @PAD2,R5   * VDP SCREEN ADDRESS
        MOV  @PAD4,R4   * String address
        MOV  @PAD6,R3   * Length
        LI   R7,BIAS    * Get Screen bias off set 
        LI   R1,VDPWD   * Register faster then @
        LI   R8,VDPRD   * Register faster then @       
HGET0   MOV  R5,R0      * Get Screen Address
        BL   @VWADDA    * read out VDP address R5
        MOVB *R8,R6     * Get Screen byte into R6
        SB   R7,R6      * Subtract bias
        MOV  R0,R5      * Get new update into R5 
        INC  R5         * SCREEN ADDRESS+1
        CI   R5,768     * Last row:col?
        JNE  HGET1      * No, so continue loop
        CLR  R5         * Reset back to top row:col
HGET1   MOV  R4,R0      * Get STRING ADDRESS
        BL   @VWADD     * write out VDP write address R4
        MOVB R6,*R1     * Put R6 onto String address R0 
        MOV  R0,R4      * Get new String update into R4
        INC  R4         * STRING ADDRESS+1
        DEC  R3         * Length-1
        JNE  HGET0      * count=0? Restart at top row:col
HGET2   B    @PAGER     * return to caller
**********************************************************
* CALL VGET(row,column,length,$variable)                 *
**********************************************************
* R0 VDP SCREEN ADDRESS = PAD2  R5,R0
* R4 VDP STRING ADDRESS = PAD4  R4,R0
* R3 Length             = PAD6  R3
*
VGET    MOV  R11,R9     * save return address
        MOV  @PAD2,R5   * VDP ADDRESS
        MOV  @PAD4,R4   * String address or number
        MOV  @PAD6,R3   * Length
        LI   R7,BIAS    * Get Screen bias off set 
        LI   R1,VDPWD   * Register faster then @
        LI   R8,VDPRD   * Register faster then @
VGET0   MOV  R5,R0      * Get Screen address
        BL   @VWADDA    * read out VDP address R5
        MOVB *R8,R6     * Get Screen from R5 into R6
        SB   R7,R6      * Subtact bias
        MOV  R0,R5      * Get new Screen update into R5
        CI   R5,735     * Last ROW?
        JLE  VGET2      * Yes, ROW+1
        CI   R5,767     * OFF SCREEN?
        JHE  VGET1      * Yes, reset ROW:COL to Zero
        INC  R5         * COL+1
        S    @PAD2,R5   * Original address-screen address 
        JMP  VGET3      * Save to String
VGET1   CLR  R5         * Reset back to top row:col  
        JMP  VGET3      * Save to String
VGET2   AI   R5,32      * ROW+1  
VGET3   MOV  R4,R0      * Get STRING ADDRESS
        BL   @VWADD     * write out VDP write address R4
        MOVB R6,*R1     * Put R6 onto screen address R0 
        MOV  R0,R4      * Get new update into R4
        INC  R4         * STRING ADDRESS+1     
        DEC  R3         * Length-1
        JNE  VGET0      * No loop
        B    @PAGER     * return to XB
**********************************************************
* CALL INVERSE(chr#,...)                                 *
* CALL INVERSE(ALL,...)                                  *
**********************************************************
* R0 TEMP VDP   
* R1 CHARACTER ADDRESS  = FAC
* R2 NUMBER CHAR COUNT  = PAD 
* R3 ADDRESS OF R4 TO R7
INVERS  MOV  R11,R9    * save return address
        MOV  @FAC,R1   * CHARACTER ADDRESS
        CI   R1,0      * ALL flag?
        JNE  INV1      * No single character defintion
        LI   R1,>03F0  * Cursor first character
        LI   R2,129    * Load number of characters
        JMP  INV2      * Go do ALL
INV1    LI   R2,1      * Load 1 character 
* Get 4 bytes of character definition
INV2    LI   R3,>83E8 * BUFFER in R4 to R7 
        MOV  R1,R0    * Copy VDP Char Address
        BL   @VWADDA  * read out VDP address                 
        LI   R8,VDPRD * Register faster then address
        MOVB *R8,*R3+ * read next VDP byte to RAM
        MOVB *R8,*R3+ * read next VDP byte to RAM
        MOVB *R8,*R3+ * read next VDP byte to RAM
        MOVB *R8,*R3+ * read next VDP byte to RAM
        MOVB *R8,*R3+ * read next VDP byte to RAM
        MOVB *R8,*R3+ * read next VDP byte to RAM
        MOVB *R8,*R3+ * read next VDP byte to RAM
        MOVB *R8,*R3+ * read next VDP byte to RAM
        INV  R4       * INVERT BITS
        INV  R5       * INVERT BITS
        INV  R6       * INVERT BITS
        INV  R7       * INVERT BITS
        LI   R3,>83E8 * BUFFER in R4 to R7 
        MOV  R1,R0    * Copy VDP Char Address
        BL   @VWADD   * write out VDP address
        LI   R8,VDPWD * Register faster then address
        MOVB *R3+,*R8 * write next VDP byte from RAM
        MOVB *R3+,*R8 * write next VDP byte from RAM
        MOVB *R3+,*R8 * write next VDP byte from RAM
        MOVB *R3+,*R8 * write next VDP byte from RAM
        MOVB *R3+,*R8 * write next VDP byte from RAM
        MOVB *R3+,*R8 * write next VDP byte from RAM
        MOVB *R3+,*R8 * write next VDP byte from RAM
        MOVB *R3+,*R8 * write next VDP byte from RAM
        AI   R1,8     * Next Character Definition  
        DEC  R2       * Character counter -1
        JNE  INV2     * 0? No keep looping
        B    @PAGER     * return to XB
*************************************************************
* CALL COLLIDE(#SPR,#SPR,TOLERANCE,DOTROW,DOTCOL)           *
*************************************************************
* PAD  = SPRITE 1 RETURN=ROW
* PAD2 = SPRITE 2 RETURN=COLUMN
* FAC  = TOLERANCE
COLLSP MOV  R11,R9     * save return address
* LOOK FOR SPRITE COINCIDENCE
COLL   LI   R8,PAD     * PAD
       CLR  R0         * ZERO OUT
       MOVB *R8+,R0    * Sprite #1 ROW in high byte
       CLR  R4         * ZERO OUT
       MOVB *R8+,R4    * Sprite #1 COL in high byte
       CLR  R1         * ZERO OUT 
       MOVB *R8+,R1    * Sprite #2 ROW in high byte
       CLR  R5         * ZERO OUT
       MOVB *R8+,R5    * Sprite #2 COL in high byte
       MOV  @FAC,R7    * TOLERANCE
       SWPB R7         * Put into high byte
       CLR  @PAD       * zero out 
       CLR  @PAD2      * zero out 
*** CHECK FOR OFF SCREEN       
       LI   R6,>C000   * Off screen value
       C    R0,R6      * To Sprite #1 ROW to high?
       JHE  COLL       * Yes defualt zero 
       C    R1,R6      * To Sprite #2 ROW to high?
       JHE  COLL       * Yes defualt zero 
*** Row comparison
       MOV  R1,R8
       S    R0,R8      * Sprite #2 ROW-Sprite #1 ROW
       ABS  R8         * No negative value
       C    R8,R7      * Within tolerance?
       JGT  COLL       * No defualt zero       
*** Column comparison 
       MOV  R5,R8
       S    R4,R8      * Sprite #2 COL-Sprite #1 COL
       ABS  R8         * No negative value
       C    R8,R7      * Within tolerance?
       JGT  COLLO      * No defualt zero 
       SWPB R0         * Sprite #1 ROW in low byte
       MOV  R0,@PAD    * Save Sprite #1 ROW to XB
       SWPB R4         * Sprite #1 COL in low byte
       MOV  R4,@PAD2   * Save Sprite #1 COL to XB
COLLO  B    @PAGER     * return to XB 
***********************************************************
* CALL CLEARPRINT                                         *
***********************************************************
CLEARP MOV  R11,R9     * save return address
       LI   R0,2       * Screen address start COL 3
       LI   R1,>8000   * Space Character
       LI   R3,24      * ROW counter
       LI   R4,2       * COL copy
       LI   R8,VDPWD   * put VDPWD in R8 for faster loop
CLEARL BL   @VWADD     * write out VRAM write address
       LI   R2,28      * Count COL 28
CLEARR MOVB R1,*R8     * Write a byte to next VRAM location
       DEC  R2         * COUNT-1
       JNE  CLEARR     * No loop
       AI   R4,32      * Start COL copy +32
       MOV  R4,R0      * Get new ROW:COL
       DEC  R3         * ROW-1
       JNE  CLEARL     * Not zero continue
       B    @PAGER     * return to XB 
***********************************************************
* RXB CALL INIT XB ASSEMBLY ROUTINE
*
CINIT   MOV  R11,R9    * save return address
        LI   R0,>2000  * RAM destination address
        LI   R1,ALCEND * ROM source address 
        LI   R2,>0274  * COUNT
INITLP  MOV  *R1+,*R0+ * Write next RAM word 1
        MOV  *R1+,*R0+ * Write next RAM word 2
        MOV  *R1+,*R0+ * Write next RAM word 3
        MOV  *R1+,*R0+ * Write next RAM word 4 
        MOV  *R1+,*R0+ * Write next RAM word 5
        MOV  *R1+,*R0+ * Write next RAM word 6
        MOV  *R1+,*R0+ * Write next RAM word 7
        MOV  *R1+,*R0+ * Write next RAM word 8
        DEC  R2        * COUNT-1
        JNE  INITLP    * Repeat if not done
        MOV  *R1+,*R0+ * Last word to load
        B    @PAGER       * DONE RETURN TO XB 
***********************************************************
ALCEND  DATA >205A,>24F4,>4000,>AA55
        DATA >2038,>2096,>2038,>217E
        DATA >2038,>21E2,>2038,>234C
        DATA >2038,>2432,>2038,>246E
        DATA >2038,>2484,>2038,>2490
        DATA >2038,>249E,>2038,>24AA
        DATA >2038,>24B8,>2038,>2090
        DATA >0000,>0000,>0000,>0000
        DATA >0000,>0000,>0000,>0000
        DATA >0000,>0000,>0000,>0000
        DATA >0000,>0000,>0000,>0000
        DATA >6520,>C060,>2004,>0281
        DATA >4000,>130E,>C001,>0202
        DATA >834A,>8CB0,>1606,>8CB0
        DATA >1604,>8CB0,>1602,>C030
        DATA >0450,>0221,>0008,>10EF
        DATA >0200,>2500,>C800,>8322
        DATA >02E0,>83E0,>0460,>00CE
        DATA >C81D,>8322,>10F9,>C01D
        DATA >C06D,>0002,>06A0,>20DC
        DATA >C0C1,>0603,>0223,>8300
        DATA >D0D3,>1361,>0983,>0643
        DATA >1612,>C000,>165C,>C0C5
        DATA >05C3,>06A0,>2406,>1653
        DATA >05C3,>06A0,>23CA,>0204
        DATA >834A,>0202,>0008,>DC74
        DATA >0602,>15FD,>0380,>06A0
        DATA >20F8,>10F5,>C041,>1347
        DATA >0A81,>9060,>8312,>1143
        DATA >0981,>C141,>0A35,>0225
        DATA >0008,>A160,>8310,>045B
        DATA >C24B,>0643,>1634,>C0C5
        DATA >06A0,>23CA,>C0C1,>06A0
        DATA >2406,>112D,>06A0,>211C
        DATA >06A0,>23CA,>6004,>0A30
        DATA >A040,>0459,>C28B,>0A51
        DATA >09D1,>C201,>D120,>8343
        DATA >0984,>1303,>0600,>1123
        DATA >0580,>0206,>0001,>C0C5
        DATA >0223,>0004,>06A0,>23CA
        DATA >C0C1,>0643,>05C3,>06A0
        DATA >23CA,>0581,>6044,>3981
        DATA >C186,>1611,>C187,>0608
        DATA >15F5,>0606,>A184,>8180
        DATA >150A,>05C3,>045A,>0200
        DATA >0700,>0460,>2084,>0200
        DATA >1C00,>0460,>2084,>0200
        DATA >1400,>0460,>2084,>C01D
        DATA >C06D,>0002,>06A0,>20DC
        DATA >C0C1,>0603,>0223,>8300
        DATA >D0D3,>0983,>160E,>C000
        DATA >1622,>0202,>0008,>0204
        DATA >834A,>C0C5,>06A0,>23CA
        DATA >CD01,>05C3,>0642,>15FA
        DATA >0380,>0643,>160F,>C000
        DATA >1612,>C0C5,>05C3,>06A0
        DATA >2406,>160B,>05C3,>06A0
        DATA >23CA,>C101,>0201,>834A
        DATA >0460,>20CA,>06A0,>20F8
        DATA >10F8,>0460,>2166,>0460
        DATA >216E,>C81D,>2038,>C82D
        DATA >0002,>83E2,>C82D,>0004
        DATA >2044,>02E0,>83E0,>C80B
        DATA >2040,>C020,>2044,>06A0
        DATA >20DC,>C0C1,>0603,>0223
        DATA >8300,>D0D3,>0983,>0603
        DATA >1332,>0643,>164A,>C2A0
        DATA >2038,>162D,>C0C5,>05C3
        DATA >06A0,>2406,>9801,>2058
        DATA >1620,>0206,>0008,>0204
        DATA >834A,>C0C5,>06A0,>23CA
        DATA >CD01,>05C3,>0646,>15FA
        DATA >06A0,>22DA,>0225,>0004
        DATA >C105,>C046,>06A0,>23E6
        DATA >05C4,>D050,>0981,>06A0
        DATA >23E6,>C2E0,>2040,>C820
        DATA >203E,>830C,>02E0,>2038
        DATA >0380,>0200,>0700,>C2E0
        DATA >2040,>0460,>2084,>0200
        DATA >1C00,>0460,>226E,>C08B
        DATA >0643,>16F3,>C0C5,>06A0
        DATA >23CA,>C0C1,>06A0,>2406
        DATA >1102,>0460,>226A,>C020
        DATA >2038,>06A0,>211C,>6004
        DATA >0A10,>A0C0,>06A0,>23CA
        DATA >0452,>06A0,>227E,>0206
        DATA >834A,>CD83,>DDA0,>2058
        DATA >DD84,>CD81,>C0C1,>1602
        DATA >04D6,>1005,>0603,>06A0
        DATA >2406,>0981,>C581,>C020
        DATA >2044,>06A0,>22DA,>0460
        DATA >225A,>C80B,>203A,>C805
        DATA >203C,>C2E0,>601E,>069B
        DATA >C020,>2044,>C160,>203C
        DATA >D190,>0986,>C820,>830C
        DATA >203E,>C806,>830C,>C806
        DATA >8350,>C2E0,>6012,>069B
        DATA >C020,>2044,>0206,>834A
        DATA >0204,>001C,>CD84,>DDA0
        DATA >2058,>DD84,>C5A0,>831C
        DATA >C0A0,>830C,>1309,>C116
        DATA >C0C0,>0583,>D073,>06A0
        DATA >241A,>0584,>0602,>15FA
        DATA >C2E0,>6028,>069B,>C020
        DATA >2044,>C160,>203C,>C2E0
        DATA >203A,>045B,>C01D,>C06D
        DATA >0002,>06A0,>20DC,>C0C1
        DATA >0603,>0223,>8300,>D0D3
        DATA >0983,>0603,>1302,>0643
        DATA >1623,>C000,>1628,>C02D
        DATA >0004,>C0C5,>05C3,>06A0
        DATA >2406,>9801,>2058,>161D
        DATA >05C3,>06A0,>23CA,>C041
        DATA >1307,>C181,>0601,>C0C1
        DATA >06A0,>2406,>9050,>1A15
        DATA >DC01,>1309,>C0C6,>0981
        DATA >C141,>06A0,>2406,>DC01
        DATA >0583,>0605,>15FA,>0380
        DATA >06A0,>227E,>C02D,>0004
        DATA >10E6,>0460,>2166,>0460
        DATA >216E,>0200,>1300,>0460
        DATA >2084,>06C3,>D803,>8C02
        DATA >06C3,>D803,>8C02,>1000
        DATA >D060,>8800,>06C1,>D060
        DATA >8800,>06C1,>045B,>06C4
        DATA >D804,>8C02,>06C4,>0264
        DATA >4000,>D804,>8C02,>1000
        DATA >D801,>8C00,>06C1,>D801
        DATA >8C00,>06C1,>045B,>06C3
        DATA >D803,>8C02,>06C3,>D803
        DATA >8C02,>1000,>D060,>8800
        DATA >045B,>06C4,>D804,>8C02
        DATA >06C4,>0264,>4000,>D804
        DATA >8C02,>1000,>D801,>8C00
        DATA >045B,>C83E,>83E2,>02E0
        DATA >83E0,>C80B,>204E,>C081
        DATA >0281,>0040,>1B0A,>C0A1
        DATA >6010,>0281,>0004,>1605
        DATA >C0A2,>0002,>0692,>2466
        DATA >1001,>0692,>02E0,>2038
        DATA >C80B,>83F6,>0380,>0200
        DATA >0B00,>0460,>2084,>02E0
        DATA >83E0,>C80B,>204E,>06A0
        DATA >000E,>02E0,>2038,>C80B
        DATA >83F6,>0380,>06A0,>24CA
        DATA >D82D,>0002,>8C00,>0380
        DATA >06A0,>24CA,>D831,>8C00
        DATA >0602,>16FC,>0380,>06A0
        DATA >24D0,>DB60,>8800,>0002
        DATA >0380,>06A0,>24D0,>DC60
        DATA >8800,>0602,>16FC,>0380
        DATA >C05D,>D82D,>0001,>8C02
        DATA >0261,>8000,>D801,>8C02
        DATA >0380,>0201,>4000,>1001
        DATA >04C1,>C09D,>D820,>203D
        DATA >8C02,>E081,>D802,>8C02
        DATA >C06D,>0002,>C0AD,>0004
        DATA >045B
**********************************************************
EAINIT  MOV  R11,R9    * save return address
        CLR  R0        * ZERO OUT R0
        LI   R1,>2000  * Start address
        LI   R2,8192   * Counter
CLRINT  MOV  R0,*R1+   * CLEAR WORD 
        DECT R2        * Counter-2
        JNE  CLRINT    * ZERO?
        LI   R0,LOW1   * FOUR WORDS
        LI   R1,>2000  * Set up init
        BL   @FOURWS   * LOAD IT
        LI   R0,LOW2   * FOUR WORDS
        LI   R1,>2024  * Set up list 
        BL   @FOURWS   * LOAD IT
        LI   R0,LOW3   * Routines
        LI   R1,>20FA  * Set up routines
        LI   R2,1404   * Counter
SLOW3   MOV  *R0+,*R1+ * LOAD IT
        DECT R2        * Counter-2
        JNE  SLOW3     * ZERO? 
        LI   R0,LOW4   * Name List
        LI   R1,>3F38  * NAMES & Address
        LI   R2,200    * Counter
SLOW4   MOV  *R0+,*R1+ * LOAD IT
        DECT R2        * Counter-2
        JNE  SLOW4     * ZERO?
        B    @PAGER     * return to XB
************************
FOURWS  MOV  R11,R10
        MOV  *R0+,*R1+
        MOV  *R0+,*R1+
        MOV  *R0+,*R1+
        MOV  *R0+,*R1+
        B    *R10
**********************************************************
* EDITOR ASSEMBLER LOWER 8K SUPPORT
* Data for Initialization of
* Memory Expansion
***********************************
LOW1  DATA  >A55A,>2128,>2398,>225A
LOW2  DATA  >A000,>FFD7,>2676,>3F38
LOW3  DATA  >0064,>2000,>2EAA,>2094
      DATA  >21C4,>2094,>2196,>2094,>21DE,>2094,>21F4
      DATA  >2094,>2200,>2094,>220E,>2094,>221A,>2094,>2228
      DATA  >209A,>22B2,>20DA,>23BA,>C80B,>2030,>D060
      DATA  >8349,>2060,>20FC,>132A,>C020,>8350,>1311,>06A0
      DATA  >2646,>101E,>0281,>3F38,>1319,>C001,>0202
      DATA  >834A,>8CB0,>1611,>8CB0,>160F,>8CB0,>160D,>C810
      DATA  >2022,>02E0,>20BA,>C020,>2022,>1309,>0690
      DATA  >02E0,>83E0,>C2E0,>2030,>045B,>0221,>0008,>10E4
      DATA  >0200,>0F00,>D800,>8322,>02E0,>83E0,>0460
      DATA  >00CE,>5820,>20FC,>8349,>02E0,>2094,>0380,>C83E
      DATA  >83E2,>02E0,>83E0,>C80B,>20AA,>C081,>0281
      DATA  >8000,>1B07,>09C1,>0A11,>0A42,>09B2,>A0A1,>0CFA
      DATA  >C092,>0692,>02E0,>2094,>C80B,>83F6,>0380
      DATA  >D060,>8373,>0981,>C87E,>8304,>F820,>20FC,>8349
      DATA  >02E0,>83E0,>C2E0,>2030,>045B,>02E0,>83E0
      DATA  >C80B,>20AA,>06A0,>000E,>02E0,>2094,>C80B,>83F6
      DATA  >0380,>06A0,>223A,>D82D,>0002,>8C00,>0380
      DATA  >06A0,>223A,>D831,>8C00,>0602,>16FC,>0380,>06A0
      DATA  >2240,>DB60,>8800,>0002,>0380,>06A0,>2240
      DATA  >DC60,>8800,>0602,>16FC,>0380,>C05D,>D82D,>0001
      DATA  >8C02,>0261,>8000,>D801,>8C02,>0380,>0201
      DATA  >4000,>1001,>04C1,>C09D,>D820,>2099,>8C02,>E081
      DATA  >D802,>8C02,>C06D,>0002,>C0AD,>0004,>045B
      DATA  >0204,>834A,>C014,>C184,>04F6,>04F6,>C140,>1323
      DATA  >0740,>0203,>0040,>04F6,>04D6,>0280,>0064
      DATA  >1A13,>0280,>2710,>1A08,>0583,>C040,>04C0,>3C20
      DATA  >20FA,>D920,>83E3,>0003,>0583,>C040,>04C0
      DATA  >3C20,>20FA,>D920,>83E3,>0002,>D920,>83E1,>0001
      DATA  >D520,>83E7,>0545,>1101,>0514,>045B,>C17E
      DATA  >53E0,>20FC,>C020,>8356,>C240,>0229,>FFF8,>0420
      DATA  >2114,>D0C1,>0983,>0704,>0202,>208C,>0580
      DATA  >0584,>80C4,>1306,>0420,>2114,>DC81,>9801,>20FE
      DATA  >16F6,>C104,>1352,>0284,>0007,>154F,>04E0
      DATA  >83D0,>C804,>8354,>C804,>2036,>0584,>A804,>8356
      DATA  >C820,>8356,>2038,>02E0,>83E0,>04C1,>020C
      DATA  >0F00,>C30C,>1301,>1E00,>022C,>0100,>04E0,>83D0
      DATA  >028C,>2000,>1332,>C80C,>83D0,>1D00,>0202
      DATA  >4000,>9812,>20FF,>16EE,>A0A0,>20A4,>1003,>C0A0
      DATA  >83D2,>1D00,>C092,>13E6,>C802,>83D2,>05C2
      DATA  >C272,>D160,>8355,>1309,>9C85,>16F2,>0985,>0206
      DATA  >208C,>9CB6,>16ED,>0605,>16FC,>0581,>C801
      DATA  >203A,>C809,>2034,>C80C,>2032,>0699,>10E2,>1E00
      DATA  >02E0,>209A,>C009,>0420,>2114,>09D1,>1604
      DATA  >0380,>02E0,>209A,>04C1,>06C1,>D741,>F3E0,>20FC
      DATA  >0380,>C80B,>2030,>02E0,>20BA,>0420,>2124
      DATA  >02E0,>83E0,>1303,>C2E0,>2030,>045B,>D820,>20BA
      DATA  >8322,>0460,>00CE,>04E0,>2022,>53E0,>20FC
      DATA  >C020,>8356,>0420,>2120,>0008,>1332,>0220,>FFF7
      DATA  >0201,>0200,>0420,>210C,>0580,>C800,>202E
      DATA  >C1E0,>2024,>C147,>04CC,>06A0,>25E0,>0283,>0001
      DATA  >1624,>058C,>04C3,>1023,>0283,>0046,>161E
      DATA  >04C2,>06A0,>262E,>0283,>003A,>16F7,>C020,>202E
      DATA  >0600,>0201,>0100,>0420,>210C,>06A0,>25E0
      DATA  >C020,>2022,>1307,>06A0,>2646,>1005,>CB4E,>0016
      DATA  >C3A0,>2022,>0380,>D740,>F3E0,>20FC,>0380
      DATA  >06A0,>25C2,>04C4,>D123,>2662,>0974,>C808,>202C
      DATA  >06A0,>2594,>0464,>23F8,>0580,>0240,>FFFE
      DATA  >C120,>2024,>A100,>1808,>8804,>2026,>1B05,>C160
      DATA  >2024,>C804,>2024,>100A,>C120,>2028,>A100
      DATA  >8804,>202A,>140C,>C160,>2028,>C804,>2028,>C1C5
      DATA  >0209,>0008,>06A0,>262E,>0609,>16FC,>10B6
      DATA  >0200,>0800,>10CC,>A005,>C800,>2022,>10AF,>A800
      DATA  >202C,>13AC,>0200,>0B00,>10C2,>A005,>C1C0
      DATA  >10A6,>A005,>DDC0,>DDE0,>20DB,>10A1,>A005,>06A0
      DATA  >2566,>C000,>1316,>0226,>FFF8,>8106,>1B02
      DATA  >0514,>1096,>8594,>16F8,>89A4,>0002,>0002,>16F4
      DATA  >89A4,>0004,>0004,>16F0,>C0E6,>0006,>C250
      DATA  >C403,>C009,>16FC,>0224,>0008,>C804,>202A,>10EA
      DATA  >A005,>06A0,>2566,>0226,>FFF8,>8106,>13E3
      DATA  >C296,>1501,>050A,>8294,>16F7,>89A4,>0002,>0002
      DATA  >16F3,>89A4,>0004,>0004,>16EF,>C296,>1516
      DATA  >C0E6,>0006,>C253,>C4C0,>C0C9,>16FC,>C246,>6244
      DATA  >C286,>022A,>0008,>C0C6,>0643,>064A,>C693
      DATA  >0649,>16FB,>0224,>0008,>C804,>202A,>10D9,>CB44
      DATA  >0002,>0200,>0C00,>0460,>2432,>0460,>2494
      DATA  >C28B,>0209,>0006,>C1A0,>202A,>0226,>FFF8,>C106
      DATA  >8806,>2028,>1AF3,>C806,>202A,>06A0,>262E
      DATA  >DDA0,>20E1,>0609,>16FA,>C580,>0206,>4000,>045A
      DATA  >C28B,>04C0,>C30C,>1308,>06A0,>262E,>D020
      DATA  >20E1,>06A0,>262E,>A003,>045A,>0209,>0004,>06A0
      DATA  >262E,>06A0,>25C2,>0A40,>A003,>0609,>16F8
      DATA  >045A,>0223,>FFD0,>0283,>000A,>1A05,>0223,>FFF9
      DATA  >0283,>0019,>1B01,>045B,>0200,>0A00,>0460
      DATA  >2432,>02E0,>83E0,>0200,>2032,>C330,>C270,>C830
      DATA  >8354,>C830,>8356,>C050,>1D00,>9820,>4000
      DATA  >20FF,>161D,>0699,>101B,>1E00,>02E0,>20DA,>C020
      DATA  >202E,>0201,>20DB,>0202,>0004,>0420,>2118
      DATA  >7000,>0950,>1610,>0982,>C001,>0201,>203C,>0420
      DATA  >2118,>04C8,>0602,>11D7,>D0F1,>0983,>A203
      DATA  >045B,>02E0,>20DA,>04C0,>06C0,>0460,>2432,>0201
      DATA  >3F40,>0221,>FFF8,>C011,>1105,>8060,>202A
      DATA  >16F9,>05CB,>045B,>0200,>0D00,>045B,>2D52,>5163
      DATA  >6483,>8455,>045C,>5B5F,>5EF0,>F003,>F0F0
      DATA  >4700,>00C8,>3F38
LOW4  DATA  >5554,>4C54,>4142,>2022,>5041,>4420,>2020,>8300
      DATA  >4750,>4C57,>5320,>83E0,>534F,>554E,>4420
      DATA  >8400,>5644,>5052,>4420,>8800,>5644,>5053,>5441
      DATA  >8802,>5644,>5057,>4420,>8C00,>5644,>5057
      DATA  >4120,>8C02,>5350,>4348,>5244,>9000,>5350,>4348
      DATA  >5754,>9400,>4752,>4D52,>4420,>9800,>4752
      DATA  >4D52,>4120,>9802,>4752,>4D57,>4420,>9C00,>4752
      DATA  >4D57,>4120,>9C02,>5343,>414E,>2020,>000E
      DATA  >584D,>4C4C,>4E4B,>2104,>4B53,>4341,>4E20,>2108
      DATA  >5653,>4257,>2020,>210C,>564D,>4257,>2020
      DATA  >2110,>5653,>4252,>2020,>2114,>564D,>4252,>2020
      DATA  >2118,>5657,>5452,>2020,>211C,>4453,>524C
      DATA  >4E4B,>2120,>4C4F,>4144,>4552,>2124,>4750,>4C4C
      DATA  >4E4B,>2100
***********************************************************
* RXB ALL CHAR loader
***********************************************************
CHRALL MOV  R11,R9    * save return address
       LI   R0,>03F8  * VDP destination address
       BL   @VWADD    * write out VDP write address
       LI   R2,96     * COUNT
       LI   R8,VDPWD  * Register faster then address
CHRALP LI   R1,FAC    * CHAR 
       MOVB *R1+,*R8  * write next VDP byte from ROM 1
       MOVB *R1+,*R8  * write next VDP byte from ROM 2
       MOVB *R1+,*R8  * write next VDP byte from ROM 3
       MOVB *R1+,*R8  * write next VDP byte from ROM 4
       MOVB *R1+,*R8  * write next VDP byte from ROM 5
       MOVB *R1+,*R8  * write next VDP byte from ROM 6
       MOVB *R1+,*R8  * write next VDP byte from ROM 7
       MOVB *R1+,*R8  * write next VDP byte from ROM 8
       DEC  R2        * COUNT-1
       JNE  CHRALP    * Repeat if not done 
       B    @PAGER    * DONE
***********************************************************
* RXB Character set 
***********************************************************
CHRLDR MOV  R11,R9    * save return address
       LI   R0,>03F8  * VDP destination address
       BL   @VWADD    * write out VDP write address
       LI   R1,CHARS  * CHARACTER LIST
       LI   R2,96     * COUNT
       LI   R8,VDPWD  * Register faster then address
CHRLP  MOVB *R1+,*R8  * write next VDP byte from ROM 1
       MOVB *R1+,*R8  * write next VDP byte from ROM 2
       MOVB *R1+,*R8  * write next VDP byte from ROM 3
       MOVB *R1+,*R8  * write next VDP byte from ROM 4
       MOVB *R1+,*R8  * write next VDP byte from ROM 5
       MOVB *R1+,*R8  * write next VDP byte from ROM 6
       MOVB *R1+,*R8  * write next VDP byte from ROM 7
       MOVB *R1+,*R8  * write next VDP byte from ROM 8
       DEC  R2        * COUNT-1
       JNE  CHRLP     * Repeat if not done 
       B    @PAGER    * DONE
**************************************************
CHARS  BYTE >00,>00,>00,>00,>00,>00,>00,>00 *   31
       BYTE >00,>00,>00,>00,>00,>00,>00,>00 *   32
       BYTE >00,>10,>10,>10,>10,>00,>10,>00 * ! 33 
       BYTE >00,>28,>28,>28,>00,>00,>00,>00 * " 34
       BYTE >00,>28,>7C,>28,>28,>7C,>28,>00 * # 35
       BYTE >00,>38,>54,>30,>18,>54,>38,>00 * $ 36
       BYTE >00,>44,>4C,>18,>30,>64,>44,>00 * % 37
       BYTE >00,>20,>50,>20,>54,>48,>34,>00 * & 38
       BYTE >00,>08,>10,>20,>00,>00,>00,>00 * ' 39
       BYTE >00,>08,>10,>10,>10,>10,>08,>00 * ( 40
       BYTE >00,>20,>10,>10,>10,>10,>20,>00 * ) 41
       BYTE >00,>00,>28,>10,>7C,>10,>28,>00 * * 42
       BYTE >00,>10,>10,>7C,>10,>10,>00,>00 * + 43
       BYTE >00,>00,>00,>00,>00,>30,>10,>20 * , 44
       BYTE >00,>00,>00,>7C,>00,>00,>00,>00 * - 45
       BYTE >00,>00,>00,>00,>00,>30,>30,>00 * . 46
       BYTE >00,>04,>08,>10,>20,>40,>00,>00 * / 47
       BYTE >00,>3C,>4C,>54,>64,>44,>38,>00 * 0 48
       BYTE >00,>10,>30,>10,>10,>10,>38,>00 * 1 49
       BYTE >00,>38,>44,>08,>10,>20,>7C,>00 * 2 50
       BYTE >00,>38,>44,>18,>04,>44,>38,>00 * 3 51
       BYTE >00,>08,>18,>28,>48,>7C,>08,>00 * 4 52
       BYTE >00,>78,>40,>78,>04,>44,>38,>00 * 5 53
       BYTE >00,>38,>40,>78,>44,>44,>38,>00 * 6 54
       BYTE >00,>7C,>04,>08,>10,>20,>20,>00 * 7 55
       BYTE >00,>38,>44,>38,>44,>44,>38,>00 * 8 56
       BYTE >00,>38,>44,>44,>3C,>04,>78,>00 * 9 57
       BYTE >00,>00,>30,>30,>00,>30,>30,>00 * : 58
       BYTE >00,>00,>30,>30,>00,>30,>10,>20 * ; 59
       BYTE >00,>00,>10,>20,>40,>20,>10,>00 * < 60
       BYTE >00,>00,>00,>7C,>00,>7C,>00,>00 * = 61
       BYTE >00,>00,>10,>08,>04,>08,>10,>00 * > 62
       BYTE >00,>38,>44,>08,>10,>00,>10,>00 * ? 63
       BYTE >00,>38,>44,>54,>58,>40,>3C,>00 * @ 64
       BYTE >00,>38,>44,>44,>7C,>44,>44,>00 * A 65
       BYTE >00,>78,>24,>38,>24,>24,>78,>00 * B 66
       BYTE >00,>38,>44,>40,>40,>44,>38,>00 * C 67
       BYTE >00,>78,>24,>24,>24,>24,>78,>00 * D 68
       BYTE >00,>7C,>40,>78,>40,>40,>7C,>00 * E 69
       BYTE >00,>7C,>40,>78,>40,>40,>40,>00 * F 70
       BYTE >00,>38,>44,>40,>4C,>44,>38,>00 * G 71
       BYTE >00,>44,>44,>7C,>44,>44,>44,>00 * H 72
       BYTE >00,>38,>10,>10,>10,>10,>38,>00 * I 73
       BYTE >00,>04,>04,>04,>04,>44,>38,>00 * J 74
       BYTE >00,>44,>48,>50,>70,>48,>44,>00 * K 75
       BYTE >00,>40,>40,>40,>40,>40,>7C,>00 * L 76
       BYTE >00,>44,>6C,>54,>44,>44,>44,>00 * M 77
       BYTE >00,>44,>64,>54,>54,>4C,>44,>00 * N 78
       BYTE >00,>38,>44,>44,>44,>44,>38,>00 * O 79 
       BYTE >00,>78,>44,>44,>78,>40,>40,>00 * P 80
       BYTE >00,>38,>44,>44,>54,>4C,>3C,>00 * Q 81
       BYTE >00,>78,>44,>44,>78,>48,>44,>00 * R 82
       BYTE >00,>38,>44,>30,>08,>44,>38,>00 * S 83
       BYTE >00,>7C,>10,>10,>10,>10,>10,>00 * T 84
       BYTE >00,>44,>44,>44,>44,>44,>38,>00 * U 85
       BYTE >00,>44,>44,>44,>44,>28,>10,>00 * V 86
       BYTE >00,>44,>44,>44,>54,>54,>28,>00 * W 87
       BYTE >00,>44,>28,>10,>10,>28,>44,>00 * X 88
       BYTE >00,>44,>44,>28,>10,>10,>10,>00 * Y 89
       BYTE >00,>7C,>08,>10,>20,>40,>7C,>00 * Z 90
       BYTE >00,>38,>20,>20,>20,>20,>38,>00 * [ 91
       BYTE >00,>00,>40,>20,>10,>08,>04,>00 * \ 92
       BYTE >00,>38,>08,>08,>08,>08,>38,>00 * ] 93
       BYTE >00,>10,>38,>54,>10,>10,>10,>00 * ^ 94
       BYTE >00,>00,>00,>00,>00,>00,>7C,>00 * _ 95
       BYTE >00,>20,>10,>08,>00,>00,>00,>00 * ` 96
       BYTE >00,>00,>00,>38,>48,>48,>3C,>00 * a 97
       BYTE >00,>20,>20,>38,>24,>24,>38,>00 * b 98
       BYTE >00,>00,>00,>1C,>20,>20,>1C,>00 * c 99
       BYTE >00,>04,>04,>1C,>24,>24,>1C,>00 * d 100
       BYTE >00,>00,>00,>1C,>28,>30,>1C,>00 * e 101
       BYTE >00,>0C,>10,>38,>10,>10,>10,>00 * f 102
       BYTE >00,>00,>00,>1C,>24,>1C,>04,>38 * g 103
       BYTE >00,>20,>20,>38,>24,>24,>24,>00 * h 104
       BYTE >00,>10,>00,>30,>10,>10,>38,>00 * i 105
       BYTE >00,>08,>00,>08,>08,>08,>48,>30 * j 106
       BYTE >00,>20,>20,>24,>38,>28,>24,>00 * k 107
       BYTE >00,>30,>10,>10,>10,>10,>38,>00 * l 108
       BYTE >00,>00,>00,>78,>54,>54,>54,>00 * m 109
       BYTE >00,>00,>00,>38,>24,>24,>24,>00 * n 110
       BYTE >00,>00,>00,>18,>24,>24,>18,>00 * o 111
       BYTE >00,>00,>00,>38,>24,>38,>20,>20 * p 112
       BYTE >00,>00,>00,>1C,>24,>1C,>04,>04 * q 113
       BYTE >00,>00,>00,>28,>34,>20,>20,>00 * r 114
       BYTE >00,>00,>00,>1C,>30,>0C,>38,>00 * s 115
       BYTE >00,>10,>10,>38,>10,>10,>0C,>00 * t 116
       BYTE >00,>00,>00,>24,>24,>24,>1C,>00 * u 117 
       BYTE >00,>00,>00,>44,>28,>28,>10,>00 * v 118
       BYTE >00,>00,>00,>44,>54,>54,>28,>00 * w 119
       BYTE >00,>00,>00,>24,>18,>18,>24,>00 * x 120
       BYTE >00,>00,>00,>24,>24,>1C,>04,>38 * y 121
       BYTE >00,>00,>00,>3C,>08,>10,>3C,>00 * z 122
       BYTE >00,>0C,>10,>10,>20,>10,>10,>0C * { 123
       BYTE >00,>10,>10,>10,>00,>10,>10,>10 * | 124
       BYTE >00,>60,>10,>10,>08,>10,>10,>60 * } 125
       BYTE >00,>00,>20,>54,>08,>00,>00,>00 * ~ 126
**********************************************************
* CALL HEX($variable,variable,...)                       *
* CALL HEX(variable,$variable,...)                       *
* CALL HEX(">####",variable,...)                         *
**********************************************************
* HEX VDP to RAM (String to Address) LES version
* R0 TEMP ASC TO HEX    
* R1 HEX ADDRESS        = FAC
* R2 STRING             = PAD 
* R3 COUNTER            = R3
ASCHEX MOV  R11,R9      * save return address
       CLR  R1          * clear result reg
       LI   R2,PAD      * assume 4-bytes in PAD-PAD3
       LI   R3,4        * load counter
HEX01  CLR  R0          * zero out work reg
       MOVB *R2+,R0     * Get ASC byte
       SWPB R0          * get byte to LSB
* ASC CHECK VALUE
       CI   R0,103      * g ?
       JHE  ERROR       * ERROR BAD ARGUMENT
       CI   R0,97       * a ?
       JHE  HEX02       * Valid
       CI   R0,71       * G ?
       JHE  ERROR       * ERROR BAD ARGUMENT 
       CI   R0,65       * A ?
       JHE  HEX02       * Valid
       CI   R0,58       * : ?
       JHE  ERROR       * ERROR BAD ARGUMENT
       CI   R0,47       * / ?
       JLE  ERROR       * ERROR BAD ARGUMENT
* Convert ASC to value
HEX02  AI   R0,>FFD0    * correct for 0-9 in LSB
       CI   R0,>000A    * LSB < 10?
       JLT  HEX03       * we're good
       AI   R0,>FFF9    * correct LSB for A-F
* Add digit and shift if not done
HEX03  A    R0,R1       * add hex digit to result reg LSB
       DEC  R3          * decrement counter
       JEQ  HEX04       * return if done
       SLA  R1,4        * shift hex digit left 1 nybble
       JMP  HEX01       * get another hex digit
HEX04  MOV  R1,@FAC     * get result to FAC for CIF
       B    @PAGER      * return to XB
ERROR  LI   R1,>994A    * ERROR CODE FLAG
       MOV  R1,@ARG     * LOAD ERROR CODE FLAG
       B    @PAGER     * return to XB
***********************************************************
* CALL ALPHALOCK(numeric-variable)                        *
***********************************************************
ALPHA  MOV  R11,R9     * save return address
       MOV  R12,R8     * save R12 value for later
       CLR  R12        * ZERO OUT R12
       SBZ  21         * PUT ALPHA LOCK STROBE
       SRC  R12,14     * WAIT
       TB   7          * ALPHA LOCK DOWN?
       SBO  21         * RESET ALPHA LOCK STROBE
       JEQ  ALPHAF     * RETURN ALPHA LOCK OFF 
       LI   R1,>994A   * ALPHA LOCK ON     
ALPHAO MOV  R8,R12     * Restore R12 
       MOV  R1,@FAC    * Save value to FAC
       B    @PAGER     * return to XB
ALPHAF CLR  R1         * ZERO OUT FLAG
       JMP  ALPHAO     * ALPHA LOCK OFF
***********************************************************
* CALL ISRON(variable)                                    *
***********************************************************
XISRON MOV  R11,R9       * save return address
       MOV  @FAC,@ISR    * Put FAC into ISR Interupt hook
       JMP  NEXIT        * exit
***********************************************************
* CALL ISROFF(variable)                                   *  
***********************************************************
XISROF MOV  R11,R9       * save return address
       MOV  @ISR,@ISR    * Compare if new ISR HOOK
       JEQ  NHOOK        * No 
       MOV  @ISR,@FAC    * Put ISR Hook into FAC
NHOOK  CLR  @ISR         * Clear ISR Hook
NEXIT  CLR  @STATUS      * Clear GPL stuse byte
       B    @PAGER       * return to XB
************************
SPRLP  MOVB R1,*R8     * Write a byte to next VRAM location
       DEC  R2         * COUNT-1  
       JNE  SPRLP      * LOOP
       RT
***********************************************************
* CALL CHAR(char-code,definition[,...])                   *
* CALL CHAR(ALL,definition[,...])                         *
***********************************************************
*  VAR9 <--ASCII code of char.....CDT address of char--> R4
*     VAR9 = PAD+20 = >8314
*  FAC4 <--XB chr str ptr..ptr to str left to process--> R5
*  FAC6    Length of char string                         R3
*          Temporary counter                             R6
*          Temporary counter                             R7
*          VDPWD write data register                     R8
*          Save return address for PAGER                 R9
*          VDPRD read data register                     R10
*          VDP address                                   R0
*          VDP character                                 R1
*          Temporary counter                             R2
*  PAD (>8300..>830F) 16-byte buffer for a single character
*     string and its resultant 8-byte hexadecimal string
*  ARG2    address after end of XB string
***********************************************************
*
GR5LB  EQU  >83EB
*
* Get Character Code & adjust for Character Definition
*  Table (CDT) address.
DCHAR  MOV  R11,R9     * Save return address
*
* Set up VDP write data register (saves 4 bytes)
       LI   R8,VDPWD   * VDP Write Data register
*
* Set to CDT address of first character if string length>0
       MOV  @FAC4,R5   * get pointer to XB string address
       MOV  @FAC6,R3   * get length of XB string..=0?
       JEQ  JERR       * yes..so ERROR BAD ARGUMENT
       MOV  R5,@ARG2   * no..XB string address to ARG2
       A    R3,@ARG2   * address after end of XB string
       MOV  @VAR9,R4   * Get char-code
       SLA  R4,3       * Convert char-code to CDT address
       AI   R4,>0300   * Correct for XB offse
SCCHR  C    R5,@ARG2   * Done?
       JHE  CHAREX     * yes..back to XB
       BL   @SETPAD    * Set up PAD for use
       BL   @ASC2HX    * do ASCII-to-hex conversion
       CI   R3,0       * 0? ZERO LENGTH?
       JEQ  CHAREX     * LOOP 
       AI   R4,8       * CDT address to next char pattern
       CI   R4,>0780   * address within CDT?
       JLT  SCCHR      * yes..keep using XB string
CHAREX CLR  @ARG       * clear error flag
       B    @PAGER     * exit to XB
*
*==========================================================
* ASCII-to-Hexadecimal Conversion/Copy Subroutine *********
*==========================================================
*
* Zero out PAB 16 bytes '0' (>30)
SETPAD SETO R12        * Set nybble toggle
       LI   R2,8       * Max # of words
       LI   R7,PAD     * PAD RAM buffer
       LI   R1,>3030   * 2 ASCII zeros
ZPAD   MOV  R1,*R7+    * clear 2 bytes with ASCII zeros
       DEC  R2         * count -1
       JNE  ZPAD       * LOOP 
       RT              * return to caller  
*
* Get String Into PAD
ASC2HX LI   R2,16      * Set max count chars to process
       C    R3,R2      * remaining XB string length < 16?
       JGT  OKPAD      * no..process 16 characters 
       MOV  R3,R2      * yes..set to actual characters left
OKPAD  S    R2,R3      * update running XB string length
       LI   R1,PAD     * Get string into PAD
       MOV  R1,R7      * saves 4 bytes at CONVRT
       MOVB @GR5LB,*R15    * write LSB of R5 to VDPWA
       MOVB R5,*R15        * write MSB of R5 to VDPWA
       LI   R10,VDPRD  * VDP Read Data register
       A    R2,R5      * update running XB string adress
LDPAD  MOVB *R10,*R1+  * Put next char into PAD buffer
       DEC  R2         * more chars?
       JNE  LDPAD      * yes..get next char
*
* Convert From Char String To Hex
CONVRT MOV  R7,R6      * hex and nybble strings both at PAD
       LI   R2,16      * Counter
       CLR  R1         * insure LSB is >00
CONPAD MOVB *R6+,R1    * get byte
       AI   R1,->3000  * ASCII to binary..
*                      * assume is a good digit
       CI   R1,>0A00   * MSB logical < 10?, i.e., 0 to 9?
       JL   NIBB       * yes..process it
       AI   R1,->0700  * no, subtract hole between 9 and A
       CI   R1,>0A00   * logical >= 10? includes neg digit
       JHE  CONVT1     * if yes, test if a good hex digit
       JMP  JERR       * error..invalid digit
*
CONVT1 CI   R1,>0F00   * logical <= F?
       JLE  NIBB       * if yes, good digit..
*                      * catches neg digit
*
JERR   B    @ERROR     * ERROR BAD VALUE
*
* Get Hex Character to Correct Nybble
NIBB   INV  R12        * toggle nybble toggle..=0?
       JNE  NIBB1      * no..skip left shift
       SLA  R1,4       * shift left 1 nybble (MSN)
       MOVB R1,*R7     * Save left nybble to 
*                      * current byte of PAD buffer
       JMP  NIBB2      * 
*
NIBB1  AB   R1,*R7+    * Save result to PAD buffer
NIBB2  DEC  R2         * more chars?
       JNE  CONPAD     * yes..get next char
*
* Copy Hex String from PAD to VDP
HEXCPY LI   R2,8       * count
HEXCHR LI   R6,PAD     * PAD has combined values
       MOV  R4,R0      * XB char definition address
       ORI  R0,>4000       * set to write VRAM data
       MOVB @GR0LB,*R15    * write LSB of R0 to VDPWA
       MOVB R0,*R15        * write MSB of R0 to VDPWA
LDCHR  MOVB *R6+,*R8   * put next byte into CDT
       DEC  R2         * more bytes?
       JNE  LDCHR      * yes..get next byte
       RT              * no..return to caller
***********************************************************
* CALL CHARPAT(char-code,string-variable,...)             *
***********************************************************
* VAR9 CHARACTER CODE                 R5
* FAC4 VDP ADDRESS OF STRING VARIABLE R4
*
CHRPAT MOV  R11,R9     * Save return address
       MOV  @FAC4,R4   * get pointer to XB string address
       MOV  @VAR9,R5   * Get char-code
       SLA  R5,3       * Convert char-code to CDT address
       AI   R5,>0300   * Correct for XB offset
* MOVE AT CHAR TABLE TO ARG (8 BYTES)
       LI   R2,8       * COUNTER
       LI   R3,ARG     * BUFFER in PAD
       MOV  R5,R0      * Copy VDP Char Address
       BL   @VWADDA    * write out VDP read address
       LI   R8,VDPRD   * Register faster then address
CHRMOV MOVB *R8,*R3+   * read next VDP byte to RAM
       DEC  R2         * COUNTER-1
       JNE  CHRMOV     * Put char table into ARG
* CONVERT EACH NIBBLE TO HEX IN PAD (16 BYTES)
       LI   R2,8       * COUNTER
       LI   R3,ARG     * Char Table Buffer
       LI   R7,PAD     * ASCII VALUE BUFFER
ARGPAD CLR  R1         * CLEAR BOTH BYTES
       CLR  R6         * CLEAR BOTH BYTES
       MOVB *R3+,R0    * GET BYTE
       MOVB R0,R1      * COPY BYTE
       SRA  R0,4       * STRIP OFF LOW NIBBLE
       MOVB R0,R6      * SAVE ADJUSTED VALUE 
       AI   R6,>3000   * ADD 48 TO VALUE
       CI   R6,>3A00   * Above 9? 
       JL   SAVPD1     * No
       AI   R6,>0700   * ADD 65 TO VALUE
SAVPD1 MOVB R6,*R7+    * SAVE IT IN PAD
       SLA  R1,4       * STRIP OFF HIGH NIBBLE 
       SRA  R1,4       * RESET THIS NIBBLE 
       AI   R1,>3000   * ADD 48 TO VALUE
       CI   R1,>3A00   * Above 9?
       JL   SAVPD2     * No
       AI   R1,>0700   * ADD 65 TO VALUE 
SAVPD2 MOVB R1,*R7+    * SAVE IT IN PAD 
       DEC  R2         * COUNTER-1
       JNE  ARGPAD     * LOOP       
* MOVE PAD BUFFER TO VDP XB STRING ADDRESS R4
       MOV  R4,R0      * GET XB STRING ADDRESS 
       LI   R1,PAD     * PAD ADDRESS
       LI   R2,16      * COUNTER
       BL   @VWADD     * write out VDP write address
       LI   R8,VDPWD   * Register faster then address
XBSTR  MOVB *R1+,*R8   * MOVE IT FROM PAD TO VDP
       DEC  R2         * COUNTER=1 
       JNE  XBSTR      * LOOP
* GO BACK TO XB
       B    @PAGER     * RETURN TO XB
***********************************************************
* SPNUM  EQU  >03AA    * VDP SPRITE NUMBER 
* PAD8   EQU  >8308    * COPY OF RESULT
*
SPSPD5 MOV  R11,R9     * Save return address
       LI   R0,>03AA   * Save Sprite# into VDP 
       BL   @VWADD     * write out VDP write address
       LI   R8,VDPWD   * Register faster then address
       MOVB @FAC1,*R8  * MOVE IT FROM FAC1 TO VDP
       MOV  @FAC,R7    * Get Sprite# 
       DEC  R7         * Adjust for internal use
       SLA  R7,2       * Get location of SAL
       AI   R7,>0300   * Sprite # * 4 + >0300
       MOV  R7,@FAC    * Save to FAC
       MOV  R7,@>8308  * Save a copy to PAD8
* GO BACK TO XB
       B    @PAGER     * RETURN TO XB
***********************************************************
* CALL DELSPRITE(#SPR,...)                                *
* CALL DELSPRITE(ALL)                                     *
***********************************************************
* NOMSPR EQU  >837A      * NUMBER OF MOVING SPRITES
* SPNUM  EQU  >03AA      * Sprite number temporary
*
SPDEL  MOV  R11,R9     * Save return address
       MOV  @PAD8,R0   * GET PAD8 INTO R0
       AI   R0,>0480   * ADD >0480
       BL   @VWADD     * write out VDP write address
       LI   R8,VDPWD   * Register faster then address          
       LI   R7,>C000   * Set up off screen sprites
       MOVB R7,*R8     * >C0 INTO VDP
       CLR  R6         * ZERO OUT R6
       MOVB R6,*R8     * >00 INTO VDP
       LI   R0,>03AA   * VDP ADDRESS
       BL   @VWADDA    * write out VDP read address
       LI   R8,VDPRD   * Register faster then address
       MOVB *R8,R6     * GET VALUE
       CB   @>837A,R6  * SAME?
       JNE  SPDEL2     * No, exit 
SPDEL1 DEC  @>837A     * SPRITE#-1
       JEQ  SPDEL2     * 0? Yes, exit
       MOV  @PAD8,R0   * GET VDP ADDRESS
       DECT R0         * -2
       DECT R0         * -2      
       BL   @VWADDA    * write out VDP read address
       LI   R8,VDPRD   * Register faster then address
       MOVB *R8,R3     * GET VALUE
       SWPB R3         * SWAP BYTE
       MOVB *R8,R3     * GET VALUE
       CI   R3,>0000   * 0000?
       JEQ  SPDEL1     * LOOP
SPDEL2 B    @PAGER     * Return to XB 
***********************************************************

       AORG >7FFA
PAGER  CLR  @>6000     * RESTORE PAGE ONE
       B    *R9        * return to caller   
***********************************************************
       END
