99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0001 
Version 2.0 (Weiand 1985)     Options : LCSFPF                                  
[0001]               ***********************************************************
[0002]                      TITL 'RXB 2024'
[0003]                      GROM >8000
[0004]               ***********************************************************
[0005]               * RAM EXPANSION ADDRESS
[0006] A040          CPUBAS EQU  >A040             Expansion RAM base
[0007]               ***********************************************************
[0008]               *           GROM ADDRESSES
[0009]               ***********************************************************
[0010]               *    EQUATES FOR ROUTINES FROM OTHER GROM SECTIONS
[0011]               * GROM >0000
[0012] 0022          ATNZZ  EQU  >0022             Arctangent routine
[0013]               * GROM >6000
[0014] 6012          TOPL15 EQU  >6012             RETURN FROM OLD  or SAVE
[0015] 6014          INITPG EQU  >6014             Initialize program space
[0016] 601A          TOPL10 EQU  >601A             Return to main and re-init
[0017] 6022          KILSYM EQU  >6022             KILL SYMBOL TABLE ROUTINE
[0018] 6030          TOPL02 EQU  >6030             RTN address for failing AUTOL
[0019] 6032          EDITLN EQU  >6032             Edit a line into the program
[0020] 6036          GWSUB  EQU  >6036             Write a few bytes of data to
[0021] 6A74          LLIST  EQU  >6A74             List a line
[0022] 6A76          READLN EQU  >6A76             Read a line from keyboard
[0023] 6A82          WARNZZ EQU  >6A82             WARNING MESSAGE ROUTINE
[0024] 6A84          ERRZZ  EQU  >6A84             ERROR MESSAGE ROUTINE
[0025] 6A86          READL1 EQU  >6A86             Read a line from keyboard
[0026] 7A06          GTLIST EQU  >7A06             GKXB address
[0027]               * GROM >A000
[0028] A002          LITS05 EQU  >A002             Literal string common code
[0029] A006          LINE   EQU  >A006             GET LINE NUMBER ROUTINE
[0030] A008          DATAST EQU  >A008             SEARCH FOR NEXT "DATA" STATEM
[0031] A012          CONV1  EQU  >A012             CONVERT WITH WARNING
[0032] A016          VALCD  EQU  >A016             CONVERT STRING TO NUMBER
[0033] A020          UBSUB  EQU  >A020             CLEAR BREAKPOINTS IN LN # TAB
[0034]               ***********************************************************
[0035]               *    Equates for routine in MONITOR
[0036] 0010          CALDSR EQU  >10               CALL DEVICE SERVICE ROUTINE
[0037] 0012          CFI    EQU  >12               CONVERT TO TWO BYTE INTEGER
[0038] 0034          TONE1  EQU  >34               ACCEPT TONE
[0039] 0036          TONE2  EQU  >36               BAD TONE
[0040] 0018          CHAR2Z EQU  >18               CHARACTER TABLE ADDRESS
[0041] 004A          CHAR3Z EQU  >4A               CHARACTER TABLE ADDRESS
[0042]               ***********************************************************
[0043]               *    Equates for XMLs
[0044] 0000          SYNCHK EQU  >00               SYNCHK XML selector
[0045] 0001          FILSPC EQU  >01               Fill-space utility
[0046] 0002          CSTRIN EQU  >02               Copy-string utility
[0047] 0003          SEETWO EQU  >03               SEETWO XML selector
[0048] 0070          COMPCT EQU  >70               PREFORM A GARBAGE COLLECTION
[0049] 0071          GETSTR EQU  >71               SYSTEM GET STRING
[0050] 0072          MEMCHK EQU  >72               MEMORY check routine: VDP
[0051] 0073          XCNS   EQU  >73               Convert number to string
[0052]               * Warning Default changed in >0073
[0053] 0074          PARSE  EQU  >74               Parse a value
[0054] 0075          CONT   EQU  >75               Continue parsing
[0055] 0077          VPUSH  EQU  >77               Push on value stack
[0056] 0078          VPOP   EQU  >78               Pop off value stack
[0057] 0079          PGMCHR EQU  >79               GET PROGRAM CHARACTER
[0058] 007A          SYM    EQU  >7A               Find SYMBOL entry
[0059] 007B          SMB    EQU  >7B               Also for ARRAYS
[0060] 007C          ASSGNV EQU  >7C               Assign VARIABLE
[0061] 007D          SCHSYM EQU  >7D               Search symbol table
[0062] 007E          SPEED  EQU  >7E               SPEED UP XML
[0063] 007F          CRUNCH EQU  >7F               Crunch an input line
[0064] 0080          CIF    EQU  >80               Convert INTEGER to FLOATING P
[0065] 0081          CONTIN EQU  >81               Continue after a break

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0002 
RXB 2024
[0066] 0083          SCROLL EQU  >83               SCROLL THE SCREEN
[0067] 0084          IO     EQU  >84               IO utility (KW table search)
[0068] 0085          GREAD  EQU  >85               READ DATA FROM ERAM
[0069] 0086          GWRITE EQU  >86               WRITE DATA TO ERAM
[0070] 0087          DELREP EQU  >87               REMOVE CONTENT FROM VDP/ERAM
[0071] 0088          MVDN   EQU  >88               MOVE DATA IN VDP/ERAM
[0072] 0089          MVUP   EQU  >89               MOVE DATA IN VDP/ERAM
[0073] 008A          VGWITE EQU  >8A               MOVE DATA FROM VDP TO ERAM
[0074] 008B          GVWITE EQU  >8B               WRITE DATA FROM GRAM TO VRAM
[0075] 008C          GREAD1 EQU  >8C               READ DATA FROM ERAM
[0076] 008E          GDTECT EQU  >8E               ERAM DETECT&ROM PAGE 1 ENABLE
[0077] 008F          SCNSMT EQU  >8F               SCAN STATEMENT FOR PRESCAN
[0078]               ***********************************************************
[0079]               *    Temporary workspaces in EDIT
[0080] 8300          VAR0   EQU  >8300            TEMPORARY
[0081] 8301          VAR1   EQU  >8301            TEMPORARY
[0082] 8302          ACCUM  EQU  >8302            # OF BYTES ACCUMULATOR (4 BYTE
[0083] 8302          STPT   EQU  >8302            TWO BYTES
[0084] 8302          MNUM   EQU  >8302            Ussually a counter
[0085] 8302          AAA1   EQU  >8302
[0086] 8304          VARY   EQU  >8304
[0087] 8304          PABPTR EQU  >8304            Pointer to current PAB
[0088] 8306          VARY2  EQU  >8306            Use in MVDN only
[0089] 8306          DFLTLM EQU  >8306            Default array limit (10)
[0090] 8306          CCPPTR EQU  >8306            OFFSET WITHIN RECORED (1)
[0091]               *                             or Pointer to current column
[0092] 8307          RECLEN EQU  >8307            LENGTH OF CURRENT RECORD (1)
[0093] 8308          CCPADR EQU  >8308            RAM address of current refs
[0094]               *                             or Actual buffer address or c
[0095] 8308          VARC   EQU  >8308
[0096] 8308          CCPADD EQU  >8308            RAM address of current color
[0097] 8308          CCC1   EQU  >8308
[0098] 830A          CALIST EQU  >830A            Call list for resolving refs
[0099] 830A          RAMPTR EQU  >830A            Pointer for crunching
[0100] 830A          STADDR EQU  >830A            Start address - usually for co
[0101] 830C          BYTES  EQU  >830C            BYTE COUNTER
[0102]               *                             or String length for GETSTR
[0103] 830C          NMPTR  EQU  >830C            Pointer save for pscan
[0104] 830C          BBB1   EQU  >830C
[0105] 830E          CHSAV  EQU  >830E
[0106] 830E          CURINC EQU  >830E            Increment for auto-num mode
[0107] 830E          VAR4   EQU  >830E
[0108] 8310          TOPSTK EQU  >8310            Top of data stack pointer
[0109] 8310          VAR5   EQU  >8310
[0110] 8311          VAR6   EQU  >8311
[0111] 8312          LINUM  EQU  >8312            Used to determine end of scan
[0112] 8314          NMLEN  EQU  >8314            Current line for auto-num
[0113] 8314          CURLIN EQU  >8314            Current line for auto-num
[0114]               *                             or Starting line number for L
[0115] 8316          VAR9   EQU  >8316
[0116] 8316          XFLAG  EQU  >8316            SCAN FLAG-BITS USED AS BELOW
[0117] 8317          DSRFLG EQU  >8317            INTERNAL =60, EXTERNAL =0 (1)
[0118] 8317          OPTFLG EQU  >8317            Option flag byte during OPEN
[0119] 8317          FORNET EQU  >8317            Nesting level of for/next
[0120] 8317          FNUM   EQU  >8317            Current file number for search
[0121]               ***********************************************************
[0122]               *    Permanent workspace variables
[0123] 8318          STRSP  EQU  >8318            String space begining
[0124] 831A          STREND EQU  >831A            String space ending
[0125] 831C          SREF   EQU  >831C            Temporary string pointer
[0126] 831E          SMTSRT EQU  >831E            Start of current statement
[0127] 8320          VARW   EQU  >8320            Screen address (CURSOR)
[0128] 8322          ERRCOD EQU  >8322            Return error code from ALC
[0129] 8324          STVSPT EQU  >8324            Value-stack base

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0003 
RXB 2024
[0130] 8326          RTNG   EQU  >8326            Return vector from 9900 code
[0131] 8328          NUDTAB EQU  >8328            Start of NUD table
[0132] 832A          VARA   EQU  >832A            Ending display location
[0133] 832C          PGMPTR EQU  >832C            Program text pointer (TOKEN)
[0134] 832E          EXTRAM EQU  >832E            Line number table pointer
[0135] 8330          STLN   EQU  >8330            Start of line number table
[0136] 8332          ENLN   EQU  >8332            End of line number table
[0137] 8334          DATA   EQU  >8334            Data pointer for READ
[0138] 8336          LNBUF  EQU  >8336            Line table pointer for READ
[0139] 8338          INTRIN EQU  >8338            Add of intrinsic poly constant
[0140] 833A          SUBTAB EQU  >833A            Subprogram symbol table
[0141] 833C          IOSTRT EQU  >833C            PAB list/Start of I/O chain
[0142] 833E          SYMTAB EQU  >833E            Symbol table pointer
[0143] 8340          FREPTR EQU  >8340            Free space pointer
[0144] 8342          CHAT   EQU  >8342            Current charater/token
[0145] 8343          BASE   EQU  >8343            OPTION BASE value
[0146] 8344          PRGFLG EQU  >8344            Program/imperative flag
[0147] 8345          FLAG   EQU  >8345            General 8-bit flag
[0148] 8346          BUFLEV EQU  >8346            Crunch-buffer destruction leve
[0149] 8348          LSUBP  EQU  >8348            Last subprogram block on stack
[0150]               * FAC  EQU  >834A            Floating-point ACcurmulator
[0151] 834B          FAC1   EQU  FAC+1
[0152] 834C          FAC2   EQU  FAC+2
[0153] 834C          AAA    EQU  FAC+2
[0154] 834D          FAC3   EQU  FAC+3
[0155] 834E          FAC4   EQU  FAC+4
[0156] 834E          CCC    EQU  FAC+4
[0157] 834E          FFF    EQU  FAC+4
[0158] 834F          FAC5   EQU  FAC+5
[0159] 8350          FAC6   EQU  FAC+6
[0160] 8350          BBB    EQU  FAC+6
[0161] 8350          EEE    EQU  FAC+6
[0162] 8351          FAC7   EQU  FAC+7
[0163] 8352          FAC8   EQU  FAC+8
[0164] 8353          FAC9   EQU  FAC+9
[0165] 8354          FAC10  EQU  FAC+10
[0166] 8354          DDD1   EQU  FAC+10
[0167] 8355          FAC11  EQU  FAC+11
[0168] 8356          FAC12  EQU  FAC+12
[0169] 8356          FFF1   EQU  FAC+12
[0170] 8357          FAC13  EQU  FAC+13
[0171] 8358          FAC14  EQU  FAC+14
[0172] 8358          EEE1   EQU  FAC+14
[0173] 8359          FAC15  EQU  FAC+15
[0174] 835A          FAC16  EQU  FAC+16
[0175] 835B          FAC17  EQU  FAC+17
[0176]               * ARG  EQU  >835C             Floating-point ARGument
[0177] 835D          ARG1   EQU  ARG+1
[0178] 835E          ARG2   EQU  ARG+2
[0179] 835F          ARG3   EQU  ARG+3
[0180] 8360          ARG4   EQU  ARG+4
[0181] 8361          ARG5   EQU  ARG+5
[0182] 8362          ARG6   EQU  ARG+6
[0183] 8363          ARG7   EQU  ARG+7
[0184] 8364          ARG8   EQU  ARG+8
[0185] 8364          XSTLN  EQU  >8364            GKXB variable
[0186] 8366          TEMP5  EQU  >8366
[0187] 8367          ARG11  EQU  ARG+11
[0188] 836B          ARG15  EQU  ARG+15
[0189] 836C          ARG16  EQU  ARG+16
[0190]               * VSPTR  EQU  >836E          Value stack pointer
[0191]               ***********************************************************
[0192]               *    GPL Status Block
[0193] 8370          HIVDP  EQU  >8370             Highest VDP available

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0004 
RXB 2024
[0194] 8372          STACK  EQU  >8372             STACK FOR DATA
[0195] 8374          KEYBD  EQU  >8374             KEYBOARD SELCTION
[0196] 8375          RKEY   EQU  >8375             KEY CODE
[0197] 8376          EXPZ   EQU  >8376             Exponent in floating-point
[0198] 8378          RANDOM EQU  >8378             RANDOM NUMBER GENERATOR
[0199] 8379          TIMER  EQU  >8379             TIMING REGISTER
[0200] 837A          MOTION EQU  >837A             NUMBER OF MOVING SPRITES
[0201] 837B          VDPSTS EQU  >837B             VDP STATUS REGISTER
[0202] 837C          ERCODE EQU  >837C             STATUS REGISTER
[0203]               ***********************************************************
[0204] 8384          RAMTOP EQU  >8384            Highest address in ERAM
[0205] 8386          RAMFRE EQU  >8386            Free pointer in the ERAM
[0206] 8388          RSTK   EQU  >8388            Subroutine stack base
[0207]               *                             (Starts at >8A)
[0208] 8389          RAMFLG EQU  >8389            ERAM flag
[0209] 83AF          STKMIN EQU  >83AF            Base of data stack
[0210] 83BD          STKMAX EQU  >83BD            Top of data stack
[0211] 83CE          PRTNFN EQU  >83CE            Sound - previous tone finished
[0212]               ***********************************************************
[0213]               *    VDP addresses
[0214] 02E0          SCRNBS EQU  >02E0             Screen base addr for last lin
[0215] 02E2          NLNADD EQU  >02E2             New LiNe ADDress
[0216] 02FE          ENDSCR EQU  >02FE             END of SCReen address
[0217] 0371          LODFLG EQU  >0371             Auto-boot needed flag
[0218] 0372          START  EQU  >0372             Line to start execution at
[0219]               * Temporary
[0220] 0374          NOTONE EQU  >0374             NO-TONE for SIZE in ACCEPT us
[0221]               *                              in FLMGRS (4 bytes used)
[0222] 0376          SYMBOL EQU  >0376             Saved symbol table pointer
[0223] 0382          SPGMPT EQU  >0382             Saved PGMPTR for continue
[0224] 0384          SBUFLV EQU  >0384             Saved BUFLEV for contiue
[0225] 0386          SEXTRM EQU  >0386             Saved EXTRAM for continue
[0226] 0388          SAVEVP EQU  >0388             Saved VSPRT for continue
[0227] 038A          ERRLN  EQU  >038A             On-error line pointer
[0228] 038C          BUFSRT EQU  >038C             Edit recall start addr (VARW)
[0229] 038E          BUFEND EQU  >038E             Edit recall end addr (VARA)
[0230] 0390          CSNTMP EQU  >0390             Use as temporary stored place
[0231]               *                          or CSN TEMPORARY FOR FAC12
[0232] 0392          TABSAV EQU  >0392             Saved main symbol table ponte
[0233] 0394          AUTTMP EQU  >0394             AUTOLD TEMPORARY IN SIDE ERRZ
[0234] 0396          SLSUBP EQU  >0396             Saved LSUBP for continue
[0235] 0398          SFLAG  EQU  >0398             Saved on-warning/break bits
[0236] 039A          SSTEMP EQU  >039A             To save subprogram program ta
[0237] 039C          SSTMP2 EQU  >039C             Same as above. Used in SUBPRO
[0238] 039E          MRGPAB EQU  >039E             MERGEd temporary for pab ptr
[0239] 03A0          PMEM   EQU  >03A0             UPPER 24K MEMORY
[0240] 03AA          INPUTP EQU  >03AA             INPUT TEMPORARY FOR PTR TO PR
[0241] 03AC          ACCVRW EQU  >03AC             Temoporary used in ERRZZ, als
[0242]               *                              used in FLMGRS
[0243]               *                             or temporary for @VARW, @VARA
[0244] 03AE          ACCVRA EQU  >03AE             TRY AGAIN
[0245] 03B0          VALIDP EQU  >03B0             Use as two values passing fro
[0246]               *                          or PTR TO STANDARD STRING IN VAL
[0247] 03B2          VALIDL EQU  >03B2             VALIDATE code to READL1
[0248]               *                          or Length of string in validate
[0249] 03B4          SIZCCP EQU  >03B4             SIZE TEMPORARY FOR CCPADR
[0250] 03B6          SIZREC EQU  >03B6             SIZE TEMPORARY FOR RECLEN
[0251]               *                            Also used as temporary in RELO
[0252]               *----------------------------------------------------------
[0253]               * Added 6/8/81 for NOPSCAN feature
[0254] 03B7          PSCFG  EQU  >03B7
[0255]               *----------------------------------------------------------
[0256] 03B7          ACCTRY EQU  >03B7             ACCEPT "TRY AGAIN" FLAG
[0257] 03B8          SIZXPT EQU  >03B8             Save XPT in SIZE when "try ag

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0005 
RXB 2024
[0258] 03B9          SAPROT EQU  >03B9             PROTECTION flag in SAVE
[0259] 03BA          CSNTP1 EQU  >03BA             CSN TEMPORARY FOR FAC10
[0260]               *----------------------------------------------------------
[0261]               *    Flag 0:  99/4  console, 5/29/81
[0262]               *         1:  99/4A console
[0263] 03BB          CONFLG EQU  >03BB
[0264]               *----------------------------------------------------------
[0265] 03BC          OLDTOP EQU  >03BC             Temporary used in ERRZZ, also
[0266]               *                          or Old top of memory for RELOCA
[0267] 03BC          CPTEMP EQU  >03BC             CCPPTR, RECLEN temp in INPUT
[0268] 03BE          NEWTOP EQU  >03BE             New top of memory for RELOCA
[0269] 03C0          VROAZ  EQU  >03C0             Temporary VDP Roll Out Area
[0270] 0820          CRNBUF EQU  >0820             CRuNch BUFfer address
[0271] 08BE          CRNEND EQU  >08BE             CRuNch buffer END
[0272] 08C0          RECBUF EQU  >08C0             Edit RECall BUFfer
[0273] 0958          VRAMVS EQU  >0958             Default base of value stack
[0274]               ***********************************************************
[0275]               *    IMMEDITATE VALUES
[0276] 0000          NUMBR  EQU  >00               NUMERIC validate
[0277] 0002          LISTZ  EQU  >02
[0278] 0005          OLDZ   EQU  >05
[0279] 0006          RESEQZ EQU  >06
[0280] 0007          SAVEZ  EQU  >07
[0281] 0008          MERGEZ EQU  >08
[0282] 000A          DWNARR EQU  >0A
[0283] 000B          UPARR  EQU  >0B
[0284] 000D          CHRTN  EQU  >0D
[0285] 0020          BKGD   EQU  >20               BACKGROUND CHARACTER
[0286] 0060          OFFSET EQU  >60               OFFSET FOR VIDEO TABLES
[0287] 0065          STRVAL EQU  >65               Value in accum. is string val
[0288]               ***********************************************************
[0289]               * Editting command equates
[0290] 0002          BREAK  EQU  >02               Break key
[0291] 0003          DLETE  EQU  >03               Delete key
[0292] 0004          INSRT  EQU  >04               Insert key
[0293] 0006          RECALL EQU  >06               Edit-buffer recall
[0294] 0007          CLRLN  EQU  >07               Clear-line key
[0295] 0008          BACK   EQU  >08               Back-space key
[0296] 0009          FORW   EQU  >09               Forward-space key
[0297] 000A          DOWN   EQU  >0A               Down-arrow key
[0298] 000B          UPMV   EQU  >0B               Up-arrow key
[0299] 001C          VWIDTH EQU  >1C               Screen width (PRINT)
[0300] 0020          SPACE  EQU  >20               Space key
[0301] 0022          QUOTE  EQU  >22               "
[0302] 0024          DOLLAR EQU  >24               $
[0303] 007E          CURSOR EQU  >1E+OFFSET        CURSOR
[0304] 007F          EDGECH EQU  >1F+OFFSET        EDGE character
[0305] 002C          COMMA  EQU  >2C               ,
[0306] 002D          MINUS  EQU  >2D               -
[0307]               ***********************************************************
[0308]               * PAB offset
[0309] 0000          CZOPEN EQU  0                 OPEN CODE
[0310] 0001          CZCLOS EQU  1                 CLOSE CODE
[0311] 0002          FIL    EQU  2                 File number within BASIC(0-25
[0312] 0002          CZREAD EQU  2                 READ CODE
[0313] 0003          OFS    EQU  3                 Offset within record
[0314] 0003          CZWRIT EQU  3                 WRITE CODE
[0315] 0004          COD    EQU  4                 I/O code
[0316] 0004          CZREST EQU  4                 RESTORE/REWIND CODE
[0317] 0005          FLG    EQU  5                 I/O mode flag byte
[0318] 0005          CZLOAD EQU  5                 LOAD CODE
[0319] 0006          BUF    EQU  6                 Start of data buffer
[0320] 0006          CZSAVE EQU  6                 SAVE CODE
[0321] 0007          CZDELE EQU  7                 DELETE CODE

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0006 
RXB 2024
[0322] 0008          LEN    EQU  8                 Record length
[0323] 0008          CZSCR  EQU  8                 SCRATCH CODE
[0324] 0009          CNT    EQU  9                 Character count
[0325] 0009          CZSTAT EQU  9                 STATUS CODE
[0326] 000A          RNM    EQU  10                Record number
[0327] 000C          SCR    EQU  12                Screen base offset
[0328] 000D          NLEN   EQU  13                Length of file descriptor
[0329] 000E          PABLEN EQU  14                PAB LENGTH
[0330]               ***********************************************************
[0331]               *    BASIC TOKEN TABLE
[0332]               *      EQU  >80               spare token
[0333] 0081          ELSEZ  EQU  >81               ELSE
[0334] 0082          SSEPZ  EQU  >82               ::
[0335] 0083          TREMZ  EQU  >83               $
[0336] 0084          IFZ    EQU  >84               IF
[0337] 0085          GOZ    EQU  >85               GO
[0338] 0086          GOTOZ  EQU  >86               GOTO
[0339] 0087          GOSUBZ EQU  >87               GOSUB
[0340] 0088          RETURZ EQU  >88               RETURN
[0341] 0089          DEFZ   EQU  >89               DEF
[0342] 008A          DIMZ   EQU  >8A               DIM
[0343] 008B          ENDZ   EQU  >8B               END
[0344] 008C          FORZ   EQU  >8C               FOR
[0345]               * LETZ   EQU  >8D               LET   * RXB REMOVED
[0346] 008E          BREAKZ EQU  >8E               BREAK
[0347] 008F          UNBREZ EQU  >8F               UNBREAK
[0348] 0090          TRACEZ EQU  >90               TRACE
[0349] 0091          UNTRAZ EQU  >91               UNTRACE
[0350] 0092          INPUTZ EQU  >92               INPUT
[0351] 0093          DATAZ  EQU  >93               DATA
[0352] 0094          RESTOZ EQU  >94               RESTORE
[0353] 0095          RANDOZ EQU  >95               RANDOMIZE
[0354] 0096          NEXTZ  EQU  >96               NEXT
[0355] 0097          READZ  EQU  >97               READ
[0356] 0098          STOPZ  EQU  >98               STOP
[0357] 0099          DELETZ EQU  >99               DELETE
[0358] 009A          REMZ   EQU  >9A               REM
[0359] 009B          ONZ    EQU  >9B               ON
[0360] 009C          PRINTZ EQU  >9C               PRINT
[0361] 009D          CALLZ  EQU  >9D               CALL
[0362] 009E          OPTIOZ EQU  >9E               OPTION
[0363] 009F          OPENZ  EQU  >9F               OPEN
[0364] 00A0          CLOSEZ EQU  >A0               CLOSE
[0365] 00A1          SUBZ   EQU  >A1               SUB
[0366] 00A2          DISPLZ EQU  >A2               DISPLAY
[0367] 00A3          IMAGEZ EQU  >A3               IMAGE
[0368] 00A4          ACCEPZ EQU  >A4               ACCEPT
[0369] 00A5          ERRORZ EQU  >A5               ERROR
[0370] 00A6          WARNZ  EQU  >A6               WARNING
[0371] 00A7          SUBXTZ EQU  >A7               SUBEXIT
[0372] 00A8          SUBNDZ EQU  >A8               SUBEND
[0373] 00A9          RUNZ   EQU  >A9               RUN
[0374] 00AA          LINPUZ EQU  >AA               LINPUT
[0375]               *      EQU  >AB               spare token (LIBRARY)
[0376]               *      EQU  >AC               spare token (REAL)
[0377]               *      EQU  >AD               spare token (INTEGER)
[0378]               *      EQU  >AE               spare token (SCRATCH)
[0379]               *      EQU  >AF               spare token
[0380] 00B0          THENZ  EQU  >B0               THEN
[0381] 00B1          TOZ    EQU  >B1               TO
[0382] 00B2          STEPZ  EQU  >B2               STEP
[0383] 00B3          COMMAZ EQU  >B3               ,
[0384] 00B4          SEMICZ EQU  >B4               ;
[0385] 00B5          COLONZ EQU  >B5               :

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0007 
RXB 2024
[0386] 00B6          RPARZ  EQU  >B6               )
[0387] 00B7          LPARZ  EQU  >B7               (
[0388] 00B8          CONCZ  EQU  >B8               &          (CONCATENATE)
[0389]               *      EQU  >B9               spare token
[0390] 00BA          ORZ    EQU  >BA               OR
[0391] 00BB          ANDZ   EQU  >BB               AND
[0392] 00BC          XORZ   EQU  >BC               XOR
[0393] 00BD          NOTZ   EQU  >BD               NOT
[0394] 00BE          EQUALZ EQU  >BE               =
[0395] 00BF          LESSZ  EQU  >BF               <
[0396] 00C0          GREATZ EQU  >C0               >
[0397] 00C1          PLUSZ  EQU  >C1               +
[0398] 00C2          MINUSZ EQU  >C2               -
[0399] 00C3          MULTZ  EQU  >C3               *
[0400] 00C4          DIVIZ  EQU  >C4               /
[0401] 00C5          CIRCUZ EQU  >C5               ^
[0402]               *      EQU  >C6               spare token
[0403] 00C7          STRINZ EQU  >C7               QUOTED STRING
[0404] 00C8          UNQSTZ EQU  >C8               UNQUOTED STRING
[0405] 00C8          NUMZ   EQU  >C8               ALSO NUMERICAL STRING
[0406] 00C8          NUMCOZ EQU  >C8               ALSO UNQUOTED STRING
[0407] 00C9          LNZ    EQU  >C9               LINE NUMBER CONSTANT
[0408]               *      EQU  >CA               spare token
[0409] 00CB          ABSZ   EQU  >CB               ABS
[0410] 00CC          ATNZ   EQU  >CC               ATN
[0411] 00CD          COSZ   EQU  >CD               COS
[0412] 00CE          EXPZZ  EQU  >CE               EXP
[0413] 00CF          INTZ   EQU  >CF               INT
[0414] 00D0          LOGZ   EQU  >D0               LOG
[0415] 00D1          SGNZZ  EQU  >D1               SGN
[0416] 00D2          SINZ   EQU  >D2               SIN
[0417] 00D3          SQRZ   EQU  >D3               SQR
[0418] 00D4          TANZ   EQU  >D4               TAN
[0419] 00D5          LENZ   EQU  >D5               LEN
[0420] 00D6          CHRZZ  EQU  >D6               CHR$
[0421] 00D7          RNDZ   EQU  >D7               RND
[0422] 00D8          SEGZZ  EQU  >D8               SEG$
[0423] 00D9          POSZ   EQU  >D9               POS
[0424] 00DA          VAL    EQU  >DA               VAL
[0425] 00DB          STRZZ  EQU  >DB               STR$
[0426] 00DC          ASCZ   EQU  >DC               ASC
[0427] 00DD          PIZ    EQU  >DD               PI
[0428] 00DE          RECZ   EQU  >DE               REC
[0429] 00DF          MAXZ   EQU  >DF               MAX
[0430] 00E0          MINZ   EQU  >E0               MIN
[0431] 00E1          RPTZZ  EQU  >E1               RPT$
[0432]               *      EQU  >E2               unused
[0433]               *      EQU  >E2               unused
[0434]               *      EQU  >E3               unused
[0435]               *      EQU  >E4               unused
[0436]               *      EQU  >E5               unused
[0437]               *      EQU  >E6               unused
[0438]               *      EQU  >E7               unused
[0439] 00E8          NUMERZ EQU  >E8               NUMERIC
[0440] 00E9          DIGITZ EQU  >E9               DIGIT
[0441] 00EA          UALPHZ EQU  >EA               UALPHA
[0442] 00EB          SIZEZ  EQU  >EB               SIZE
[0443] 00EC          ALLZ   EQU  >EC               ALL
[0444] 00ED          USINGZ EQU  >ED               USING
[0445] 00EE          BEEPZ  EQU  >EE               BEEP
[0446] 00EF          ERASEZ EQU  >EF               ERASE
[0447] 00F0          ATZ    EQU  >F0               AT
[0448] 00F1          BASEZ  EQU  >F1               BASE
[0449]               *      EQU  >F2               spare token (TEMPORARY)

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0008 
RXB 2024
[0450] 00F3          VARIAZ EQU  >F3               VARIABLE
[0451] 00F4          RELATZ EQU  >F4               RELATIVE
[0452] 00F5          INTERZ EQU  >F5               INTERNAL
[0453] 00F6          SEQUEZ EQU  >F6               SEQUENTIAL
[0454] 00F7          OUTPUZ EQU  >F7               OUTPUT
[0455] 00F8          UPDATZ EQU  >F8               UPDATE
[0456] 00F9          APPENZ EQU  >F9               APPEND
[0457] 00FA          FIXEDZ EQU  >FA               FIXED
[0458] 00FB          PERMAZ EQU  >FB               PERMANENT
[0459] 00FC          TABZ   EQU  >FC               TAB
[0460] 00FD          NUMBEZ EQU  >FD               #
[0461] 00FE          VALIDZ EQU  >FE               VALIDATE
[0462]               *      EQU  >FF               ILLEGAL VALUE
[0463]               ***********************************************************
[0464]                      TITL 'FLMGR-359'
[0465]               ***********************************************************
[0466]               *                        GROM HEADER
[0467]               ***********************************************************
[0468]               *    Branch table routines
[0469]               ***********************************************************
[0470] 8000 42,57           BR   DISPL1            DISPLAY routine
[0471] 8002 41,7C           BR   DELET             DELETE routine
[0472] 8004 42,66           BR   PRINT             PRINT routine
[0473] 8006 45,F0           BR   INPUT             INPUT routine (not yet impele
[0474] 8008 40,32           BR   OPEN              OPEN routine
[0475] 800A 41,96           BR   CLOSE             CLOSE routine
[0476] 800C 41,FC           BR   RESTOR            RESTORE routine
[0477] 800E 4B,3A           BR   READ              READ routine
[0478] 8010 53,0B           BR   GETDAT            Get DATA from ERAM/VDP (not u
[0479] 8012 41,F4           BR   CLSALL            CLOSE ALL OPEN FILES subrouti
[0480] 8014 4D,B8           BR   SAVE              SAVE routine
[0481] 8016 4B,C4           BR   OLD               LOAD routine
[0482] 8018 50,6B           BR   LIST              LIST routine
[0483] 801A 56,A8           BR   OUTREC            Output record routine
[0484] 801C 51,E1           BR   EOF               End of file routine
[0485] 801E 49,6B           BR   ACCEPT            ACCEPT routine
[0486] 8020 4B,96           BR   SRDATA            Search "DATAZ" routine
[0487] 8022 51,CD           BR   SUBREC            RECORD routine
[0488] 8024 55,B0           BR   CHKEND            Check EOS
[0489] 8026 4B,CA           BR   OLD1              A subroutine for LOAD
[0490] 8028 50,05           BR   MERGE             MERGE a program
[0491] 802A 51,7C           BR   GRMLST            List a line out of ERAM
[0492] 802C 51,A7           BR   GRSUB2            Read 2 bytes of data from ERA
[0493] 802E 51,BF           BR   GRSUB3            Read 2 bytes of data from ERA
[0494]               *                             with resetting possible break
[0495] 8030 48,41           BR   LINPUT              LINPUT statement
[0496]               ***********************************************************
[0497]               *               OPEN STATEMENT HANDLER
[0498]               * Handle the BASIC OPNE statement. A legal syntax can only
[0499]               * be something like
[0500]               *      OPEN #{exp}:{string-exp}[,{open-options}]
[0501]               * in which {open-option} is any of the following
[0502]               * DISPLAY, INPUT, VARIABLE, RELATIVE, INTERNAL, SEQUENTIAL,
[0503]               * OUTPUT, UPDATE, APPEND, FIXED or PERMANENT
[0504]               *
[0505]               * Each keyword can only be used once, which is being checke
[0506]               * with an OPTFLG-bit. For each specific option please refer
[0507]               * to the related routine.
[0508]               * Scanning stops as soon as no next field starting with a
[0509]               * comma can be found.
[0510]               * NOTE: After the actual DSR OPEN has been preformed, the
[0511]               *       length of the record, whether VARIABLE or FIXED,
[0512]               *       has to be non-zero. A zero length will cause an
[0513]               *       INCORRECT STATEMENT error.

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0009 
FLMGR-359
[0514]               ***********************************************************
[0515] 8032 06,93,58 OPEN   CALL CHKFN             See if we specified any file
[0516] 8035 77,DA           BS   ERRFE             Definitely not... no # or #0
[0517] 8037 06,93,74        CALL CHKCON            Check and search given filenu
[0518] 803A 77,DA           BS   ERRFE             *** FILE NUMBER EXISTS ***
[0519]               * ERROR IF NOT STOPPED ON COLON
[0520] 803C 0F,7E           XML  SPEED             Must be at a
[0521] 803E 00              BYTE SYNCHK          *  colon or else
[0522] 803F B5              BYTE COLONZ          *   its an error
[0523] 8040 06,96,5D        CALL PARFN             Parse filename and create PAB
[0524] 8043 93,2C           DDEC @PGMPTR           Backup pgm pointer for next t
[0525] 8045 0F,79    OPTION XML  PGMCHR            Get next program character
[0526]               * Next field should start with a comma
[0527] 8047 D6,42,B3 OPTIZ0 CEQ  COMMAZ,@CHAT
[0528] 804A 41,0D           BR   CHECK
[0529]               * Enter HERE after comma exit in "SEQUENTIAL"
[0530] 804C 0F,79    OPTIZ1 XML  PGMCHR            Next token please...
[0531]               * Treat DISPLAY and INPUT as special cases
[0532] 804E D6,42,A2        CEQ  DISPLZ,@CHAT
[0533] 8051 60,EA           BS   OPTZ6
[0534] 8053 D6,42,92        CEQ  INPUTZ,@CHAT
[0535] 8056 60,F4           BS   OPTZ7
[0536] 8058 A6,42,F3        SUB  VARIAZ,@CHAT      Reduce keyword offset to 0
[0537] 805B CA,42,09        CHE  9,@CHAT           Keyword to high
[0538] 805E 61,06           BS   OPERR
[0539] 8060 8A,42           CASE @CHAT             JUST IN CASE
[0540] 8062 40,BE           BR   OPTZ01            Option VARIABLE
[0541] 8064 40,7C           BR   OPTZ02                   RELATIVE
[0542] 8066 40,E5           BR   OPTZ03                   INTERNAL
[0543] 8068 40,81           BR   OPTZ1                    SEQUENTIAL
[0544] 806A 40,A8           BR   OPTZ2                    OUTPUT
[0545] 806C 40,AD           BR   OPTZ3                    UPDATE
[0546] 806E 40,B7           BR   OPTZ4                    APPEND
[0547] 8070 40,C3           BR   OPTZ5                    FIXED
[0548]               *      BR   OPTZ0                    PERMANENT       <<<<<<
[0549]               * CASE 0 - "PERMANENT" ************************************
[0550]               *  Only check for multiple usage. Since PERMANENT is the
[0551]               *  default, we might as well ignore it...
[0552] 8072 DA,17,04 OPTZ0  CLOG >04,@OPTFLG
[0553] 8075 41,06           BR   OPERR
[0554] 8077 B6,17,04        OR   >04,@OPTFLG       Not used ... use now
[0555] 807A 40,45           BR   OPTION            Treat as simple default
[0556]               * CASE 2 - "RELATIVE" *************************************
[0557]               *  Select relative record file in PAB and fall through in
[0558]               *  SEQUENTIAL code for multiple usage check. Also handle
[0559]               *  initial file-size there.
[0560] 807C B6,E0,05 OPTZ02 OR   >01,V@FLG(@PABPTR) Indicate RELATIVE RECORD
       807F 04,01
[0561]               * CASE 4 - "SEQUENTIAL" ***********************************
[0562]               *  Checks for multiple usage. Remainder of syntax demads th
[0563]               *  we have something like:
[0564]               *                         [{numeric expression}],...
[0565]               *  In case only a comma is found, we use the default.
[0566]               *  Everything else has to be evaluated as a numeric
[0567]               *  expression, convertable to a 16-bit integer value.
[0568] 8081 DA,17,08 OPTZ1  CLOG >08,@OPTFLG
[0569] 8084 41,06           BR   OPERR
[0570] 8086 B6,17,08        OR   >08,@OPTFLG       First time usage, ok
[0571] 8089 0F,79           XML  PGMCHR            Check next token for default
[0572]               * Comma means default has been used
[0573] 808B D6,42,B3        CEQ  COMMAZ,@CHAT
[0574] 808E 60,4C           BS   OPTIZ1
[0575] 8090 06,95,B0        CALL CHKEND            Check for end of statement
[0576] 8093 61,0D           BS   CHECK

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0010 
FLMGR-359
[0577] 8095 06,80,9F        CALL CHKPAR            Preform combined checking & p
[0578] 8098 BD,E0,0A        DST  @FAC,V@RNM(@PABPTR) Non-zero result
       809B 04,4A
[0579] 809D 40,47           BR   OPTIZ0            Scan other options
[0580]               * Parse and check a numeric argument in here....
[0581] 809F 0F,74    CHKPAR XML  PARSE             If not ... parse up to comma
[0582] 80A1 B3              BYTE COMMAZ
[0583] 80A2 06,93,5F        CALL CHKCNV            Check and convert to integer
[0584] 80A5 61,06           BS   OPERR             Oops..., someone made a mista
[0585] 80A7 00              RTN                    Return to caller
[0586]               * CASE 5 - "OUTPUT" ***************************************
[0587]               *  Select mode code "01" and check for multiple usage. Use
[0588]               *  MFLAG bit in OPTFLG for checking.
[0589] 80A8 B6,E0,05 OPTZ2  OR   >02,V@FLG(@PABPTR)  Mode code = 01
       80AB 04,02
[0590]               * CASE 6 - "UPDATE" ***************************************
[0591]               *  Default ... Check for multiple usage only...
[0592]               *  Test for previous usage of any mode setting
[0593] 80AD DA,17,01 OPTZ3  CLOG >01,@OPTFLG
[0594] 80B0 41,06           BR   OPERR
[0595] 80B2 B6,17,01        OR   >01,@OPTFLG       If not... set "MODE USED" bit
[0596] 80B5 40,45           BR   OPTION            Continue option scan
[0597]               * CASE 7 - "APPEND" ***************************************
[0598]               *  Mode code "11" indicates APPEND mode.
[0599] 80B7 B6,E0,05 OPTZ4  OR   >06,V@FLG(@PABPTR)  Mode code = 11
       80BA 04,06
[0600] 80BC 40,AD           BR   OPTZ3
[0601]               * CASE 1 - "VARIABLE" *************************************
[0602]               *  Change record type to VARIABLE and continue as FIXED
[0603] 80BE B6,E0,05 OPTZ01 OR   >10,V@FLG(@PABPTR)  Indicate variable length mo
       80C1 04,10
[0604]                
[0605]               * CASE 8 - "FIXED" ****************************************
[0606]               *  Fixed is default. Don't change anything, unless argument
[0607]               *  is given. In this case evaluate as numeric expression an
[0608]               *  check for 8-bit integer range...
[0609]               *  This routine is also used for VARIABLE !!!!!
[0610] 80C3 0F,79    OPTZ5  XML  PGMCHR            Get next character
[0611] 80C5 D6,42,B3        CEQ  COMMAZ,@CHAT      Could be some argument
[0612] 80C8 60,DB           BS   OPTZ55
[0613] 80CA 06,95,B0        CALL CHKEND            Could also be end of statemen
[0614] 80CD 60,DB           BS   OPTZ55            It is an EOS
[0615] 80CF 06,80,9F        CALL CHKPAR            Check & parse expression
[0616]               * Check for byte overflow (records can only be up to 255
[0617]               * bytes in length)
[0618] 80D2 8E,4A           CZ   @FAC
[0619] 80D4 41,06           BR   OPERR
[0620] 80D6 BC,E0,08        ST   @FAC1,V@LEN(@PABPTR) Select non-zero rec-size
       80D9 04,4B
[0621] 80DB DA,17,10 OPTZ55 CLOG >10,@OPTFLG
[0622] 80DE 41,06           BR   OPERR
[0623] 80E0 B6,17,10        OR   >10,@OPTFLG       Prevent to much usage of mode
[0624] 80E3 40,47           BR   OPTIZ0             Continue option scan
[0625]               * CASE 3 - "INTERNAL" *************************************
[0626]               *  Select INTERANL file type and continue in DIPLAY
[0627] 80E5 B6,E0,05 OPTZ03 OR   8,V@FLG(@PABPTR)  Select INTERNAL type
       80E8 04,08
[0628]               * CASE 9 - "DISPLAY" **************************************
[0629]               *  Default. Only check for multiple usage of either DISPLAY
[0630]               *  or INTERNAL...
[0631] 80EA DA,17,02 OPTZ6  CLOG >02,@OPTFLG
[0632] 80ED 41,06           BR   OPERR
[0633] 80EF B6,17,02        OR   >02,@OPTFLG       Else set "DISPLAY/INTERAL" fl
[0634] 80F2 40,45           BR   OPTION            Continue... DISPLAY is defaul

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0011 
FLMGR-359
[0635]               * CASE 10 "INPUT" *****************************************
[0636]               *  Same as any other I/O type definition. Mode code "10" ..
[0637]               *  Continue in OPTZ3
[0638] 80F4 B6,E0,05 OPTZ7  OR   >04,V@FLG(@PABPTR) Mode code = 10
       80F7 04,04
[0639] 80F9 40,AD           BR   OPTZ3
[0640]               * CLRFRE deallocates previously alocated (parts of) PAB's a
[0641]               * return with an error message
[0642] 80FB 86,02    CLRFRE CLR  @MNUM             Undo any allocation
[0643] 80FD BC,03,E0        ST   V@OFS(@PABPTR),@MNUM+1  We need the length for
       8100 03,04
[0644]               *                                    that
[0645]               *      V@OFS(@PABPTR) Was set up in PARFN routine
[0646] 8102 A1,40,02        DADD @MNUM,@FREPTR     Update the first free world
[0647] 8105 00              RTN                    And return
[0648] 8106 06,80,FB OPERR  CALL CLRFRE            First undo the allocation
[0649] 8109 06,6A,84 ERRSYN CALL ERRZZ             Then give an error
[0650] 810C 03              BYTE 3                 * SYNTAX ERROR
[0651]               * Continue with CHECK to conplete the actual OPEN
[0652] 810D 06,95,B0 CHECK  CALL CHKEND            Check EOS
[0653] 8110 41,06           BR   OPERR             Not EOS  : SYNTAX ERROR
[0654]               * If the user hasn't specified VARIABLE or FIXED, the
[0655]               * default specification depends on the file type.
[0656]               * Change current default (=VARIABLE) to FIXED for
[0657]               * RELATIVE files.
[0658] 8112 DA,E0,05        CLOG >01,V@FLG(@PABPTR) RELATIVE RECORD
       8115 04,01
[0659] 8117 61,27           BS   G8127
[0660] 8119 DA,E0,05        CLOG >10,V@FLG(@PABPTR) VARIABLE RECORD
       811C 04,10
[0661] 811E 61,25           BS   G8125
[0662] 8120 06,80,FB FILZZ  CALL CLRFRE            Undo the PAB allocation
[0663] 8123 57,DA           BR   ERRFE             FILE ERROR
[0664] 8125 41,31    G8125  BR   G8131             Sequential file, check rec. m
[0665] 8127 DA,17,10 G8127  CLOG >10,@OPTFLG       No definition yet
[0666] 812A 41,31           BR   G8131
[0667] 812C B6,E0,05        OR   >10,V@FLG(@PABPTR) Force VARIABLE mode
       812F 04,10
[0668] 8131 06,97,6E G8131  CALL CDSR              Call the DSR, return with err
[0669] 8134 57,97           BR   ERRZ2B             indication in COND...
[0670] 8136 87,E0,0A        DCLR V@RNM(@PABPTR)    Make sure we start with recor
       8139 04
[0671]               * Check for undefined record length. The record length for
[0672]               * any type might be defined by the DSR
[0673] 813A 8E,E0,08        CZ   V@LEN(@PABPTR)
       813D 04
[0674] 813E 61,20           BS   FILZZ
[0675] 8140 BC,03,E0        ST   V@LEN(@PABPTR),@MNUM+1 Get record length
       8143 08,04
[0676] 8145 86,02           CLR  @MNUM             Create two byte result and
[0677] 8147 86,E0,03        CLR  V@OFS(@PABPTR)     allocate - remove offset for
       814A 04
[0678]               *                              later use
[0679] 814B BD,4A,02        DST  @MNUM,@FAC        - prepare for space claim
[0680]               * Check for special case : no PAB's yet
[0681] 814E 8F,3C           DCZ  @IOSTRT
[0682] 8150 41,57           BR   G8157
[0683] 8152 BD,3C,04        DST  @PABPTR,@IOSTRT   Simply enter the first pointe
[0684] 8155 41,69           BR   G8169
[0685] 8157 BD,0A,3C G8157  DST  @IOSTRT,@STADDR   Search for the end of the cha
[0686] 815A 8F,B0,0A G815A  DCZ  V*STADDR
[0687] 815D 61,65           BS   G8165
[0688] 815F BD,0A,B0        DST  V*STADDR,@STADDR  Keep on deferring
       8162 0A

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0012 
FLMGR-359
[0689] 8163 41,5A           BR   G815A
[0690] 8165 BD,B0,0A G8165  DST  @PABPTR,V*STADDR  Update last chain link
       8168 04
[0691] 8169 BD,E0,06 G8169  DST  @PABPTR,V@BUF(@PABPTR) Set empty buffer first
       816C 04,04
[0692] 816E 0F,72           XML  MEMCHK            Check memory overflow & strin
[0693] 8170 77,CA           BS   ERRMEM            * MEMORY FULL
[0694] 8172 A5,40,02        DSUB @MNUM,@FREPTR     Compute buffer entry address
[0695] 8175 A5,E0,06        DSUB @MNUM,V@BUF(@PABPTR) Correct buffer address in
       8178 04,02
[0696] 817A 0F,75           XML  CONT              Return to the parser
[0697]               ***********************************************************
[0698]               *                    DELETE ROUTINE
[0699]               * Use file # 0 for this operation. Parse the file name
[0700]               * string-expression as usual, and delete the PAB before
[0701]               * actually calling the DSR.
[0702]               ***********************************************************
[0703] 817C 86,17    DELET  CLR  @FNUM             Create file #0 - non-existing
[0704] 817E 06,96,5D        CALL PARFN             Handle as normal PAB OPEN
[0705] 8181 06,95,B0        CALL CHKEND            Check EOS first
[0706] 8184 41,06           BR   OPERR             Not EOS : go undo PAB allocat
[0707]               *                              and print SYNTAX ERROR
[0708] 8186 86,02           CLR  @MNUM       *  Delete PAB again before calling
[0709] 8188 BC,03,E0        ST   V@OFS(@PABPTR),@MNUM+1  Create double byte PAB
       818B 03,04
[0710]                
[0711] 818D A1,40,02        DADD @MNUM,@FREPTR     Update free word pointer
[0712] 8190 06,97,61        CALL IOCALL            Preform I/O call for actual d
[0713] 8193 07              BYTE CZDELE
[0714] 8194 0F,75           XML  CONT
[0715]               ***********************************************************
[0716]               *                    CLOSE ROUTINE
[0717]               * Syntax could be
[0718]               * CLOSE #{ num exp }  or CLOSE #{ num exp }:DELETE
[0719]               *
[0720]               * Possibly output pending records before closing or
[0721]               * deleting the file.
[0722]               ***********************************************************
[0723] 8196 06,93,58 CLOSE  CALL CHKFN             Check for "no #" / "#0" cases
[0724] 8199 77,DA           BS   ERRFE             Not for "CLOSE" you don't
[0725] 819B 06,93,74        CALL CHKCON            Check file number etc...
[0726] 819E 57,DA           BR   ERRFE             *** FILE NUMBER NOT IN SYSTEM
[0727] 81A0 06,93,93        CALL OUTEOF            Output pending records
[0728] 81A3 BE,E0,04        ST   CZCLOS,V@COD(@PABPTR) Default to CLOSE I/O code
       81A6 04,01
[0729] 81A8 D6,42,B5        CEQ  COLONZ,@CHAT      Check for ":DELETE" spec.
[0730] 81AB 41,B8           BR   G81B8
[0731] 81AD 0F,79           XML  PGMCHR            Request next input token
[0732] 81AF 0F,7E           XML  SPEED             Must be at a
[0733] 81B1 00              BYTE SYNCHK          *  "DELETE" else
[0734] 81B2 99              BYTE DELETZ          *   its an error
[0735] 81B3 BE,E0,04        ST   CZDELE,V@COD(@PABPTR) Change CLOSE to DELETE
       81B6 04,07
[0736] 81B8 06,95,B0 G81B8  CALL CHKEND            EOS?
[0737] 81BB 41,09           BR   ERRSYN            NO:SYNTAX ERROR
[0738] 81BD 06,97,6E        CALL CDSR              Call DSR with whatever we hav
[0739] 81C0 41,C7           BR   CLOSZ1            Reset means error....
[0740] 81C2 06,93,A9        CALL DELPAB            Delete PAB and data-buffer
[0741] 81C5 0F,75           XML  CONT              Return to parser routine
[0742] 81C7 BD,5C,E0 CLOSZ1 DST  V@4(@PABPTR),@ARG Save error code for message
       81CA 04,04
[0743] 81CC 06,93,A9        CALL DELPAB            Now delete the PAB
[0744] 81CF BD,04,40        DST  @FREPTR,@PABPTR   Store error-code in free memo
[0745] 81D2 A7,04,00        DSUB 6,@PABPTR         Create standard size PAB

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0013 
FLMGR-359
       81D5 06
[0746] 81D6 BD,E0,04        DST  @ARG,V@4(@PABPTR) Copy error-code
       81D9 04,5C
[0747] 81DB 57,BE           BR   ERRIO             Exit to error-routine
[0748]               ***********************************************************
[0749]               *                   CLOSE ALL ROUTINE
[0750]               * CLOSE all the existing PABs ... ignore errors
[0751]               *
[0752]               * NOTE: "CLSLBL" is used in the I/O error routine to
[0753]               *       determine if a warning should be given rather than
[0754]               *       an error.
[0755]               ***********************************************************
[0756] 81DD BD,04,B0 G81DD  DST  V*PABPTR,@PABPTR
       81E0 04
[0757] 81E1 8F,B0,04 CLSAZ0 DCZ  V*PABPTR          Find last PAB in chain
[0758] 81E4 41,DD           BR   G81DD
[0759] 81E6 06,93,93        CALL OUTEOF            Take care of pending records
[0760] 81E9 BE,E0,04 CLSLBL ST   CZCLOS,V@COD(@PABPTR) Select CLOSE code
       81EC 04,01
[0761] 81EE 06,97,6E        CALL CDSR              CLOSE to DSR routine
[0762] 81F1 06,93,A9        CALL DELPAB            Delete PAB - ignore CLOSE err
[0763] 81F4 BD,04,3C CLSALL DST  @IOSTRT,@PABPTR   Start at beginning of chain
[0764] 81F7 8F,3C           DCZ  @IOSTRT           Continue until done
[0765] 81F9 41,E1           BR   CLSAZ0
[0766] 81FB 00              RTN                    And return
[0767]               ***********************************************************
[0768]               *                   RESTORE ROUTINE
[0769]               * RESTORE can have any of four forms:
[0770]               *
[0771]               * RESTORE                     Restore to first DATA
[0772]               * RESTORE 20                  Restore DATA pointer
[0773]               * RESTORE #1                  Rewind file number 1
[0774]               * RESTORE #1, REC 2           Position file 1 at record 2
[0775]               ***********************************************************
[0776] 81FC 87,4A    RESTOR DCLR @FAC              Assume simple RESTORE
[0777] 81FE D6,42,FD        CEQ  NUMBEZ,@CHAT
[0778] 8201 42,1F           BR   OLDCD
[0779] 8203 06,93,58        CALL CHKFN             Check for #<filenumber>
[0780] 8206 8F,4A           DCZ  @FAC              Found equivalent of #0
[0781] 8208 62,27           BS   OLDCZ0
[0782] 820A 06,93,74        CALL CHKCON            Check and decode file #
[0783] 820D 57,DA           BR   ERRFE             Give error if file not there
[0784] 820F 06,93,93        CALL OUTEOF            Output pending record
[0785] 8212 87,E0,0A        DCLR V@RNM(@PABPTR)    Initialize to record 0
       8215 04
[0786] 8216 06,94,C5        CALL PARREC            Parse possible record clause
[0787] 8219 06,97,61        CALL IOCALL            Call DSR routine with
[0788] 821C 04              BYTE CZREST          *   RESTORE I/O code
[0789] 821D 0F,75           XML  CONT              Return if no error found
[0790]               * Following code is for handling RESTORE to line number
[0791]               * within program
[0792] 821F 06,95,B0 OLDCD  CALL CHKEND            Check for start with end
[0793] 8222 62,27           BS   OLDCZ0            If we have anything else
[0794] 8224 06,A0,06        CALL LINE               in FAC (double)
[0795] 8227 D5,30,32 OLDCZ0 DCEQ @ENLN,@STLN
[0796] 822A 42,33           BR   G8233
[0797] 822C 06,6A,82 WRNNPP CALL WARNZZ            * NO PROGRAM PRESENT *
[0798] 822F 1D              BYTE 29
[0799] 8230 05,60,12        B    TOPL15            Go back to toplevel
[0800] 8233 BD,36,32 G8233  DST  @ENLN,@LNBUF      Start at beginning of program
[0801] 8236 A7,36,00        DSUB 3,@LNBUF          Backup for first line number
       8239 03
[0802]               * Check against given line number
[0803] 823A 06,91,BF OLDCZ1 CALL GRSUB3            Read 2 bytes of line ptr from

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0014 
FLMGR-359
[0804]               *                              line # table which is in ERA
[0805] 823D 36              BYTE LNBUF           * Source address on ERAM/VDP
[0806]               *                             @EEE1: Destination addr on CP
[0807] 823E C5,4A,58        DCH  @EEE1,@FAC        Try to get something higher
[0808] 8241 42,4E           BR   G824E
[0809] 8243 D5,36,30        DCEQ @STLN,@LNBUF      Last line in program
[0810] 8246 77,D6           BS   ERRDAT
[0811] 8248 A7,36,00        DSUB 4,@LNBUF          Get next entry in line # tabl
       824B 04
[0812] 824C 42,3A           BR   OLDCZ1            Try again with next line
[0813] 824E A3,36,00 G824E  DADD 3,@LNBUF          Undo subtraction
       8251 03
[0814] 8252 06,A0,08        CALL DATAST            Setup pointer for READ
[0815] 8255 0F,75           XML  CONT              Continue PARSE
[0816]               ***********************************************************
[0817]               *                 DISPLAY ROUTINE
[0818]               * DISPLAY handles all random screen access stuff..
[0819]               * the AT-clause, and the BEEP, ERASE ALL and SIZE clause.
[0820]               ***********************************************************
[0821] 8257 06,94,F2 DISPL1 CALL DISACC            Evaluate DISPLAY options
[0822] 825A 63,95           BS   EOLEX             EXIT directly on end-of-state
[0823]               * If anything is specified it has to be a colon
[0824] 825C 8E,04           CZ   @PABPTR           Nothing was specified
[0825] 825E 62,C4           BS   PRINZ1
[0826]               * At this point we MUST have a colon, or else we error off
[0827]               * (SYNTAX ERROR)
[0828] 8260 0F,7E           XML  SPEED             Check for a colon
[0829] 8262 00              BYTE SYNCHK          *  and continue
[0830] 8263 B5              BYTE COLONZ          *   it approved
[0831] 8264 42,C4           BR   PRINZ1            Continue with PRINT items
[0832]               ***********************************************************
[0833]               *                    PRINT ROUTINE
[0834]               * MAIN-HANDLER FOR ALL PRINT-FUNCTIONS
[0835]               ***********************************************************
[0836] 8266 06,97,42 PRINT  CALL INITKB            Initialize keyboard I/O
[0837] 8269 D6,42,FD        CEQ  NUMBEZ,@CHAT      Could still be anything
[0838] 826C 42,C4           BR   PRINZ1
[0839] 826E 06,93,58        CALL CHKFN             Check if default or open chan
[0840] 8271 8F,4A           DCZ  @FAC              Default intended
[0841] 8273 62,A5           BS   PRNZ10
[0842] 8275 06,93,74        CALL CHKCON            Check and convert expression
[0843] 8278 57,DA           BR   ERRFE             Error if PAB not in system
[0844]               * PRINT allowed in output, append or update modes
[0845]               *       Not allowed in input mode
[0846] 827A DA,E0,05        CLOG >04,V@FLG(@PABPTR)
       827D 04,04
[0847] 827F 62,88           BS   G8288
[0848] 8281 DA,E0,05        CLOG >02,V@FLG(@PABPTR)
       8284 04,02
[0849] 8286 77,DA           BS   ERRFE
[0850] 8288 D6,E0,04 G8288  CEQ  CZREAD,V@COD(@PABPTR)
       828B 04,02
[0851] 828D 42,93           BR   G8293
[0852] 828F 86,E0,03        CLR  V@OFS(@PABPTR)    Unpend pending INPUTs
       8292 04
[0853] 8293 BE,E0,04 G8293  ST   CZWRIT,V@COD(@PABPTR) uncomplete PRINTs
       8296 04,03
[0854] 8298 06,96,F8        CALL PRINIT            Initialize some variables
[0855]               * Next character has to be either EOL, COMMA, or COLON
[0856] 829B 06,95,B0        CALL CHKEND
[0857] 829E 63,95           BS   EOLEX              exit on end of statement
[0858] 82A0 06,94,C5        CALL PARREC            Parse possible record clause
[0859] 82A3 62,B1           BS   PRINZ0            found "," but no REC clause
[0860] 82A5 06,95,B0 PRNZ10 CALL CHKEND

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0015 
FLMGR-359
[0861] 82A8 63,95           BS   EOLEX             Exit on end of statement for
[0862]               *                       "PRINT #0" or "PRINT file position"
[0863] 82AA D6,42,B3        CEQ  COMMAZ,@CHAT
[0864] 82AD 42,BE           BR   G82BE
[0865] 82AF 0F,79           XML  PGMCHR            Get next in line
[0866] 82B1 8E,04    PRINZ0 CZ   @PABPTR           For "PRINT #0"
[0867] 82B3 63,CF           BS   USING
[0868]               *         Interal type of file?
[0869] 82B5 DA,E0,05        CLOG >08,V@FLG(@PABPTR)
       82B8 04,08
[0870] 82BA 57,DA           BR   ERRFE
[0871] 82BC 43,CF           BR   USING             Execute USING clause
[0872] 82BE 0F,7E    G82BE  XML  SPEED             Must be at a
[0873] 82C0 00              BYTE SYNCHK          *   colon at this point
[0874] 82C1 B5              BYTE COLONZ          *     and error off on others
[0875] 82C2 42,C9           BR   CONPRT            Make it a short branched ELSE
[0876] 82C4 D6,42,ED PRINZ1 CEQ  USINGZ,@CHAT
[0877] 82C7 63,CF           BS   USING             End standard initialization
[0878]               * Test standard separators
[0879] 82C9 06,96,2A CONPRT CALL TSTSEP            Test separator character
[0880] 82CC D6,42,FC        CEQ  TABZ,@CHAT        Handle TABs
[0881] 82CF 63,2D           BS   PRTAB
[0882]               * At this point we've checked TAB and ; , :
[0883]               * The only remaining print items have to be expressions
[0884]               *  All expressions are being handled below.
[0885]               * If the result of the expression is a numeric, the string
[0886]               * is transformed into a string and printed. Strings are
[0887]               * printed "as is".
[0888]               *  The code for strings and converted numerics cannot be ma
[0889]               * common, since numerics may require an extra space behind
[0890]               * the item, depending upon the current position in the reco
[0891]               *  Either way, the string is chunked up into little pieces
[0892]               * it won't fit in an empty record.
[0893] 82D1 0F,74           XML  PARSE             Evaluate the expression
[0894] 82D3 B5              BYTE COLONZ
[0895]               * Special code for INTERNAL file handling
[0896]               *  Translate numeric datums into string format and indicate
[0897]               * length 8. Then check to see if the item fits within the
[0898]               * current record. If not, it is an error, since each item
[0899]               * has to fit.
[0900] 82D4 06,83,C5        CALL TSTINT            Test for internal files
[0901] 82D7 63,03           BS   OTHEZ1            Nope, something different
[0902] 82D9 D6,4C,65        CEQ  STRVAL,@FAC2      Change numerics
[0903] 82DC 62,EC           BS   G82EC
[0904] 82DE BE,56,08        ST   8,@FAC12          To string length 8
[0905] 82E1 35,00,08        MOVE 8,@FAC,@ARG       Save in ARG
       82E4 5C,4A
[0906] 82E6 BE,55,5C        ST   ARG,@FAC11        And use this as source
[0907] 82E9 06,96,0E        CALL RSTRING           Reserve some string space
[0908] 82EC BC,5C,07 G82EC  ST   @RECLEN,@ARG      Compute remaining space to EO
[0909] 82EF A4,5C,06        SUB  @CCPPTR,@ARG       for space checking
[0910] 82F2 90,5C           INC  @ARG              Make it real space
[0911] 82F4 C8,51,5C        CHE  @ARG,@FAC7        Not enough!!!!!
[0912] 82F7 77,DA           BS   ERRFE
[0913]               * The = check includes length byte
[0914] 82F9 BC,B0,08        ST   @FAC7,V*CCPADR    Prestore string length
       82FC 51
[0915] 82FD 91,08           DINC @CCPADR           Update actual RAM address
[0916] 82FF 90,06           INC  @CCPPTR            and internal column pointer
[0917] 8301 43,08           BR   OTHEZ0
[0918] 8303 D6,4C,65 OTHEZ1 CEQ  STRVAL,@FAC2      Print the string result
[0919] 8306 43,0D           BR   G830D
[0920] 8308 06,97,11 OTHEZ0 CALL OSTRNG            Output the string to the reco
[0921] 830B 43,28           BR   CHKSEP

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0016 
FLMGR-359
[0922] 830D 86,55    G830D  CLR  @FAC11            Select standard BASIC format
[0923] 830F 0F,73           XML  XCNS              Convert number to string
[0924] 8311 06,96,0E        CALL RSTRING           Reserve and copy string
[0925] 8314 06,97,11        CALL OSTRNG            Output the string
[0926]               * Possibly add an extra space if we're not at the end of th
[0927]               * current record.
[0928] 8317 C8,07,06        CHE  @CCPPTR,@RECLEN   Enough space left
[0929] 831A 43,28           BR   CHKSEP
[0930] 831C BE,B0,08        ST   SPACE,V*CCPADR    Add trailing space
       831F 20
[0931] 8320 A0,B0,08        ADD  @DSRFLG,V*CCPADR  Take care of screen I/O
       8323 17
[0932] 8324 91,08           DINC @CCPADR           Update current column address
[0933] 8326 90,06           INC  @CCPPTR            and base 1 pointer
[0934] 8328 06,96,2A CHKSEP CALL TSTSEP            Check for legal delimiter
[0935] 832B 41,09           BR   ERRSYN            Illegal delimiter. SYNTAX ERR
[0936]               *                              Unconditional branch
[0937]               * PRTAB - Print TAB as part of PRINT command
[0938] 832D 06,83,C5 PRTAB  CALL TSTINT            Watch out for INTERAL file ty
[0939] 8330 57,DA           BR   ERRFE             They can't handle TABs
[0940] 8332 0F,79           XML  PGMCHR            Skip TAB keyword
[0941] 8334 D6,42,B7        CEQ  LPARZ,@CHAT
[0942] 8337 41,09           BR   ERRSYN
[0943] 8339 0F,74           XML  PARSE             Parse TAB expression
[0944] 833B B6              BYTE RPARZ
[0945] 833C 06,94,BB        CALL CNVDEF            Check and convert to integer
[0946] 833F BC,4C,07        ST   @RECLEN,@FAC2     Set modulo number
[0947] 8342 06,96,1D        CALL COMMOD            Compute remainder
[0948] 8345 C4,06,4B        CH   @FAC1,@CCPPTR     Position on next output recor
[0949] 8348 43,4F           BR   G834F
[0950] 834A 06,96,A8        CALL OUTREC            Output current record - no pe
[0951] 834D 63,28           BS   CHKSEP             react on SIZE block!!!
[0952] 834F D4,06,4B G834F  CEQ  @FAC1,@CCPPTR     Stay here
[0953] 8352 63,28           BS   CHKSEP
[0954] 8354 BC,03,4B        ST   @FAC1,@MNUM+1     Fill with spaces
[0955] 8357 0F,84           XML  IO                OK, go ahead... fill'r up
[0956] 8359 01              BYTE FILSPC
[0957] 835A 43,28           BR   CHKSEP            And check separator again
[0958]               * Comma is similar to TAB, except that it generates at leas
[0959]               * one space. The exact number of spaces generated depends
[0960]               * upon the current position within the record. If the next
[0961]               * fixed tab-position is outside the record, the record, the
[0962]               * current record is output and the column pointer is reset
[0963]               * to column 1 of the next record.
[0964] 835C BC,03,06 PRTCOM ST   @CCPPTR,@MNUM+1   Compute initial # of spaces
[0965] 835F 92,03           DEC  @MNUM+1           Decrecment for 0 origin
[0966] 8361 86,02           CLR  @MNUM             Clear high byte of double
[0967] 8363 AE,02,0E        DIV  14,@MNUM          TABs are 14 spaces apart
[0968] 8366 90,02           INC  @MNUM             Compute next TAB-stop
[0969] 8368 AA,02,0E        MUL  14,@MNUM           and actual position
[0970] 836B C4,07,03        CH   @MNUM+1,@RECLEN   Within this record
[0971] 836E 43,77           BR   PRCOL
[0972] 8370 90,03           INC  @MNUM+1           Convert to real position
[0973] 8372 0F,84           XML  IO                Fill spaces to new location
[0974] 8374 01              BYTE FILSPC
[0975] 8375 43,7A           BR   PRSEM             Outside current record
[0976]               * The ":" (colon) separator is used to output the current
[0977]               * record, and proceed to position 1 of the next record.
[0978] 8377 06,96,A8 PRCOL  CALL OUTREC            Output the current record
[0979]               * The ";" (semi-colon) generates the null string. Since all
[0980]               * print items should be separated by a separator, this one
[0981]               * has been introduced to separate without moving to another
[0982]               * position. Notice that all separators join up here.
[0983] 837A 0F,79    PRSEM  XML  PGMCHR            Skip the separator

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0017 
FLMGR-359
[0984] 837C 06,95,B0        CALL CHKEND            Exit on end of line
[0985] 837F 42,C9           BR   CONPRT            Continue if not end of line
[0986] 8381 8E,17    PRSMZ1 CZ   @DSRFLG           For screen output continue
[0987] 8383 63,A4           BS   PREXIT
[0988] 8385 DA,04,08        CLOG >08,@PABPTR       Check SIZE clause
[0989] 8388 63,A4           BS   PREXIT
[0990] 838A 06,96,A8        CALL OUTREC            Output current record (blank
[0991] 838D BC,06,09        ST   @CCPADR+1,@CCPPTR Compute correct value for CCP
[0992] 8390 A6,06,E1        SUB  >E1,@CCPPTR       Subtract current screen base
[0993] 8393 43,A4           BR   PREXIT             and exit form this command
[0994]               * End of line exit routine for PRINT statement
[0995] 8395 8E,17    EOLEX  CZ   @DSRFLG           I/O - remove blocks if
[0996] 8397 63,A1           BS   G83A1
[0997] 8399 DA,04,04        CLOG >04,@PABPTR        " AT" clause unused
[0998] 839C 43,A1           BR   G83A1
[0999] 839E B2,04,E7        AND  >E7,@PABPTR        remove flag 3 (SIZE used)
[1000] 83A1 06,96,A8 G83A1  CALL OUTREC            Output pending record
[1001]               * Continue here if record remains pending
[1002] 83A4 8E,17    PREXIT CZ   @DSRFLG           Regular file/device I/O
[1003] 83A6 43,B1           BR   G83B1
[1004] 83A8 92,06           DEC  @CCPPTR           Back to actual offset
[1005] 83AA BC,E0,03        ST   @CCPPTR,V@OFS(@PABPTR) Save for next statement
       83AD 04,06
[1006] 83AF 0F,75           XML  CONT              Continue with next statement
[1007]               *                              End external I/O handling
[1008]               * Reset of code is for internal I/O handling (VDP)
[1009] 83B1 DA,04,04 G83B1  CLOG >04,@PABPTR       Is not used
[1010] 83B4 43,BB           BR   G83BB
[1011] 83B6 BC,7F,06        ST   @CCPPTR,@XPT      Save current value of pointer
[1012] 83B9 94,7F           INCT @XPT              CCPPTR: 1-28
[1013] 83BB DA,04,02 G83BB  CLOG >02,@PABPTR       Used BEEP clause
[1014] 83BE 63,C3           BS   G83C3
[1015] 83C0 06,00,34        CALL TONE1             ---------- BEEP ------------
[1016] 83C3 0F,75    G83C3  XML  CONT              Continue in PARSE routine
[1017]               * TSTINT - test for INTERAL type files, set COND if file
[1018]               *          is NOT INTERNAL
[1019] 83C5 8E,17    TSTINT CZ   @DSRFLG           Couldn't possibly be INTERNAL
[1020] 83C7 53,8F           BR   RTC
[1021] 83C9 DA,E0,05        CLOG >08,V@FLG(@PABPTR) Set COND according to bit 3
       83CC 04,08
[1022] 83CE 01              RTNC                   Return without changing COND
[1023]               ********* PRINT / DISPLAY USING SECTION *******************
[1024]               * Arrive here after the keyword "USING" has been rejected.
[1025] 83CF 0F,7E    USING  XML  SPEED
[1026] 83D1 00              BYTE SYNCHK          * Get first character of format
[1027] 83D2 ED              BYTE USINGZ          *  after (double) checking USIN
[1028] 83D3 D6,42,C9        CEQ  LNZ,@CHAT         Pick up the line number
[1029] 83D6 44,30           BR   G8430
[1030] 83D8 0F,79           XML  PGMCHR            Get high address
[1031] 83DA BC,4A,42        ST   @CHAT,@FAC
[1032] 83DD 0F,79           XML  PGMCHR             and low address
[1033] 83DF BC,4B,42        ST   @CHAT,@FAC1
[1034] 83E2 0F,79           XML  PGMCHR              get next program character
[1035] 83E4 BD,4C,2E        DST  @EXTRAM,@FAC2        in SEETWO : EXTRAM value w
[1036]               *                                 changed
[1037] 83E7 0F,7E           XML  SPEED
[1038] 83E9 03              BYTE SEETWO          *  Find the line # in the progr
[1039] 83EA C1,4C,2E        DEX  @EXTRAM,@FAC2      result in SEETWO is in EXTRA
[1040]               *                               and restore EXTRAM value
[1041] 83ED 44,5E           BR   USNGZ1               has to match exactly
[1042] 83EF 95,4C           DINCT @FAC2            Move up to the pointer field
[1043] 83F1 BD,52,34        DST   @DATA,@FAC8      Save DATA pointer for READ fi
[1044] 83F4 06,91,A7        CALL GRSUB2            Read 2 bytes of data from ERA
[1045] 83F7 4C              BYTE FAC2           *  @FAC2 : Source address on ERA

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0018 
FLMGR-359
[1046] 83F8 BD,34,58        DST  @EEE1,@DATA       @EEE1 : Destination addr. on
[1047]               *                              Put it in @DATA
[1048] 83FB BE,4C,A3        ST   IMAGEZ,@FAC2      Search for an IMAGE token
[1049] 83FE 06,8B,99        CALL SEARCH             at beginning of an statement
[1050] 8401 64,5E           BS   USNGZ1            Error if not found on this li
[1051] 8403 06,93,07        CALL GETGFL            Get first part of format stri
[1052] 8406 06,93,26        CALL CHKSTR            Prepare data for string assig
[1053] 8409 BD,0C,50        DST  @FAC6,@BYTES      Copy actual string length in
[1054] 840C BD,34,52        DST  @FAC8,@DATA       Restore original DATA pointer
[1055] 840F 06,92,D0        CALL CTSTR             Create a temporary string
[1056] 8412 8F,50           DCZ  @FAC6
[1057] 8414 64,2E           BS   G842E
[1058] 8416 8E,80,84        CZ   @RAMTOP           Data from RAM
[1059] 8419 44,23           BR   G8423
[1060] 841B 34,50,B0        MOVE @FAC6,V*TEMP5,V*SREF
       841E 1C,B0,66
[1061] 8421 44,2E           BR   G842E
[1062] 8423 BD,56,50 G8423  DST  @FAC6,@FFF1       FFF1 : byte count
[1063] 8426 BD,54,66        DST  @TEMP5,@DDD1      DDD1 : source address in ERAM
[1064] 8429 BD,58,1C        DST  @SREF,@EEE1       EEE1 : destination address on
[1065] 842C 0F,8B           XML  GVWITE            Write data from ERAM to VDP
[1066] 842E 44,38    G842E  BR   G8438
[1067] 8430 0F,74    G8430  XML  PARSE             Parse up to the ending ":"
[1068] 8432 B5              BYTE COLONZ
[1069] 8433 D6,4C,65        CEQ  STRVAL,@FAC2      * IMAGE ERROR *
[1070] 8436 44,5E           BR   USNGZ1
[1071] 8438 D6,42,B5 G8438  CEQ  COLONZ,@CHAT      Probably no variable list
[1072] 843B 64,48           BS   G8448
[1073] 843D 06,95,B0        CALL CHKEND            We better check that through
[1074] 8440 41,09           BR   ERRSYN             something sneaky sneaked in
[1075] 8442 8E,51           CZ   @FAC7             End of line exit
[1076] 8444 63,95           BS   EOLEX
[1077] 8446 44,63           BR   G8463             Look for format item
[1078] 8448 8E,51    G8448  CZ   @FAC7             Exclude null strings
[1079] 844A 64,5E           BS   USNGZ1
[1080] 844C BD,5C,4E        DST  @FAC4,@ARG        Get start address for string
[1081] 844F BC,5E,51        ST   @FAC7,@ARG2       Get format string length
[1082] 8452 D6,B0,5C USNGZ0 CEQ  >23,V*ARG         Found no format item yet
       8455 23
[1083] 8456 64,60           BS   G8460
[1084] 8458 91,5C           DINC @ARG              Try next address
[1085] 845A 92,5E           DEC  @ARG2             Update address
[1086] 845C 44,52           BR   USNGZ0            Try up to the end of the stri
[1087] 845E 57,C6    USNGZ1 BR   ERRIM             * IMAGE ERROR
[1088]               * Now we're sure that we have at least one legal format ite
[1089]               * (anything with a "#" in it)
[1090] 8460 BE,42,B3 G8460  ST   COMMAZ,@CHAT      Fake comma seperator for prin
[1091] 8463 0F,77    G8463  XML  VPUSH             Current string might be tempo
[1092] 8465 BD,0C,50        DST  @FAC6,@BYTES      Create a workstring for outpu
[1093] 8468 90,0D           INC  @BYTES+1          Create space for end of strin
[1094] 846A 0C              CARRY                  String would be too long
[1095] 846B 64,5E           BS   USNGZ1
[1096] 846D 0F,71           XML  GETSTR            Length whold equal format str
[1097] 846F BD,14,1C        DST  @SREF,@CURLIN     Create a temporary string
[1098] 8472 A1,1C,50        DADD @FAC6,@SREF       Compute last position in stri
[1099] 8475 86,B0,1C        CLR  V*SREF            Set end of string indicator
[1100] 8478 BD,4E,E0 USNGZ3 DST  V@4(@VSPTR),@FAC4 Update FAC4 area in case garb
       847B 04,6E
[1101] 847D 34,50,B0        MOVE @FAC6,V*FAC4,V*CURLIN Copy format
       8480 14,B0,4E
[1102] 8483 BD,4E,14        DST  @CURLIN,@FAC4     Complete preps for VPUSH
[1103] 8486 BF,4A,00        DST  >001C,@FAC        SREF = >001C
       8489 1C
[1104] 848A 91,50           DINC @FAC6             Include 0 in string length

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0019 
FLMGR-359
[1105] 848C 0F,77           XML  VPUSH             Make the string temporary
[1106] 848E BD,14,E0        DST  V@4(@VSPTR),@CURLIN Update current line pointer
       8491 04,6E
[1107] 8493 D6,B0,14 USNGZ4 CEQ  >23,V*CURLIN      Try to locate the next format
       8496 23
[1108] 8497 64,C3           BS   G84C3
[1109] 8499 8E,B0,14        CZ   V*CURLIN          Not end of string yet
[1110] 849C 64,A2           BS   G84A2
[1111] 849E 91,14           DINC @CURLIN           Update pointer if not found
[1112] 84A0 44,93           BR   USNGZ4             and continue searching
[1113] 84A2 D6,42,B3 G84A2  CEQ  COMMAZ,@CHAT      Stop on last variable
[1114] 84A5 45,C3           BR   USNGZ9
[1115] 84A7 0F,78           XML  VPOP              Restore original workstring d
[1116] 84A9 BC,0C,51        ST   @FAC7,@BYTES      Pring the current format stri
[1117] 84AC 92,0C           DEC  @BYTES            Don't count the last "0"
[1118] 84AE BE,03,01        ST   1,@MNUM+1         Indicate direct output withou
[1119] 84B1 06,97,1B        CALL CHKRZ0            Copy string to output record
[1120] 84B4 06,96,A8        CALL OUTREC            Also output current record
[1121]               * FAC still contains the right data, however it is easier j
[1122]               * to copy the original string again.
[1123] 84B7 BD,14,4E        DST  @FAC4,@CURLIN     Reconstruct CRULIN
[1124] 84BA 0F,78           XML  VPOP              Copy original string info
[1125] 84BC 0F,77           XML  VPUSH             Without actually removing it
[1126] 84BE A5,14,50        DSUB @FAC6,@CURLIN     Reconstruct start address
[1127] 84C1 44,78           BR   USNGZ3            Continue for the next variabl
[1128] 84C3 D5,14,E0 G84C3  DCEQ V@4(@VSPTR),@CURLIN Avoid "#" as count
       84C6 04,6E
[1129] 84C8 64,E9           BS   USNZ42
[1130] 84CA 93,14           DDEC @CURLIN           Backup to the sign
[1131] 84CC D6,B0,14        CEQ  >2E,V*CURLIN      Used ".#####"
       84CF 2E
[1132] 84D0 44,DB           BR   G84DB
[1133] 84D2 D5,14,E0        DCEQ V@4(@VSPTR),@CURLIN
       84D5 04,6E
[1134] 84D7 64,E9           BS   USNZ42
[1135] 84D9 93,14           DDEC @CURLIN           Avoid checking count bit
[1136] 84DB D6,B0,14 G84DB  CEQ  >2D,V*CURLIN      Check for minus
       84DE 2D
[1137] 84DF 64,E9           BS   USNZ42
[1138] 84E1 D6,B0,14        CEQ  >2B,V*CURLIN      Check for plus
       84E4 2B
[1139] 84E5 64,E9           BS   USNZ42
[1140] 84E7 91,14           DINC @CURLIN           It's neither, so we undo
[1141]               * Check for availability of variables
[1142] 84E9 D6,42,B3 USNZ42 CEQ  COMMAZ,@CHAT      Exit if no more pt item
[1143] 84EC 45,C3           BR   USNGZ9
[1144] 84EE 0F,79           XML  PGMCHR            Get next expression
[1145] 84F0 A5,14,E0        DSUB V@4(@VSPTR),@CURLIN Make CURLIN offset for
       84F3 04,6E
[1146]               *                                garbage collection
[1147] 84F5 0F,74           XML  PARSE             Parse up to ";" or ","
[1148] 84F7 B4              BYTE SEMICZ
[1149] 84F8 A1,14,E0        DADD V@4(@VSPTR),@CURLIN Reconstruct new CLN after
       84FB 04,6E
[1150]               *                                garbage collection
[1151] 84FD 87,52           DCLR @FAC8             Start with clean sheet for co
[1152] 84FF 87,55           DCLR @FAC11
[1153] 8501 86,57           CLR  @FAC13
[1154] 8503 BD,0E,14        DST  @CURLIN,@VAR4     Now start checking process
[1155] 8506 D6,B0,14        CEQ  >2E,V*CURLIN
       8509 2E
[1156] 850A 65,33           BS   USNGZ5
[1157] 850C D6,B0,14        CEQ  >23,V*CURLIN      Has to be "+" or "-"
       850F 23

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0020 
FLMGR-359
[1158] 8510 65,27           BS   G8527
[1159] 8512 D6,B0,14        CEQ  >2D,V*CURLIN
       8515 2D
[1160] 8516 45,1B           BR   G851B
[1161] 8518 B6,55,02        OR   >02,@FAC11        Set explict sign flag for CNS
[1162] 851B D6,B0,14 G851B  CEQ  >2B,V*CURLIN
       851E 2B
[1163] 851F 45,27           BR   G8527
[1164] 8521 B6,55,02        OR   >02,@FAC11        Set explict sign flag for CNS
[1165] 8524 B6,55,04        OR   >04,@FAC11        Set positive sign flag for CN
[1166] 8527 06,85,E5 G8527  CALL ACCNM             Accept first character plus "
[1167] 852A BC,56,53        ST   @FAC9,@FAC12      Set up FAC12 for CNS
[1168] 852D D6,B0,0E        CEQ  >2E,V*VAR4        Found decimal point
       8530 2E
[1169] 8531 45,40           BR   G8540
[1170] 8533 86,53    USNGZ5 CLR  @FAC9             Prepare for use as counter of
[1171]               *                              of # sign after decimal poin
[1172] 8535 06,85,E5        CALL ACCNM             Accept some more "#"'s
[1173] 8538 BC,57,53        ST   @FAC9,@FAC13      Set up FAC13 for CNS
[1174] 853B A0,53,56        ADD  @FAC12,@FAC9      FAC9 now contains the total n
[1175]               *                              of "#" sign, decimal point a
[1176]               *                              maybe a sign bit
[1177] 853E 92,53           DEC  @FAC9             Exclude the decimal point
[1178] 8540 D7,B0,0E G8540  DCEQ >5E5E,V*VAR4      Attempt to decode  ^^
       8543 5E,5E
[1179] 8545 45,64           BR   USNZ55
[1180] 8547 95,0E           DINCT @VAR4            Update address
[1181] 8549 D7,B0,0E        DCEQ  >5E5E,V*VAR4
       854C 5E,5E
[1182] 854E 45,62           BR   G8562
[1183] 8550 95,0E           DINCT @VAR4            Update address
[1184] 8552 B6,55,08        OR   >08,@FAC11        Set E-format bit for CNS
[1185] 8555 D6,B0,0E        CEQ  >5E,V*VAR4
       8558 5E
[1186] 8559 45,64           BR   USNZ55
[1187] 855B 91,0E           DINC @VAR4             Update end address
[1188] 855D B6,55,10        OR   >10,@FAC11        Set extended E-format bit for
[1189] 8560 45,64           BR   USNZ55
[1190] 8562 97,0E    G8562  DDECT @VAR4            Correct for previous errors
[1191]               * At this point, CURLIN is pointing at the first item of th
[1192]               * format, VAR4 is pointing at the character following the i
[1193] 8564 CA,4C,64 USNZ55 CHE  >64,@FAC2         Detected numerical argument
[1194] 8567 65,96           BS   G8596
[1195] 8569 DA,55,02        CLOG >02,@FAC11        Exclude the sign count
[1196] 856C 65,70           BS   G8570
[1197] 856E 92,53           DEC  @FAC9             FAC9 : Number of significant
[1198] 8570 DA,55,08 G8570  CLOG >08,@FAC11        If E-format is used
[1199] 8573 65,7C           BS   G857C
[1200] 8575 CE,53,0A        CGT  >0A,@FAC9         More than 10 significant digi
[1201] 8578 77,C6           BS   ERRIM
[1202] 857A 45,81           BR   G8581
[1203] 857C CE,53,0E G857C  CGT  14,@FAC9          More than 14 significant digi
[1204] 857F 77,C6           BS   ERRIM
[1205] 8581 B6,55,01 G8581  OR   >01,@FAC11        Set fixed format output it fo
[1206] 8584 0F,73           XML  XCNS    1          Convert number to fixed form
[1207]               * FAC11 points to the beginning of the string after supress
[1208]               * leading 0's, FAC12 contains the length of the string
[1209] 8586 BC,57,55        ST   @FAC11,@FAC13     FAC13 now point to beginning
[1210]               *                              the string
[1211] 8589 86,55           CLR  @FAC11            Clear high byte
[1212] 858B 34,55,B0        MOVE @FAC11,*FAC13,V*CURLIN Copy the result string f
       858E 14,90,57
[1213]               *                                   temporary
[1214] 8591 BD,14,0E        DST  @VAR4,@CURLIN     Move pointer behind print fie

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0021 
FLMGR-359
[1215] 8594 44,93           BR   USNGZ4            Continue after printing
[1216] 8596 BD,54,0E G8596  DST  @VAR4,@FAC10      Compute total length
[1217] 8599 A5,54,14        DSUB @CURLIN,@FAC10
[1218] 859C C4,51,55        CH   @FAC11,@FAC7      String exceeds limits
[1219] 859F 45,B1           BR   G85B1
[1220] 85A1 BE,00,2A        ST   >2A,@VAR0         Prepare a "*****.." string
[1221] 85A4 BC,B0,14 G85A4  ST   @VAR0,V*CURLIN    Fill the remainder of field
       85A7 00
[1222] 85A8 91,14           DINC @CURLIN           Up to the end
[1223] 85AA D5,14,0E USNZ67 DCEQ @VAR4,@CURLIN     Which is stored in VAR4
[1224] 85AD 45,A4           BR   G85A4
[1225] 85AF 44,93           BR   USNGZ4
[1226] 85B1 8F,50    G85B1  DCZ  @FAC6
[1227] 85B3 65,BE           BS   USNZ68
[1228] 85B5 34,50,B0        MOVE @FAC6,V*FAC4,V*CURLIN Copy result string
       85B8 14,B0,4E
[1229] 85BB A1,14,50        DADD @FAC6,@CURLIN     And update address in string
[1230] 85BE BE,00,20 USNZ68 ST   SPACE,@VAR0       Fill remainder with spaces
[1231] 85C1 45,AA           BR   USNZ67
[1232] 85C3 0F,78    USNGZ9 XML  VPOP              Temporary string back out
[1233] 85C5 BC,0C,15        ST   @CURLIN+1,@BYTES  Output up to the current
[1234]               *                              position
[1235] 85C8 A4,0C,4F        SUB  @FAC5,@BYTES      Create one byte result
[1236] 85CB 65,D3           BS   USNZ95            Avoid empty strings
[1237] 85CD BE,03,01        ST   1,@MNUM+1         Prevent skip if field too sma
[1238] 85D0 06,97,1B        CALL CHKRZ0            Preform all nomal I/O stuff
[1239] 85D3 0F,78    USNZ95 XML  VPOP              Remove source format string
[1240] 85D5 06,95,B0        CALL CHKEND            Check for end of line exit
[1241] 85D8 63,95           BS   EOLEX             Take end of line exit
[1242] 85DA 0F,7E           XML  SPEED
[1243] 85DC 00              BYTE SYNCHK          * Then it HAS to be a ";"
[1244] 85DD B4              BYTE SEMICZ
[1245] 85DE 06,95,B0        CALL CHKEND            Now - must be EOS
[1246] 85E1 63,81           BS   PRSMZ1            Supressed end of record, make
[1247]               *                              it a pending record
[1248] 85E3 41,09           BR   ERRSYN            SYNTAX ERROR
[1249]               * Collect string of "#"'s
[1250] 85E5 90,53    ACCNM  INC  @FAC9             Update item count
[1251] 85E7 91,0E           DINC @VAR4              and item address
[1252] 85E9 D6,B0,0E        CEQ  >23,V*VAR4        Decode as many "#"'s as
       85EC 23
[1253]               *                              possible
[1254] 85ED 65,E5           BS   ACCNM
[1255] 85EF 00              RTN                    Return from duty
[1256]               ***********************************************************
[1257]               *                    INPUT ROUTINE
[1258]               * First check for file or screen I/O. If file I/O then chec
[1259]               * for pending output and print that. If screen I/O then
[1260]               * check for input prompt:
[1261]               * Next collect the INPUT variable list on the V-stack. Get
[1262]               * enough input form either file or keyboard, and compare
[1263]               * types with entries on V-stack. After verification and
[1264]               * approval, assign the values.
[1265]               ***********************************************************
[1266] 85F0 06,97,42 INPUT  CALL INITKB            Assume keyboard INPUT
[1267] 85F3 D6,42,FD        CEQ  NUMBEZ,@CHAT      Might be #0 or #1-255
[1268] 85F6 47,5A           BR   G875A
[1269] 85F8 06,93,58        CALL CHKFN             Check for default #0
[1270] 85FB 8F,4A           DCZ  @FAC              If luno #0
[1271] 85FD 46,0B           BR   G860B
[1272] 85FF BD,A3,AA        DST  @PGMPTR,V@INPUTP  Save PGMPTR for "try again"
       8602 2C
[1273] 8603 91,A3,AA        DINC V@INPUTP          Pass the ":" for the
[1274]               *                              "prompt" code handler

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0022 
FLMGR-359
[1275]               *                              later, (using #0 will not
[1276]               *                              take care the prompt in
[1277]               *                              INPUT)
[1278] 8606 06,89,2D        CALL INPUZ2            #0 is equivalent to no #
[1279] 8609 47,68           BR   INPZ2
[1280] 860B 06,88,E8 G860B  CALL INSU1             Get info about file
[1281]               * INTERNAL files get special treatment
[1282] 860E DA,E0,05        CLOG >08,V@FLG(@PABPTR) INTERNAL file
       8611 04,08
[1283] 8613 66,AD           BS   G86AD
[1284] 8615 8E,E0,03        CZ   V@OFS(@PABPTR)    Fresh start
       8618 04
[1285] 8619 46,1E           BR   G861E
[1286] 861B 06,97,68 INTRZ0 CALL IOCLZ1            Get a new record through
[1287]               *                              the DSR
[1288] 861E BC,2B,E0 G861E  ST   V@OFS(@PABPTR),@VARA+1 Regain possible offset
       8621 03,04
[1289] 8623 86,2A           CLR  @VARA             Make that a two byte constant
[1290] 8625 BD,66,E0        DST  V@BUF(@PABPTR),@TEMP5 Get first address
       8628 06,04
[1291] 862A A1,66,2A        DADD @VARA,@TEMP5      Compute actual address
[1292]               *                              within record
[1293] 862D 06,97,E6 INTRZ1 CALL BUG01             Get the symbol table entry
[1294]               * Above call fixes bug, of the given variable
[1295] 8630 0F,77           XML  VPUSH             And save it on the stack
[1296] 8632 87,0C           DCLR @BYTES            Assume no data available
[1297] 8634 C8,2B,E0        CHE  V@CNT(@PABPTR),@VARA+1 Pick up data
       8637 09,04
[1298] 8639 66,43           BS   G8643
[1299] 863B BC,0D,B0        ST   V*TEMP5,@BYTES+1  Length byte first
       863E 66
[1300] 863F 91,66           DINC @TEMP5            Update both actual address
[1301] 8641 90,2B           INC  @VARA+1            and offset
[1302] 8643 D6,4C,65 G8643  CEQ  >65,@FAC2         Has to be string variable
[1303] 8646 46,50           BR   G8650
[1304] 8648 BD,50,0C        DST  @BYTES,@FAC6      Set length of string
[1305] 864B 06,92,E1        CALL CTMPST            Create temporary string
[1306] 864E 46,7E           BR   G867E
[1307] 8650 D6,0D,08 G8650  CEQ  >08,@BYTES+1      * FILE ERROR
[1308] 8653 57,DA           BR   ERRFE
[1309] 8655 34,0C,4A        MOVE @BYTES,V*TEMP5,@FAC  Copy value
       8658 B0,66
[1310] 865A 8F,4A           DCZ  @FAC              Watch out for non-scaled stuf
[1311] 865C 66,7C           BS   G867C
[1312] 865E BE,5C,51        ST   FAC7,@ARG         Test for legal numeric
[1313] 8661 C6,90,5C G8661  CH   99,*ARG           * FILE ERROR
       8664 63
[1314] 8665 77,DA           BS   ERRFE
[1315] 8667 92,5C           DEC  @ARG              Next digit for test
[1316] 8669 D6,5C,4B        CEQ  FAC1,@ARG
[1317] 866C 46,61           BR   G8661
[1318] 866E BD,5C,4A        DST  @FAC,@ARG         Copy in ARG for some testing
[1319] 8671 81,5C           DABS @ARG              Be sure we're positive
[1320]               * If first byte after expon. byte=0 : incorrect
[1321]               * normalization has occured : FILE ERROR
[1322]               * Or >99 : illegal numeric  : FILE ERROR
[1323] 8673 92,5D           DEC  @ARG1             0 would cause underflow here
[1324] 8675 C6,5D,62        CH   98,@ARG1
[1325] 8678 77,DA           BS   ERRFE
[1326] 867A 46,7E           BR   G867E
[1327] 867C 87,4C    G867C  DCLR @FAC2             Be sure FAC2 = 0 (no strings)
[1328] 867E A1,66,0C G867E  DADD @BYTES,@TEMP5     Update address and
[1329] 8681 A0,2B,0D        ADD  @BYTES+1,@VARA+1   offset again
[1330] 8684 0F,7C           XML  ASSGNV            Assign value to variable

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0023 
FLMGR-359
[1331] 8686 86,E0,03        CLR  V@OFS(@PABPTR)    Undo allocated offsets
       8689 04
[1332] 868A D6,42,B3        CEQ  COMMAZ,@CHAT
[1333] 868D 46,AB           BR   G86AB
[1334] 868F 0F,79           XML  PGMCHR            Get next text character
[1335] 8691 06,95,B0        CALL CHKEND            Check for end of statement
[1336] 8694 66,9F           BS   INTRZ2            OK, EOS is fine
[1337] 8696 C8,2B,E0        CHE  V@CNT(@PABPTR),@VARA+1
       8699 09,04
[1338] 869B 66,1B           BS   INTRZ0
[1339] 869D 46,2D           BR   INTRZ1            Still something left
[1340] 869F C8,2B,E0 INTRZ2 CHE  V@CNT(@PABPTR),@VARA+1
       86A2 09,04
[1341] 86A4 66,AB           BS   G86AB
[1342] 86A6 BC,E0,03        ST   @VARA+1,V@OFS(@PABPTR) Save value of offset
       86A9 04,2B
[1343] 86AB 0F,75    G86AB  XML  CONT              And CONTINUE
[1344] 86AD 06,92,8D G86AD  CALL GETVAR            Collect variable list on stac
[1345] 86B0 BD,14,0A        DST  @STADDR,@CURLIN   Save it in temp
[1346] 86B3 BF,0A,08        DST  CRNBUF,@RAMPTR    Initialize crunch buffer poin
       86B6 20
[1347] 86B7 86,07           CLR  @RECLEN           Initialize field counter
[1348] 86B9 BE,E0,04        ST   CZREAD,V@COD(@PABPTR) Select READ operation
       86BC 04,02
[1349] 86BE 8E,E0,03        CZ   V@OFS(@PABPTR)
       86C1 04
[1350] 86C2 46,E9           BR   INPZ31
[1351] 86C4 46,CC           BR   INPZ3             Adjust for used record usage
[1352] 86C6 BE,EF,FF G86C6  ST   COMMAZ,V@-1(@RAMPTR) Fake legal separator
       86C9 FF,0A,B3
[1353] 86CC 06,97,68 INPZ3  CALL IOCLZ1            Get next input record
[1354] 86CF 86,E0,03        CLR  V@OFS(@PABPTR)    Reset offset within record
       86D2 04
[1355] 86D3 06,88,27        CALL RECENT
[1356] 86D6 BC,2A,E0        ST   V@CNT(@PABPTR),@VARA Get record length
       86D9 09,04
[1357] 86DB 8E,2A    G86DB  CZ   @VARA
[1358] 86DD 66,E9           BS   INPZ31
[1359] 86DF A2,B0,20        ADD  OFFSET,V*VARW     Add video offset for normal
       86E2 60
[1360] 86E3 91,20           DINC @VARW             Screen-type crunch - proceed
[1361] 86E5 92,2A           DEC  @VARA              for entire record
[1362] 86E7 46,DB           BR   G86DB
[1363] 86E9 06,88,27 INPZ31 CALL RECENT            Compute actual record entry
[1364] 86EC BC,2B,E0        ST   V@CNT(@PABPTR),@VARA+1  Compute end of record
       86EF 09,04
[1365] 86F1 86,2A           CLR  @VARA             Make that a double byte
[1366] 86F3 A1,2A,E0        DADD V@BUF(@PABPTR),@VARA  Add buffer start addr
       86F6 06,04
[1367] 86F8 93,2A           DDEC @VARA             Point to last position in rec
[1368] 86FA 86,11           CLR  @VAR6             Assume no values input
[1369] 86FC 0F,7F           XML  CRUNCH            Scan data fields as in DATA s
[1370] 86FE 01              BYTE 1               * Indicate input stmt crunch
[1371] 86FF 8F,22           DCZ  @ERRCOD           If some crunch error
[1372] 8701 57,D2           BR   ERRINP
[1373] 8703 90,11           INC  @VAR6             Get correct # of fields (one
[1374] 8705 A0,07,11        ADD  @VAR6,@RECLEN     Update # of fields up to now
[1375] 8708 C8,07,10        CHE  @VAR5,@RECLEN     OK, THAT'S ENOUGH!!!!
[1376] 870B 46,C6           BR   G86C6
[1377] 870D 97,2C           DDECT @PGMPTR          Backup program pointer
[1378] 870F 0F,79           XML  PGMCHR            Re-inspect last token before
[1379] 8711 06,88,27        CALL RECENT            Precompute record entry
[1380] 8714 86,E0,03        CLR  V@OFS(@PABPTR)    Assume no pending record
       8717 04

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0024 
FLMGR-359
[1381] 8718 D6,42,B3        CEQ  COMMAZ,@CHAT      Make record pending
[1382] 871B 47,52           BR   G8752
[1383] 871D D4,07,10        CEQ  @VAR5,@RECLEN     Enough left pending
[1384] 8720 67,52           BS   G8752
[1385] 8722 A4,07,10        SUB  @VAR5,@RECLEN     Compute remaining # of fields
[1386] 8725 A4,11,07        SUB  @RECLEN,@VAR6     # of fields used in last reco
[1387] 8728 D6,B0,20 INPZ32 CEQ  >82,V*VARW        +OFFSET
       872B 82
[1388] 872C 47,3A           BR   G873A             Skip quoted strings
[1389] 872E 91,20    G872E  DINC @VARW
[1390] 8730 D6,B0,20        CEQ  >82,V*VARW        +OFFSET
       8733 82
[1391] 8734 47,2E           BR   G872E
[1392] 8736 91,20           DINC @VARW
[1393] 8738 47,28           BR   INPZ32            Search for Nth data item
[1394] 873A 91,20    G873A  DINC @VARW             Update pointer
[1395] 873C D6,EF,FF        CEQ  >8C,V@-1(@VARW) * ","+OFFSET = >8C
       873F FF,20,8C
[1396] 8742 47,3A           BR   G873A
[1397] 8744 92,11           DEC  @VAR6             Commas denote end of field
[1398] 8746 47,28           BR   INPZ32            Continue until done
[1399] 8748 A5,20,E0        DSUB V@BUF(@PABPTR),@VARW Compute current offset
       874B 06,04
[1400] 874D BC,E0,03        ST   @VARW+1,V@OFS(@PABPTR) Store for next round
       8750 04,21
[1401] 8752 BC,11,10 G8752  ST   @VAR5,@VAR6       Copy # of variables for check
[1402] 8755 BD,0A,14        DST  @CURLIN,@STADDR   Restore from temp
[1403] 8758 47,86           BR   G8786
[1404] 875A 06,97,42 G875A  CALL INITKB            Initialize some variables for
[1405] 875D BD,A3,AA        DST  @PGMPTR,V@INPUTP  Save for "try agian" case
       8760 2C
[1406] 8761 BD,A3,BC        DST  @CCPPTR,V@CPTEMP  Save CCPPTR, RECLEN for "try
       8764 06
[1407]               *                         Entry point for "try again" case
[1408] 8765 06,89,06 INPZ33 CALL INSUB1            Put out prompt
[1409] 8768 06,92,8D INPZ2  CALL GETVAR            Get variable list on V-stack
[1410] 876B 06,89,3B INPUZ3 CALL INSUB2            Read from the screen
[1411] 876E 86,11           CLR  @VAR6             Assume no values input
[1412] 8770 0F,7F           XML  CRUNCH            Crunch the input line
[1413] 8772 01              BYTE 1               * Indicate input stmt scan
[1414] 8773 BD,0A,14        DST  @CURLIN,@STADDR   Restore from temp
[1415] 8776 8F,22           DCZ  @ERRCOD           If got some crunch error
[1416] 8778 47,BB           BR   WRNINP
[1417] 877A 0F,83           XML  SCROLL            Scroll up after crunching
[1418] 877C BE,7F,03        ST   3,@XPT            Reset XPT too - pending recor
[1419] 877F 90,11           INC  @VAR6             # fields = # of commas + 1
[1420] 8781 D4,10,11        CEQ  @VAR6,@VAR5       # of variables wrong
[1421] 8784 47,BB           BR   WRNINP
[1422]               * Once we're here, all information should be availiable
[1423]               * After type verification for input and variables, push
[1424]               * all value entries on the V-stack.
[1425]               * VAR6 = VAR5 = number of variables
[1426] 8786 BD,14,34 G8786  DST  @DATA,@CURLIN     Save current DATA pointer
[1427] 8789 BF,34,08        DST  CRNBUF,@DATA      Get crunch entry
       878C 20
[1428] 878D BD,02,0E        DST  @VAR4,@MNUM       Get entry in V-stack before P
[1429] 8790 A3,02,00 INPUZ4 DADD 8,@MNUM           Point to first symbol table e
       8793 08
[1430] 8794 BD,06,B0        DST  V*MNUM,@CCPPTR    Get immedediate result
       8797 02
[1431] 8798 06,93,0F        CALL GETRAM            Get value descriptor from RAM
[1432] 879B DA,B0,06        CLOG >80,V*CCPPTR      Numerical value
       879E 80
[1433] 879F 47,CF           BR   G87CF

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0025 
FLMGR-359
[1434] 87A1 06,92,EF        CALL CHKNUM            Check entered value against n
[1435] 87A4 47,B4           BR   INPUZ5            Found error
[1436] 87A6 8E,17           CZ   @DSRFLG           Do not check overflow in file
[1437]               *                              supply machine infinity with
[1438]               *                              appropriate sign and continu
[1439] 87A8 67,D4           BS   INPUZ6
[1440] 87AA 8E,A3,BA        CZ   V@CSNTP1          Watch out for overflow in scr
[1441] 87AD 67,D4           BS   INPUZ6
[1442] 87AF BD,34,14        DST  @CURLIN,@DATA     Restore DATA pointer
[1443] 87B2 47,BF           BR   WRZZ5             Ask for input re-enter
[1444] 87B4 8E,17    INPUZ5 CZ   @DSRFLG           FILE I/O IS FATAL
[1445] 87B6 77,D2           BS   ERRINP
[1446] 87B8 BD,34,14        DST  @CURLIN,@DATA     Restore DATA pointer on error
[1447] 87BB 06,6A,82 WRNINP CALL WARNZZ            Go here for simple warnings t
[1448] 87BE 20              BYTE 32              * INPUT ERROR - TRY AGAIN
[1449] 87BF 06,88,3A WRZZ5  CALL SCRZ              Scroll the screen and reset C
[1450] 87C2 BD,2C,A3        DST  V@INPUTP,@PGMPTR  Restore ptr to "prompt" if an
       87C5 AA
[1451] 87C6 BD,06,A3        DST  V@CPTEMP,@CCPPTR  Restore CCPPTR, RECLEN, for t
       87C9 BC
[1452] 87CA BD,6E,0E        DST  @VAR4,@VSPTR      Restore original stack ptr
[1453] 87CD 47,65           BR   INPZ33
[1454] 87CF 06,93,26 G87CF  CALL CHKSTR            Check string input
[1455] 87D2 67,B4           BS   INPUZ5            ERROR ... CHECK I/O TYPE
[1456] 87D4 06,93,0F INPUZ6 CALL GETRAM            Get separation character (RAM
[1457] 87D7 D6,01,B3        CEQ  COMMAZ,@VAR0+1
[1458] 87DA 67,E6           BS   G87E6
[1459] 87DC 92,11           DEC  @VAR6             Has to be end of data
[1460] 87DE 47,B4           BR   INPUZ5            If not ... ERROR
[1461] 87E0 8E,01           CZ   @VAR0+1
[1462] 87E2 47,B4           BR   INPUZ5
[1463] 87E4 47,EA           BR   G87EA
[1464] 87E6 92,11    G87E6  DEC  @VAR6             Count number of value entries
[1465] 87E8 47,90           BR   INPUZ4            Continue
[1466]               * Assign cycle - assign values to variables because it resc
[1467]               * the program line, this code can not be udes for inperativ
[1468]               * statements , since the crunch buffer get's destroyed on
[1469]               * input. The rescan is necessary because subscripts should
[1470]               * evaluated AFTER all previous values have been assigned. i
[1471]               *        INPUT I,A(I)      with values 2,3
[1472]               * Should assign value 3 to A(2) !!!!!!!!!
[1473]               * No error-checking is done here, since types are already
[1474]               * validated. We might get subscripts out of range though!!!
[1475] 87EA BF,34,08 G87EA  DST  CRNBUF,@DATA      Prepare for input rescan
       87ED 20
[1476] 87EE BD,2C,0A        DST  @STADDR,@PGMPTR   Restore token pointer for res
[1477] 87F1 93,2C           DDEC @PGMPTR           Backup on token
[1478] 87F3 BD,6E,0E        DST  @VAR4,@VSPTR      Restore original stack pointe
[1479] 87F6 0F,79    INPZ65 XML  PGMCHR            Get next program characters
[1480] 87F8 06,95,B0        CALL CHKEND            Might have , before EOS
[1481] 87FB 68,22           BS   INPUZ7
[1482] 87FD 06,97,E6        CALL BUG01             Rescan variable name
[1483]               * Above call fixes bug.       Get correct entry for arrays
[1484] 8800 0F,77           XML  VPUSH             Save on stack for ASSGNV
[1485] 8802 06,93,0F        CALL GETRAM            Get first token of input valu
[1486] 8805 D6,4C,65        CEQ  STRVAL,@FAC2      Numerical case
[1487] 8808 68,0F           BS   G880F
[1488] 880A 06,92,EF        CALL CHKNUM            Check for numerical value
[1489] 880D 68,18           BS   INPZ67            COND should be set (valid num
[1490] 880F 06,93,26 G880F  CALL CHKSTR            Get the correct string value
[1491] 8812 BD,0C,50        DST  @FAC6,@BYTES      Length for temporary string
[1492] 8815 06,92,E1        CALL CTMPST            Create temporary string
[1493] 8818 0F,7C    INPZ67 XML  ASSGNV            Assign value to variable
[1494] 881A 06,93,0F        CALL GETRAM            Skip separator (already check

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0026 
FLMGR-359
[1495] 881D 06,95,B0        CALL CHKEND            Check for end to statement
[1496] 8820 47,F6           BR   INPZ65            Found it
[1497] 8822 BD,34,14 INPUZ7 DST  @CURLIN,@DATA     Restore DATA pointer
[1498] 8825 0F,75           XML  CONT              Contiue in PARSE
[1499] 8827 BC,21,E0 RECENT ST   V@OFS(@PABPTR),@VARW+1  Get record offset
       882A 03,04
[1500] 882C 86,20           CLR  @VARW             Double byte value required
[1501] 882E A1,20,E0        DADD V@BUF(@PABPTR),@VARW   Got it
       8831 06,04
[1502] 8833 00              RTN                    AND NOW, THE END IS NEAR...
[1503] 8834 C7,08,02 CHKRM  DCH  SCRNBS+29,@CCPADR Not enough room for "?"
       8837 FD
[1504] 8838 48,40           BR   G8840
[1505] 883A 0F,83    SCRZ   XML  SCROLL            Scroll one line for "?"
[1506] 883C BF,08,02        DST  SCRNBS+2,@CCPADR   and update CCPADR accordingl
       883F E2
[1507] 8840 00       G8840  RTN
[1508]               ***********************************************************
[1509]               *                LINPUT ROUTINE
[1510]               * If file-I/O then
[1511]               *             Get file number and check it
[1512]               *             Internal file not allowed
[1513]               * End if
[1514]               * Get variable info
[1515]               * Must be string variable
[1516]               * If file I/O then
[1517]               *           If no-partial-record of REC clause included
[1518]               *           Read new record
[1519]               *     End if
[1520]               *     Set up copy pointers
[1521]               * Else
[1522]               *     Call readline to read from keyboard
[1523]               *     Copy to crunch buffer adjustin g for screen offset
[1524]               * End if
[1525]               * Get string of proper length
[1526]               * Move data into string
[1527]               * Assign string
[1528]               * Done.
[1529]               ***********************************************************
[1530] 8841 06,97,42 LINPUT CALL INITKB            Assume input from keyboard
[1531] 8844 D6,42,FD        CEQ  NUMBEZ,@CHAT      If "#" - then device
[1532] 8847 48,5C           BR   G885C
[1533] 8849 06,93,58        CALL CHKFN             Check for default = 0
[1534] 884C 8F,4A           DCZ  @FAC              #0 is assumed
[1535] 884E 68,5F           BS   LINP10
[1536] 8850 06,88,E8        CALL INSU1             Parse the device #
[1537] 8853 DA,E0,05        CLOG >08,V@FLG(@PABPTR)
       8856 04,08
[1538] 8858 57,DA           BR   ERRFE
[1539] 885A 48,5F           BR   LINP10
[1540] 885C 06,89,06 G885C  CALL INSUB1            Handle possible prompt
[1541] 885F BD,0E,6E LINP10 DST  @VSPTR,@VAR4      Save original V-pointer
[1542]               *                              incase BREAK in READLN
[1543] 8862 06,97,E6        CALL BUG01             Get info about the symbol
[1544]               * Above call fixes bug.       Get value pointer and type
[1545] 8865 D6,4C,65        CEQ  STRVAL,@FAC2      Must be string
[1546] 8868 57,E2           BR   ERRMUV
[1547] 886A 0F,77           XML  VPUSH
[1548] 886C 8E,17           CZ   @DSRFLG           If device I/O
[1549] 886E 48,AF           BR   G88AF
[1550] 8870 8E,E0,03        CZ   V@OFS(@PABPTR)    If new record
       8873 04
[1551] 8874 48,7B           BR   G887B
[1552] 8876 06,97,68        CALL IOCLZ1            Read the record

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0027 
FLMGR-359
[1553] 8879 48,93           BR   G8893
[1554] 887B BC,0C,E0 G887B  ST   V@CNT(@PABPTR),@BYTES Get length of record
       887E 09,04
[1555] 8880 BD,66,E0        DST  V@BUF(@PABPTR),@TEMP5 Get address of buffer
       8883 06,04
[1556] 8885 8E,0C    G8885  CZ   @BYTES            While characters in buffer
[1557] 8887 68,93           BS   G8893
[1558] 8889 A6,B0,66        SUB  OFFSET,V*TEMP5    Remove INPUT's offset
       888C 60
[1559] 888D 91,66           DINC @TEMP5            Increment pointer
[1560] 888F 92,0C           DEC  @BYTES            Decrement count
[1561] 8891 48,85           BR   G8885             Drop out directly when done
[1562] 8893 86,66    G8893  CLR  @TEMP5            Need a word value
[1563] 8895 BC,67,E0        ST   V@OFS(@PABPTR),@TEMP5+1  Restore value
       8898 03,04
[1564] 889A 86,0C           CLR  @BYTES            Need a word value
[1565] 889C BC,0D,E0        ST   V@CNT(@PABPTR),@BYTES+1  Get the length
       889F 09,04
[1566] 88A1 A5,0C,66        DSUB @TEMP5,@BYTES     Calcualte length
[1567] 88A4 A1,66,E0        DADD V@BUF(@PABPTR),@TEMP5  Current buffer address
       88A7 06,04
[1568] 88A9 86,E0,03        CLR  V@OFS(@PABPTR)    Read next record next time
       88AC 04
[1569] 88AD 48,E1           BR   G88E1             Else if keyboard input
[1570] 88AF 06,89,3B G88AF  CALL INSUB2            Clear line and call READLN
[1571] 88B2 87,0C           DCLR @BYTES            Initialize byte counter
[1572] 88B4 BD,66,0A        DST  @RAMPTR,@TEMP5    Initialize "crunch" pointer
[1573] 88B7 D6,B0,2A        CEQ  SPACE+OFFSET,V*VARA     If space
       88BA 80
[1574] 88BB 48,BF           BR   G88BF
[1575] 88BD 93,2A           DDEC @VARA             Don't include space on end
[1576] 88BF CD,20,2A G88BF  DCGT @VARA,@VARW       While not at end
[1577] 88C2 68,DC           BS   G88DC
[1578] 88C4 BC,00,B0        ST   V*VARW,@VAR0      Get the character
       88C7 20
[1579] 88C8 D6,00,7F        CEQ  EDGECH,@VAR0      If not at edge character
[1580] 88CB 68,D8           BS   G88D8
[1581] 88CD A6,00,60        SUB  OFFSET,@VAR0      Subtract screen offset
[1582] 88D0 BC,B0,0A        ST   @VAR0,V*RAMPTR    And put into crunch buffer
       88D3 00
[1583] 88D4 91,0C           DINC @BYTES            Count it
[1584] 88D6 91,0A           DINC @RAMPTR           And update "crunch" pointer
[1585] 88D8 91,20    G88D8  DINC @VARW             Update input pointer
[1586] 88DA 48,BF           BR   G88BF
[1587] 88DC 0F,83    G88DC  XML  SCROLL            Scroll the screen
[1588] 88DE BE,7F,03        ST   3,@XPT            Initialize x-pointer
[1589] 88E1 06,92,E1 G88E1  CALL CTMPST            Create temporary string
[1590] 88E4 0F,7C           XML  ASSGNV            Assign the value to it
[1591] 88E6 0F,75           XML  CONT              And continue execution
[1592]               * Get file number and info about the file
[1593] 88E8 06,93,74 INSU1  CALL CHKCON            Check & convert & search
[1594] 88EB 57,DA           BR   ERRFE             Give error if required
[1595]               * INPUT allowed for input and update modes
[1596] 88ED DA,E0,05        CLOG >02,V@FLG(@PABPTR)
       88F0 04,02
[1597] 88F2 57,DA           BR   ERRFE
[1598] 88F4 06,93,93        CALL OUTEOF            Output pending PRINT stuff
[1599] 88F7 BE,E0,04        ST   CZREAD,V@COD(@PABPTR)   Ensure read operation
       88FA 04,02
[1600] 88FC 06,94,C5        CALL PARREC            Parse REC clause
[1601] 88FF 0F,7E           XML  SPEED             Must be at a
[1602] 8901 00              BYTE SYNCHK          *  colon else
[1603] 8902 B5              BYTE COLONZ          *   its and error
[1604] 8903 86,17           CLR  @DSRFLG           Clear keyboard input flag

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0028 
FLMGR-359
[1605] 8905 00              RTN
[1606]               * Parse and put out input prompt
[1607] 8906 BD,0A,2C INSUB1 DST  @PGMPTR,@STADDR   Save pointer for prompt check
[1608] 8909 93,0A           DDEC @STADDR           Backup to previous token
[1609]               *                              Go into a tight loop
[1610] 890B 06,95,BD G890B  CALL NXTCHR            Get next program character
[1611] 890E 69,27           BS   INPZ37            Detected end of statement
[1612] 8910 D6,42,B5        CEQ  COLONZ,@CHAT      Stop if we find a colon
[1613] 8913 49,0B           BR   G890B
[1614] 8915 BD,2C,0A        DST  @STADDR,@PGMPTR   Backup for actual prompt scan
[1615] 8918 0F,79           XML  PGMCHR            Jump into 1st char of prompt
[1616] 891A 0F,74           XML  PARSE             And try to decode string expr
[1617] 891C B5              BYTE COLONZ
[1618] 891D D6,4C,65        CEQ  STRVAL,@FAC2      Number prompt illegal
[1619] 8920 57,C2           BR   ERRSNM
[1620] 8922 06,97,11        CALL OSTRNG            Output the given prompt
[1621] 8925 49,36           BR   INPZ39            Exit without prompt backup
[1622] 8927 BD,2C,0A INPZ37 DST  @STADDR,@PGMPTR   Backup to beginning of line
[1623] 892A BE,42,B5        ST   COLONZ,@CHAT      Fake prompt with ":"
[1624] 892D 06,88,34 INPUZ2 CALL CHKRM             Check for room for ?
[1625] 8930 BE,B0,08        ST   >9F,V*CCPADR      Display ?
       8933 9F
[1626] 8934 95,08           DINCT @CCPADR          Count it too
[1627] 8936 0F,7E    INPZ39 XML  SPEED             Must be at a
[1628] 8938 00              BYTE SYNCHK          *  colon else
[1629] 8939 B5              BYTE COLONZ          *   its an error
[1630] 893A 00              RTN
[1631]               * Issue 'BEEP' and call read line to read form screen
[1632] 893B 06,88,34 INSUB2 CALL CHKRM             Check for room for answer
[1633] 893E BD,20,08        DST  @CCPADR,@VARW     Copy current cursor position
[1634] 8941 BE,B0,08 G8941  ST   >80,V*CCPADR      Clear the remainder
       8944 80
[1635] 8945 91,08           DINC @CCPADR            of the current line
[1636] 8947 CB,08,02        DCHE >02FE,@CCPADR     Stop if we're there
       894A FE
[1637] 894B 49,41           BR   G8941
[1638] 894D BF,A2,FE        DST  >7F7F,V@>02FE     Replace edgechars
       8950 7F,7F
[1639] 8952 8E,80,CE        CZ   @PRTNFN           If previous tone finished
[1640] 8955 49,5A           BR   G895A
[1641] 8957 06,00,34        CALL TONE1             ---------- BEEP -------------
[1642] 895A C1,6E,0E G895A  DEX  @VAR4,@VSPTR      Don't destroy V-stack on BREA
[1643] 895D 06,6A,76        CALL READLN            Input a line from the keyboar
[1644] 8960 C1,6E,0E        DEX  @VAR4,@VSPTR      Restore V-stack pointer
[1645] 8963 BD,14,0A        DST  @STADDR,@CURLIN   Save in a temp
[1646] 8966 BF,0A,08        DST  CRNBUF,@RAMPTR    Init crunch buffer pointer
       8969 20
[1647] 896A 00              RTN
[1648]               ***********************************************************
[1649]               *                   ACCEPT STATEMENT
[1650]               * Accept input anywhere on the screen. The total number of
[1651]               * input variables is limited to one. On an ACCEPT AT( , ),
[1652]               * the maximum number that can be accepted is up to the righ
[1653]               * margin!!!! If SIZE() is used, the maximum number is
[1654]               * limited to the given SIZE, or to the number of characters
[1655]               * remaining on the line, whichever is the lesser.
[1656]               ***********************************************************
[1657]               * RXB PATCH TO FIX ACCEPT USED IN EDIT MODE               
[1658]               * ACCEPT CLR  V@ACCTRY          Clear "try again" flag
[1659] 896B 05,97,F9 ACCEPT B    ACCPMM
[1660] 896E 06,94,F2 ACCEP2 CALL DISACC            Use common code for DISPLAY/A
[1661] 8971 61,09           BS   ERRSYN             COND set means end of statem
[1662] 8973 BE,63,FF        ST   >FF,@ARG7         Assume we don't have VALIDATE
[1663]               ************ VALIDATE OPTION HANDLING *********************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0029 
FLMGR-359
[1664] 8976 D6,42,FE        CEQ  VALIDZ,@CHAT      Detected VALIDATE option
[1665] 8979 49,FD           BR   G89FD
[1666] 897B 0F,79           XML  PGMCHR            Next character should start o
[1667] 897D D6,42,B7        CEQ  LPARZ,@CHAT       "* SYNTAX ERROR *"
[1668] 8980 41,09           BR   ERRSYN
[1669] 8982 B6,04,40        OR   >40,@PABPTR       Indicate usage of validate cl
[1670] 8985 BF,2A,00        DST  1,@VARA           Use VARA as length of option
       8988 01
[1671] 8989 87,20           DCLR @VARW             VARW= options used, VARW+1=#0
[1672]               *                              stack entries for strings
[1673] 898B 0F,79    G898B  XML  PGMCHR            Skip separator token
[1674] 898D CA,42,E8        CHE  NUMERZ,@CHAT      Could be valid option
[1675] 8990 49,AA           BR   G89AA
[1676] 8992 CA,42,EB        CHE  UALPHZ+1,@CHAT    It is ....
[1677] 8995 69,AA           BS   G89AA
[1678] 8997 BE,5C,01        ST   1,@ARG            Select bit 0 as number option
[1679] 899A A6,42,E8        SUB  NUMERZ,@CHAT      Create correct offset
[1680] 899D 69,A2           BS   SETVW             Skip the shift stat.
[1681] 899F E0,5C,42        SLL  @CHAT,@ARG        Then select whatever option w
[1682] 89A2 B4,20,5C SETVW  OR   @ARG,@VARW        Remember options in VARW
[1683]               *                              stack entries for strings
[1684] 89A5 0F,79           XML  PGMCHR            Get next token
[1685] 89A7 05,89,C4        B    VLIDZ0            Must use a long branch here
[1686] 89AA 0F,74    G89AA  XML  PARSE             Try to decode a string expres
[1687] 89AC B6              BYTE RPARZ
[1688] 89AD D6,4C,65        CEQ  STRVAL,@FAC2      String-number mismatch
[1689] 89B0 57,C2           BR   ERRSNM
[1690] 89B2 8E,51           CZ   @FAC7             Only count non-null strings
[1691] 89B4 69,C4           BS   VLIDZ0
[1692] 89B6 A0,2B,51        ADD  @FAC7,@VARA+1     Now watch out for overflow
[1693] 89B9 0C              CARRY                  Sting truncated
[1694] 89BA 49,C0           BR   G89C0
[1695] 89BC 06,6A,84        CALL ERRZZ             * STRING TRUNCATED ERROR *
[1696] 89BF 13              BYTE 19
[1697] 89C0 0F,77    G89C0  XML  VPUSH             Push the result for future re
[1698] 89C2 90,21           INC  @VARW+1           Count number of entries on st
[1699] 89C4 D6,42,B3 VLIDZ0 CEQ  COMMAZ,@CHAT      Evaluate all fields
[1700] 89C7 69,8B           BS   G898B
[1701] 89C9 0F,7E           XML  SPEED
[1702] 89CB 00              BYTE SYNCHK          * Check for ")" on end
[1703] 89CC B6              BYTE RPARZ           * If not, "* SYNTAX ERROR *"
[1704] 89CD 06,94,F5        CALL DISPZ1            Try to evaluate further optio
[1705] 89D0 61,09           BS   ERRSYN            Premature end of statement
[1706] 89D2 BD,0C,2A        DST  @VARA,@BYTES      Allocate string for character
[1707] 89D5 0F,71           XML  GETSTR
[1708] 89D7 BD,5C,1C        DST  @SREF,@ARG        Get start of allocated string
[1709] 89DA BC,B0,5C        ST   @VARW,V*ARG       Get start of allocated string
       89DD 20
[1710] 89DE 91,5C           DINC @ARG              Leave room form standard opti
[1711] 89E0 8E,21    G89E0  CZ   @VARW+1           Copy all available informatio
[1712] 89E2 69,F3           BS   G89F3
[1713] 89E4 0F,78           XML  VPOP              Regain stack-entry
[1714] 89E6 34,50,B0        MOVE @FAC6,V*FAC4,V*ARG Copy string
       89E9 5C,B0,4E
[1715] 89EC A1,5C,50        DADD @FAC6,@ARG        Update destination address
[1716] 89EF 92,21           DEC  @VARW+1           Count # of stack entries
[1717] 89F1 49,E0           BR   G89E0
[1718] 89F3 BD,A3,B0 G89F3  DST  @SREF,V@VALIDP    Copy start address of string
       89F6 1C
[1719] 89F7 BD,A3,B2        DST  @VARA,V@VALIDL     and total string length
       89FA 2A
[1720] 89FB 86,63           CLR  @ARG7             Indicate VALIDATE usage of RE
[1721] 89FD BD,20,08 G89FD  DST  @CCPADR,@VARW     Save start address of the fie
[1722] 8A00 BD,2A,20        DST  @VARW,@VARA       Set default highest address u

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0030 
FLMGR-359
[1723] 8A03 BD,5E,08        DST  @CCPADR,@ARG2     Select absolute highest usabl
[1724] 8A06 A3,5E,01        DADD 290,@ARG2         290=2+32*9 maximum of 254 cha
       8A09 22
[1725] 8A0A C6,2B,FC        CH   >FC,@VARA+1       Start at the end of line
[1726] 8A0D 4A,13           BR   G8A13
[1727] 8A0F A3,5E,00        DADD 4,@ARG2
       8A12 04
[1728] 8A13 8E,04    G8A13  CZ   @PABPTR           We used some options like AT,
[1729] 8A15 6A,66           BS   G8A66
[1730] 8A17 0F,7E           XML  SPEED
[1731] 8A19 00              BYTE SYNCHK          * Should always end on ":"
[1732] 8A1A B5              BYTE COLONZ
[1733] 8A1B DA,04,02        CLOG >02,@PABPTR       Used BEEP clause
[1734] 8A1E 6A,23           BS   G8A23
[1735] 8A20 06,00,34        CALL TONE1             Wake up the user
[1736] 8A23 DA,04,04 G8A23  CLOG >04,@PABPTR       Used AT option, SIZE!!!
[1737] 8A26 6A,35           BS   G8A35
[1738] 8A28 DA,04,08        CLOG >08,@PABPTR       Use defualt SIZE option
[1739] 8A2B 4A,33           BR   G8A33
[1740] 8A2D BE,05,1C        ST   VWIDTH,@PABPTR+1  Limit current record length
[1741] 8A30 06,95,E2        CALL SIZE1
[1742] 8A33 4A,47    G8A33  BR   ACCPZ1
[1743] 8A35 DA,04,08 G8A35  CLOG >08,@PABPTR       SIZE option used somewhere
[1744] 8A38 6A,66           BS   G8A66
[1745]               * We're sure now that SIZE has been used WITHOUT the AT
[1746]               * option, this means that we should set XPT to point behind
[1747]               * the SIZE field. This can be done by adding the record
[1748]               * length to the current screen base address and the line's
[1749]               * screen base address
[1750] 8A3A BC,7F,09        ST   @CCPADR+1,@XPT    Start of with current address
[1751] 8A3D A0,7F,07        ADD  @RECLEN,@XPT      Add in the current record len
[1752] 8A40 A6,7F,DF        SUB  >DF,@XPT          And subtract the lower base a
[1753]               *                             Also adjust for edge characte
[1754] 8A43 BC,A3,B8        ST   @XPT,V@SIZXPT     Save it for "try again" case
       8A46 7F
[1755]               *                              in WARNING, XPT gets changed
[1756] 8A47 BD,A3,B4 ACCPZ1 DST  @CCPADR,V@SIZCCP  Save for "try again" case
       8A4A 08
[1757] 8A4B BC,A3,B6        ST   @RECLEN,V@SIZREC  Save for "try again" case
       8A4E 07
[1758]               ***********************************************************
[1759]               * ENTRY POINT FOR "TRY AGAIN" CASE WHEN SIZE OR ACCEPT USED
[1760]               ***********************************************************
[1761] 8A4F DA,04,80 ACCPZ9 CLOG >80,@PABPTR       Blank current field
[1762] 8A52 4A,58           BR   G8A58
[1763] 8A54 BE,B0,08        ST   SPACE+OFFSET,V*CCPADR
       8A57 80
[1764] 8A58 91,08    G8A58  DINC @CCPADR           Update screen address
[1765] 8A5A 92,07           DEC  @RECLEN           Reduce count, always at least
[1766] 8A5C 4A,4F           BR   ACCPZ9            Loop until at end of field
[1767] 8A5E 93,08           DDEC @CCPADR           Fix end of field for maximum
[1768] 8A60 BD,2A,08        DST  @CCPADR,@VARA     Set highest location availabl
[1769] 8A63 BD,5E,2A        DST  @VARA,@ARG2       Also highest location availab
[1770]               *                              OK all set to go
[1771] 8A66 D6,A3,B7 G8A66  CEQ  1,V@ACCTRY        Skip if in "try again"
       8A69 01
[1772] 8A6A 6A,74           BS   ACCPZ7
[1773] 8A6C BD,0E,6E        DST  @VSPTR,@VAR4      Save first entry in V-stack
[1774] 8A6F 06,97,E6        CALL BUG01             Collect the symbol designator
[1775]               * Above call fixes bug.       Take care of arrays too
[1776] 8A72 0F,77           XML  VPUSH             Save symbol table entry
[1777] 8A74 BD,A3,AC ACCPZ7 DST  @VARW,V@ACCVRW    Save for trying again case
       8A77 20
[1778] 8A78 BD,A3,AE        DST  @VARA,V@ACCVRA    Save for trying again case

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0031 
FLMGR-359
       8A7B 2A
[1779]               ***********************************************************
[1780]               * ENTRY POINT FOR "TRY AGAIN" WHEN NEITHER SIZE OR ACCEPT I
[1781]               ***********************************************************
[1782]               * In case a CALL CLEAR or ERASE ALL or CALL HCHAR has just
[1783]               * processed, EDGE CHARS, are gone at the bottom line
[1784] 8A7C DA,04,0C ACCPZ5 CLOG >0C,@PABPTR       If AT/SIZE used, maximum fiel
[1785] 8A7F 4A,86           BR   AZ1                is line, so no need to worry
[1786]               *                              about it
[1787] 8A81 BF,A2,FE        DST  >7F7F,V@>02FE     Put the EDGE CHAR back
       8A84 7F,7F
[1788] 8A86 C1,0E,6E AZ1    DEX  @VSPTR,@VAR4      Don't destroy V-stack on BREA
[1789] 8A89 06,6A,86        CALL READL1            Ask for some input that can b
[1790]               *                             used
[1791] 8A8C C1,0E,6E        DEX  @VSPTR,@VAR4      Resote V-stack pointer
[1792]               * At this point, VARA contains the highest location used,
[1793]               * and VARW contains the string's start address
[1794] 8A8F D5,2A,20 ACCPZ2 DCEQ @VARW,@VARA       Only non-empty string
[1795] 8A92 6A,9E           BS   G8A9E
[1796] 8A94 93,2A           DDEC @VARA             Go to the next position
[1797] 8A96 D6,B0,2A        CEQ  SPACE+OFFSET,V*VARA
       8A99 80
[1798] 8A9A 6A,8F           BS   ACCPZ2
[1799] 8A9C 91,2A           DINC @VARA             Back to the last space
[1800] 8A9E 0F,78    G8A9E  XML  VPOP              Check the symbol designator i
[1801] 8AA0 0F,77           XML  VPUSH             a string or numeric variable
[1802] 8AA2 D6,4C,65        CEQ  >65,@FAC2         If numeric : empty string is
[1803] 8AA5 6A,B2           BS   G8AB2
[1804] 8AA7 D5,20,2A        DCEQ @VARA,@VARW       If an empty string was entere
[1805] 8AAA 4A,B2           BR   G8AB2
[1806] 8AAC 06,6A,82        CALL WARNZZ            *** INPUT ERROR ***
[1807] 8AAF 20              BYTE 32
[1808] 8AB0 4A,FC           BR   ACCPZ8
[1809] 8AB2 87,0C    G8AB2  DCLR @BYTES            Compute length of input strin
[1810] 8AB4 BD,1C,20        DST  @VARW,@SREF       Use SREF as temporary variabl
[1811] 8AB7 D5,1C,2A G8AB7  DCEQ @VARA,@SREF
[1812] 8ABA 6A,C8           BS   G8AC8
[1813] 8ABC D6,B0,1C        CEQ  EDGECH,V*SREF     Exclude edge character
       8ABF 7F
[1814] 8AC0 6A,C4           BS   G8AC4
[1815] 8AC2 91,0C           DINC @BYTES
[1816] 8AC4 91,1C    G8AC4  DINC @SREF             Decrement the counter
[1817] 8AC6 4A,B7           BR   G8AB7
[1818] 8AC8 06,92,D4 G8AC8  CALL CTSTR0            Create a temporary string
[1819] 8ACB D5,20,2A ACCPZ3 DCEQ @VARA,@VARW
[1820] 8ACE 6A,EB           BS   G8AEB
[1821] 8AD0 D6,B0,20        CEQ  EDGECH,V*VARW     Skip the edge character
       8AD3 7F
[1822] 8AD4 4A,DC           BR   G8ADC
[1823] 8AD6 A3,20,00        DADD 4,@VARW
       8AD9 04
[1824] 8ADA 4A,CB           BR   ACCPZ3
[1825] 8ADC BC,B0,1C G8ADC  ST   V*VARW,V*SREF     Copy the string
       8ADF B0,20
[1826] 8AE1 A6,B0,1C        SUB  OFFSET,V*SREF     Subtract the screen offset
       8AE4 60
[1827] 8AE5 91,20           DINC @VARW             Update pointers
[1828] 8AE7 91,1C           DINC @SREF
[1829] 8AE9 4A,CB           BR   ACCPZ3            Result can't be 0
[1830] 8AEB D6,4C,65 G8AEB  CEQ  STRVAL,@FAC2      Numerical variable
[1831] 8AEE 6B,2A           BS   ACCPZ6
[1832] 8AF0 BE,4C,65        ST   STRVAL,@FAC2      Create temp string
[1833] 8AF3 06,A0,16        CALL VALCD             Use VAL code for translation
[1834] 8AF6 4B,2A           BR   ACCPZ6            No error - ok go on

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0032 
FLMGR-359
[1835] 8AF8 06,6A,82 WRNSNM CALL WARNZZ            Error
[1836] 8AFB 07              BYTE 7               * STRING NUMBER MISMATCH
[1837] 8AFC DA,04,08 ACCPZ8 CLOG >08,@PABPTR       If SIZE is used
[1838] 8AFF 6B,0A           BS   G8B0A
[1839] 8B01 DA,04,04        CLOG >04,@PABPTR       Also AT is not used
[1840] 8B04 4B,0A           BR   G8B0A
[1841] 8B06 BC,7F,A3        ST   V@SIZXPT,@XPT     Restore XPT : in WARNING XPT
       8B09 B8
[1842] 8B0A BD,20,A3 G8B0A  DST  V@ACCVRW,@VARW    Restore @VARA, @VARW
       8B0D AC
[1843] 8B0E BD,2A,A3        DST  V@ACCVRA,@VARA
       8B11 AE
[1844] 8B12 BE,A3,B7        ST   1,V@ACCTRY        Set the "try again" flag
       8B15 01
[1845] 8B16 DA,04,08        CLOG >08,@PABPTR       If SIZE is not used
[1846] 8B19 4B,20           BR   G8B20
[1847]               * IF ACCEPT ALSO NOT USED. GOTO "TRY AGAIN" FORM HERE
[1848] 8B1B DA,04,04        CLOG >04,@PABPTR
[1849] 8B1E 6A,7C           BS   ACCPZ5
[1850]               * IF "EITHER SIZE OR ACCEPT IS USED" THEN
[1851] 8B20 BD,08,A3 G8B20  DST  V@SIZCCP,@CCPADR  Restore CCPADR
       8B23 B4
[1852] 8B24 BC,07,A3        ST   V@SIZREC,@RECLEN  Restore RECLEN
       8B27 B6
[1853] 8B28 4A,4F           BR   ACCPZ9            Go blanking the field and
[1854]               *                              "try again"
[1855] 8B2A 0F,7C    ACCPZ6 XML  ASSGNV            Should be ok now
[1856] 8B2C DA,04,0C        CLOG >0C,@PABPTR       Test usage of AT and/or SIZE
[1857] 8B2F 4B,36           BR   ACCPZ4            At least one of the two used
[1858] 8B31 0F,83           XML  SCROLL            Scroll the screen up
[1859] 8B33 BE,7F,03        ST   3,@XPT            And reset XPT
[1860] 8B36 0F,75    ACCPZ4 XML  CONT
[1861]               ***********************************************************
[1862]               *                  READ STATEMENT
[1863]               * Assign DATA values to variables in READ-list one at a
[1864]               * time. Possibly search for new DATA statements if the
[1865]               * current DATA statement has been used. Be careful with
[1866]               * null entries...!!!
[1867]               ***********************************************************
[1868] 8B38 0F,79    G8B38  XML  PGMCHR            Get character following ","
[1869] 8B3A 06,97,E6 READ   CALL BUG01             Get pointers and correct entr
[1870]               * Above call fixes bug.        also allow for array variabl
[1871] 8B3D 0F,77           XML  VPUSH             Push on Vstack for assignment
[1872] 8B3F 8E,34           CZ   @DATA             DATA ERROR
[1873] 8B41 77,D6           BS   ERRDAT
[1874] 8B43 06,93,07        CALL GETGFL            Get next data item (RAM/GROM)
[1875] 8B46 D6,4C,65        CEQ  STRVAL,@FAC2
[1876] 8B49 6B,6B           BS   G8B6B
[1877] 8B4B D6,01,C8        CEQ  NUMZ,@VAR0+1      Not a numeric
[1878] 8B4E 57,C2           BR   ERRSNM
[1879]               *                              string-number mismatch error
[1880] 8B50 06,93,32        CALL CHKSZ0            Build up string info
[1881] 8B53 91,50           DINC @FAC6             Force legal delimiter on end
[1882] 8B55 06,A0,02        CALL LITS05            Copy numeric into string spac
[1883] 8B58 BD,56,1C        DST  @SREF,@FAC12      Copy string start address
[1884] 8B5B A1,1C,50        DADD @FAC6,@SREF       Compute end address of string
[1885] 8B5E 93,1C           DDEC @SREF             Back up over delimiter
[1886] 8B60 06,A0,12        CALL CONV1             Convert string to number
[1887] 8B63 D5,A3,90        DCEQ @SREF,V@CSNTMP    WRONG!!!!!!!
       8B66 1C
[1888] 8B67 57,D6           BR   ERRDAT
[1889] 8B69 4B,73           BR   G8B73
[1890] 8B6B 06,93,26 G8B6B  CALL CHKSTR            Check string input
[1891] 8B6E 77,D6           BS   ERRDAT            Give error on error

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0033 
FLMGR-359
[1892] 8B70 06,A0,02        CALL LITS05            Allocate string in string spa
[1893] 8B73 0F,7C    G8B73  XML  ASSGNV            Assign variable
[1894] 8B75 06,93,07        CALL GETGFL            Get next datum from DATA stmt
[1895] 8B78 D6,01,B3        CEQ  COMMAZ,@VAR0+1    Has to be an end of DATA
[1896] 8B7B 6B,8F           BS   G8B8F
[1897] 8B7D 8E,01           CZ   @VAR0+1           Check for end of data
[1898] 8B7F 57,D6           BR   ERRDAT
[1899] 8B81 97,36           DDECT @LNBUF           Pointer to line # of DATA stm
[1900] 8B83 86,34           CLR  @DATA             Assume the worst - no more DA
[1901] 8B85 D5,36,30        DCEQ @STLN,@LNBUF
[1902] 8B88 6B,8F           BS   G8B8F
[1903] 8B8A 93,36           DDEC @LNBUF            Next line's 1st token address
[1904] 8B8C 06,A0,08        CALL DATAST            Get next DATA statement
[1905] 8B8F D6,42,B3 G8B8F  CEQ  COMMAZ,@CHAT      Worry about junk in CONT
[1906] 8B92 6B,38           BS   G8B38
[1907] 8B94 0F,75           XML  CONT
[1908]               * SRDATA-Search for DATA statements (DATA statement must
[1909]               * be the only statement on one line)
[1910]               * SEARCH-also used for searching IMAGE statement.
[1911] 8B96 BE,4C,93 SRDATA ST   DATAZ,@FAC2       Search for a DATA token
[1912] 8B99 C1,2C,34 SEARCH DEX  @DATA,@PGMPTR     Exchange with normal PC
[1913] 8B9C C0,01,42        EX   @CHAT,@VAR0+1     Preserve current PGM characte
[1914] 8B9F 8E,44           CZ   @PRGFLG           If imperative statement
[1915] 8BA1 4B,B3           BR   G8BB3
[1916] 8BA3 8E,80,84        CZ   @RAMTOP           With ERAM : text itself in ER
[1917] 8BA6 6B,B3           BS   G8BB3
[1918] 8BA8 BE,80,89        ST   >FF,@RAMFLG       Fake RAMFLG in this case
       8BAB FF
[1919] 8BAC 0F,79           XML  PGMCHR            Get first character on the li
[1920] 8BAE 86,80,89        CLR  @RAMFLG           Restore it back
[1921] 8BB1 4B,B5           BR   SRDAZ1            Skip that PGMCHR
[1922] 8BB3 0F,79    G8BB3  XML  PGMCHR            Get first character on the li
[1923] 8BB5 D4,42,4C SRDAZ1 CEQ  @FAC2,@CHAT       Search for specific token
[1924] 8BB8 6B,BD           BS   SRDAZ0
[1925] 8BBA D4,00,00        CEQ  @VAR0,@VAR0       Set COND if no DATA found
[1926] 8BBD C1,2C,34 SRDAZ0 DEX  @DATA,@PGMPTR     Exchange won't affect the CON
[1927] 8BC0 C0,01,42        EX   @CHAT,@VAR0+1     Situation ok
[1928] 8BC3 01              RTNC                   Return to caller with COND
[1929]               ***********************************************************
[1930]               *                     OLD STATEMENT
[1931]               * A normal load:
[1932]               *   Get a program from an external device to VDP and
[1933]               *   reinitialize the program pointers. Also update the line
[1934]               *   pointer table, since the memory size of the machine on
[1935]               *   which the program was created doesn't have to be the
[1936]               *   same as on the current system!!!! Then check if ERAM
[1937]               *   existed, move it to ERAM if does exist (in relocated
[1938]               *   from)
[1939]               * Load a sequential file:
[1940]               *   When program is bigger than 13.5K and ERAM exists,
[1941]               *   maximum-length record reads are preformed to read the
[1942]               *   file and each record is copied into the ERAM as it is
[1943]               *   read.
[1944]               ***********************************************************
[1945] 8BC4 06,8B,CA OLD    CALL OLD1              Make OLD1 a subroutine for LO
[1946] 8BC7 05,60,12        B    TOPL15            Go back to top level
[1947] 8BCA 06,92,38 OLD1   CALL GPNAME            Get program name & reinitiali
[1948] 8BCD 0F,79           XML  PGMCHR            Check for EOL
[1949] 8BCF BD,0A,04        DST  @PABPTR,@STADDR   Compute memory start address
[1950] 8BD2 A1,0A,E0        DADD V@NLEN-1(@PABPTR),@STADDR    Add PAB-name lengt
       8BD5 0C,04
[1951] 8BD7 A3,0A,00        DADD PABLEN-4,@STADDR              and PAB length
       8BDA 0A
[1952] 8BDB BD,E0,0A        DST  @HIVDP,V@RNM(@PABPTR)  Compute # of availiable

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0034 
FLMGR-359
       8BDE 04,70
[1953] 8BE0 A5,E0,0A        DSUB @STADDR,V@RNM(@PABPTR)
       8BE3 04,0A
[1954] 8BE5 91,E0,0A        DINC V@RNM(@PABPTR)    Include current address
       8BE8 04
[1955] 8BE9 BD,E0,06        DST  @STADDR,V@BUF(@PABPTR) for copy start
       8BEC 04,0A
[1956] 8BEE BE,E0,04        ST   CZLOAD,V@COD(@PABPTR)   Select LOAD I/O code
       8BF1 04,05
[1957] 8BF3 06,97,6E        CALL CDSR              Call device service routine
[1958] 8BF6 4C,63           BR   OLDZ3             Not a program file, may be a
[1959]               *                              sequential file
[1960]               * STADDR still points to the info bytes
[1961] 8BF8 BD,02,E0        DST  V@2(@STADDR),@MNUM First test checksum
       8BFB 02,0A
[1962] 8BFD B9,02,E0        DXOR V@4(@STADDR),@MNUM  which is a simple XOR
       8C00 04,0A
[1963] 8C02 D5,B0,0A        DCEQ @MNUM,V*STADDR     Try PROTECTION option
       8C05 02
[1964] 8C06 6C,15           BS   G8C15
[1965] 8C08 83,02           DNEG @MNUM
[1966] 8C0A D5,B0,0A        DCEQ @MNUM,V*STADDR    No-ERROR
       8C0D 02
[1967] 8C0E 4D,2D           BR   OLDER
[1968] 8C10 B6,45,80        OR   >80,@FLAG         Yes, set LIST/EDIT PROTECTION
[1969] 8C13 4C,17           BR   G8C17
[1970] 8C15 86,45    G8C15  CLR  @FLAG             Otherwise clear protection
[1971] 8C17 BD,32,E0 G8C17  DST  V@2(@STADDR),@ENLN  Copy new ENLN,
       8C1A 02,0A
[1972] 8C1C BD,30,E0        DST  V@4(@STADDR),@STLN   STLN and
       8C1F 04,0A
[1973] 8C21 BD,A3,BC        DST  V@6(@STADDR),V@OLDTOP top of memory info
       8C24 E0,06,0A
[1974] 8C27 A3,0A,00        DADD 8,@STADDR         Point to program data
       8C2A 08
[1975] 8C2B BD,A3,BE        DST  @HIVDP,V@NEWTOP   Set up the new top
       8C2E 70
[1976] 8C2F 06,8D,36        CALL RELOCA            Relocate according to @>8370
[1977] 8C32 8E,80,84 OLDZ5  CZ   @RAMTOP           ERAM present?
[1978] 8C35 6D,32           BS   LRTOPZ
[1979]               *                             No, go back to toplevel
[1980]               *                             Yes, move from VDP to ERAM
[1981]               *                             (in relocated form)
[1982]               ************ Move to the ERAM from CPUBAS first ***********
[1983] 8C37 BD,00,70        DST  @HIVDP,@VAR0
[1984] 8C3A A5,00,30        DSUB @STLN,@VAR0
[1985] 8C3D 91,00           DINC @VAR0             # of bytes to move
[1986] 8C3F BD,4E,00        DST  @VAR0,@CCC        @CCC : Byte count for VGWITE
[1987]               * RXB PATCH CODE FOR PMEMORY UPPER 24K
[1988]               *       DST  CPUBAS,@BBB       @BBB : Destination addr on E
[1989] 8C42 BD,50,A3        DST  V@PMEM,@BBB       @BBB : Destination addr on ER
       8C45 A0
[1990] 8C46 BD,0A,50        DST  @BBB,@STADDR      For later use as the base of
[1991]               *                              current program image in REL
[1992] 8C49 BD,4C,30        DST  @STLN,@AAA        @AAA : Source address on ERAM
[1993] 8C4C 0F,8A           XML  VGWITE            Move from VDP to ERAM
[1994] 8C4E BD,A3,BC        DST  @HIVDP,V@OLDTOP   Set up old memory top
       8C51 70
[1995] 8C52 BD,A3,BE        DST  @RAMTOP,V@NEWTOP  Set up new memory top
       8C55 80,84
[1996] 8C57 06,8D,36        CALL RELOCA            Relocate the program image
[1997] 8C5A BD,80,86 OLDZ7  DST  @STLN,@RAMFRE     Reset the RAMFRE on ERAM
       8C5D 30
[1998] 8C5E 93,80,86        DDEC @RAMFRE

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0035 
FLMGR-359
[1999] 8C61 4D,32           BR   LRTOPZ            Go back to toplevel
[2000]               ***********************************************************
[2001]               * At this point : if ERAM not exist - ERROR off else open
[2002]               * sequential file to load program to ERAM through VDP RAM
[2003]               ***********************************************************
[2004] 8C63 8E,80,84 OLDZ3  CZ   @RAMTOP
[2005] 8C66 6D,2D           BS   OLDER
[2006]               * Set up PAB for OPEN
[2007]               * File type : Sequential file,
[2008]               * Mode of operation : Input
[2009]               * Date type : internal
[2010]               * Record type : Variable length records
[2011]               * Logical record length : 254 maximum
[2012] 8C68 31,00,09        MOVE 9,G@PAB3,V@4(@PABPTR) Build the PAB          <<
       8C6B E0,04,04
       8C6E 8D,24
[2013] 8C70 BD,4A,70        DST  @HIVDP,@FAC       Compute the data buffer addre
[2014] 8C73 A7,4A,00        DSUB 253,@FAC
       8C76 FD
[2015] 8C77 BD,4C,4A        DST  @FAC,@AAA         Save it for later use in VGWI
[2016] 8C7A BD,E0,06        DST  @FAC,V@BUF(@PABPTR)
       8C7D 04,4A
[2017] 8C7F 06,97,6E        CALL CDSR              Call the device service routi
[2018] 8C82 57,97           BR   ERRZ2B            Return with ERROR indication
[2019]               *                              in COND
[2020]               * Start to read in file
[2021] 8C84 06,97,61        CALL IOCALL            Read in the first record
[2022] 8C87 02              BYTE CZREAD          *
[2023]               * Check the control information
[2024] 8C88 D6,E0,09        CEQ  10,V@CNT(@PABPTR) * 10 bytes contr info
       8C8B 04,0A
[2025] 8C8D 4D,2D           BR   OLDER
[2026]               * >ABCD is the flag set at SAVE time indicating a program f
[2027] 8C8F D7,B0,4A        DCEQ >ABCD,V*FAC
       8C92 AB,CD
[2028] 8C94 4D,2D           BR   OLDER
[2029] 8C96 95,4A           DINCT @FAC
[2030] 8C98 BD,30,B0        DST  V*FAC,@STLN       Copy the new STLN
       8C9B 4A
[2031] 8C9C 95,4A           DINCT @FAC
[2032] 8C9E BD,32,B0        DST  V*FAC,@ENLN       ENLN too
       8CA1 4A
[2033] 8CA2 BD,02,32        DST  @ENLN,@MNUM       Test checksum
[2034] 8CA5 B9,02,30        DXOR @STLN,@MNUM
[2035] 8CA8 95,4A           DINCT @FAC
[2036] 8CAA D5,B0,4A        DCEQ @MNUM,V*FAC       Try PROTECTION option
       8CAD 02
[2037] 8CAE 6C,BD           BS   G8CBD
[2038] 8CB0 83,02           DNEG @MNUM
[2039] 8CB2 D5,B0,4A        DCEQ @MNUM,V*FAC       No, ERROR
       8CB5 02
[2040] 8CB6 4D,2D           BR   OLDER
[2041] 8CB8 B6,45,80        OR   >80,@FLAG         Yes, set LIST/EDIT PROTECTION
[2042] 8CBB 4C,BF           BR   G8CBF
[2043] 8CBD 86,45    G8CBD  CLR  @FLAG             Otherwise clear protection fl
[2044] 8CBF 95,4A    G8CBF  DINCT @FAC
[2045]               * Check is there enough memory in ERAM
[2046] 8CC1 BD,02,B0        DST  V*FAC,@MNUM       Get the old top of memory out
       8CC4 4A
[2047] 8CC5 BD,A3,BC        DST  @MNUM,V@OLDTOP    For later use in RELOCA
       8CC8 02
[2048] 8CC9 A5,02,30        DSUB @STLN,@MNUM
[2049] 8CCC 91,02           DINC @MNUM             Total # of bytes in program
[2050] 8CCE BD,08,02        DST  @MNUM,@CCC1       For later use as the byte cou

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0036 
FLMGR-359
[2051]               * RXB PATCH CODE FOR PMEMORY UPPER 24K
[2052]               *       DADD CPUBAS,@MNUM      Add the total # of bytes to 
[2053] 8CD1 A1,02,A3        DADD V@PMEM,@MNUM  Add the total # of bytes to CPUBA
       8CD4 A0
[2054]               * Check if enough memory in ERAM
[2055] 8CD5 0A              GT                     Greater than >FFFF case
[2056] 8CD6 6D,2D           BS   OLDER
[2057] 8CD8 C5,02,80        DCH  @RAMTOP,@MNUM     Greater than >DFFF case
       8CDB 84
[2058] 8CDC 6D,2D           BS   OLDER
[2059]               * Move to ERAM starting from CPUBAS first,
[2060]               * then relocate according the new top of memory in ERAM
[2061]               * RXB PATCH CODE FOR PMEMORY UPPER 24K
[2062]               * OLZZ   DST  CPUBAS,@BBB       @BBB : Destination addr in
[2063] 8CDE BD,50,A3 OLDZZ  DST  V@PMEM,@BBB       @BBB : Destination addr in
       8CE1 A0
[2064]               *                                    ERAM FOR VGWITE
[2065] 8CE2 BD,0A,50        DST  @BBB,@STADDR      For later use as base of the
[2066]               *                      current program image in ERAM RELOCA
[2067]               *      DST  HIVDP,@AAA        @AAA has been set up before
[2068]               *      DSUB 253,@AAA          For copy start on VDP RAM
[2069]               * @CCC1 : Total # of bytes to move to ERAM, set up above
[2070] 8CE5 06,97,61        CALL IOCALL            Read in the second record
[2071] 8CE8 02              BYTE CZREAD
[2072]               * Read in the file and each record
[2073]               * Should be a full (maximum length 254) record at this time
[2074]               * because program supposed to be bigger than 13.5K
[2075] 8CE9 D6,E0,09 G8CE9  CEQ  254,V@CNT(@PABPTR)
       8CEC 04,FE
[2076] 8CEE 4D,2D           BR   OLDER
[2077] 8CF0 BF,4E,00        DST  254,@CCC          @CCC : # of bytes to move
       8CF3 FE
[2078] 8CF4 0F,8A           XML  VGWITE            Move data from VDP to ERAM
[2079] 8CF6 A3,50,00        DADD 254,@BBB          Update the destination addres
       8CF9 FE
[2080]               *                              on ERAM
[2081] 8CFA A7,08,00        DSUB 254,@CCC1         # of bytes left to move
       8CFD FE
[2082] 8CFE 6D,16           BS   OLDZ9             No more bytes to move
[2083] 8D00 06,97,61        CALL IOCALL            Read in the file and each rec
[2084] 8D03 02              BYTE CZREAD          * Copied into ERAM as it is rea
[2085] 8D04 CB,08,00        DCHE 254,@CCC1         Leave the last record alone
       8D07 FE
[2086] 8D08 6C,E9           BS   G8CE9
[2087]               * The record length should be the same as the # of bytes le
[2088]               * to move at this time
[2089] 8D0A D4,E0,09        CEQ  @CCC1+1,V@CNT(@PABPTR)
       8D0D 04,09
[2090] 8D0F 4D,2D           BR   OLDER
[2091] 8D11 BD,4E,08        DST  @CCC1,@CCC        Set up byte count for the las
[2092] 8D14 0F,8A           XML  VGWITE            Move data from VDP to ERAM
[2093] 8D16 06,97,61 OLDZ9  CALL IOCALL            Close the file
[2094] 8D19 01              BYTE CZCLOS
[2095] 8D1A BD,A3,BE        DST  @RAMTOP,V@NEWTOP  New top of memory
       8D1D 80,84
[2096]               * V@OLDTOP : old top of memory, set up above
[2097]               * @STADDR  : base of current program image in ERAM, set abo
[2098] 8D1F 06,8D,36        CALL RELOCA            Relocate the program
[2099] 8D22 4C,5A           BR   OLDZ7             Go to set the RAMFRE and back
[2100]               *                              toplevel
[2101] 8D24 00,1C,00 PAB3   BYTE >00,>1C,>00,>00,>FE,>00,>00,>00,OFFSET * IV254
       8D27 00,FE,00
       8D2A 00,00,60
[2102]               * OLD error exit code, don't kill machine

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0037 
FLMGR-359
[2103] 8D2D 06,60,14 OLDER  CALL INITPG            Initialize program space
[2104] 8D30 57,9A           BR   ERRZ2             And take error exit
[2105] 8D32 06,60,22 LRTOPZ CALL KILSYM            Release string space/symbol t
[2106] 8D35 00              RTN
[2107]               ***********************************************************
[2108]               * RELOCATE THE PROGRAM IMAGE ACCORDING TO THE NEW TOP OF
[2109]               * MEMORY:
[2110]               *         STLN         : old STLN
[2111]               *         ENLN         : old ENLN
[2112]               *         V@OLDTOP     : old top of memory
[2113]               *         V@NEWTOP     : new top of memory
[2114]               *         @STADDR      : current base for the old image
[2115]               ***********************************************************
[2116] 8D36 BD,A3,B4 RELOCA DST  @PABPTR,V@SIZCCP  Save in temp.
       8D39 04
[2117] 8D3A BD,02,A3        DST  V@OLDTOP,@MNUM    Get the old top of memory
       8D3D BC
[2118] 8D3E BD,04,A3        DST  V@NEWTOP,@PABPTR  Get the new top of memory
       8D41 BE
[2119] 8D42 A5,32,02        DSUB @MNUM,@ENLN       Compute ENLN relative to top
[2120] 8D45 A5,30,02        DSUB @MNUM,@STLN       Compute STLN relative to top
[2121] 8D48 A5,0A,30        DSUB @STLN,@STADDR     Highest memory address used
[2122] 8D4B 87,02           DCLR @MNUM             Total # of bytes to be moved
[2123] 8D4D A5,02,30        DSUB @STLN,@MNUM       STLN = -(# bytes -1)
[2124] 8D50 91,02           DINC @MNUM             Take care of that one
[2125] 8D52 A1,32,04        DADD @PABPTR,@ENLN     Compute new address of ENLN
[2126] 8D55 A1,30,04        DADD @PABPTR,@STLN      and STLN
[2127]               * @PABPTR : destination address, @STADDR : source address
[2128] 8D58 BD,5C,02        DST  @MNUM,@ARG        @ARG   : byte count
[2129] 8D5B BD,00,0A        DST  @STADDR,@VAR0     @VAR0  : source addr for MVDN
[2130] 8D5E BD,10,06        DST  @CCPPTR,@VAR5     Save in temp (CCPPTR, VARY2 E
[2131] 8D61 BD,06,04        DST  @PABPTR,@VARY2    @VARY2 : destination addr for
[2132] 8D64 D5,A3,BE        DCEQ @RAMTOP,V@NEWTOP  Relocate the program
       8D67 80,84
[2133] 8D69 4D,6F           BR   G8D6F              in ERAM
[2134] 8D6B 0F,88           XML  MVDN              Move from lower memory to hig
[2135]               *                              memory one byte at a time
[2136] 8D6D 4D,7E           BR   G8D7E
[2137] 8D6F 87,A3,B6 G8D6F  DCLR V@SIZREC          Clear a temporary variable
[2138] 8D72 C1,A3,B6        DEX  @RAMTOP,V@SIZREC  Save the RAMTOP, also fake as
       8D75 80,84
[2139]               *                         if ERAM not exist for MVDN in thi
[2140] 8D77 0F,88           XML  MVDN              Move in VDP
[2141] 8D79 C1,A3,B6        DEX  @RAMTOP,V@SIZREC  Restore RAMTOP
       8D7C 80,84
[2142] 8D7E BD,06,10 G8D7E  DST  @VAR5,@CCPPTR     Restore back
[2143]               * Update line # links according to new size
[2144] 8D81 BD,02,A3        DST  V@OLDTOP,@MNUM    Old memory top
       8D84 BC
[2145] 8D85 A5,02,A3        DSUB V@NEWTOP,@MNUM    Stop if sizes are same
       8D88 BE
[2146] 8D89 6D,B3           BS   RELOZ1
[2147] 8D8B BD,0A,30        DST  @STLN,@STADDR     Start relocation at STLN
[2148] 8D8E C9,32,0A OLDZ2  DCHE @STADDR,@ENLN      and continue up to ENLN
[2149] 8D91 4D,B3           BR   RELOZ1
[2150] 8D93 95,0A           DINCT @STADDR          Skip the line #
[2151] 8D95 D4,A3,BE        CEQ  @RAMTOP,V@NEWTOP  If in ERAM
       8D98 80,84
[2152] 8D9A 4D,AB           BR   G8DAB
[2153] 8D9C 06,91,A7        CALL GRSUB2            Read the link out
[2154] 8D9F 0A              BYTE STADDR
[2155] 8DA0 A5,58,02        DSUB @MNUM,@EEE1       Update
[2156] 8DA3 06,60,36        CALL GWSUB             Write it back
[2157] 8DA6 0A,58,02        BYTE >0A,>58,>02     * STADDR,EEE1,2

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0038 
FLMGR-359
[2158] 8DA9 4D,AF           BR   G8DAF
[2159] 8DAB A5,B0,0A G8DAB  DSUB @MNUM,V*STADDR    Upadate the link
       8DAE 02
[2160] 8DAF 95,0A    G8DAF  DINCT @STADDR          Skip the link, next line #
[2161] 8DB1 4D,8E           BR   OLDZ2             And continue until done
[2162] 8DB3 BD,04,A3 RELOZ1 DST  V@SIZCCP,@PABPTR  Restore from temp
       8DB6 B4
[2163] 8DB7 00              RTN
[2164]               ***********************************************************
[2165]               *                    SAVE STATEMENT
[2166]               * SAVE "NAME", MERGE : Save in crunched form in program
[2167]               *  into a file one line at at time with the line number.
[2168]               *  File opened with sequential accessed, variable-length
[2169]               *  records (161 max), display type & output mode, move one
[2170]               *  line number and one in text to the crunch buffer then
[2171]               *  write to the file one line at a time.
[2172]               * A normal SAVE : When ERAM not exist or the size of the
[2173]               *  program and line number table in ERAM can fit in VDP
[2174]               *  (can be moved into VDP from ERAM once), then the save
[2175]               *  statement saves a program image to an external device,
[2176]               *  including all the information the system needs for
[2177]               *  rebuilding the program image on a machine with a
[2178]               *  different memory size, also included is a checksum for
[2179]               *  rudimentary error checking and for PROTECTION VIOLATION
[2180]               * A sequential SAVE : Maximum-length records are performed
[2181]               *  to write the file and each record is copied into the VDP
[2182]               *  from ERAM before it is written.
[2183]               ***********************************************************
[2184] 8DB8 DA,45,80 SAVE   CLOG >80,@FLAG         * PROTECTION VIOLATION
[2185] 8DBB 57,DE           BR   ERRPV
[2186] 8DBD 06,92,38        CALL GPNAME            This will also close all file
[2187]               * Check SAVE "NAME", MERGE or SAVE "NAME", PROTECTED first
[2188] 8DC0 86,A3,B9        CLR  V@SAPROT          Clear "PROTECTED" flag
[2189] 8DC3 0F,79           XML  PGMCHR
[2190] 8DC5 8E,42           CZ   @CHAT             EOL?
[2191] 8DC7 6E,2B           BS   SAZ1              Yes, no need to check any opt
[2192] 8DC9 D6,42,B3        CEQ  COMMAZ,@CHAT      Has to be a comma here
[2193] 8DCC 41,09           BR   ERRSYN
[2194] 8DCE D7,B0,2C        DCEQ >C805,V*PGMPTR    Unquoted string with length 5
       8DD1 C8,05
[2195]               *                              has to be MERGE at this time
[2196] 8DD3 4D,F4           BR   G8DF4
[2197] 8DD5 D7,E0,02        DCEQ >4D45,V@2(@PGMPTR) "ME" of MErge
       8DD8 2C,4D,45
[2198]               * RXB PATCH CODE OPTION ADDED IV254 FOR SAVE 2015 *********
[2199]               * SAVE "DSK#.FILENAME",MERGE ! SAVE MERGE FORMAT
[2200]               * SAVE "DSK#.FILENAME",IV254 ! SAVE IV254 PROGRAM FORMAT
[2201]               * SAVE "DSK#.FILENAME" ! NORMAL PROGRAM FORMAT OR IV254
[2202]               *       BR   ERRSYN             If not : SYNTAX ERROR
[2203] 8DDB 58,03           BR    CIV254            CHECK FOR IV254 OPTION
[2204] 8DDD D7,E0,04        DCEQ >5247,V@4(@PGMPTR) "RG" of meRGe
       8DE0 2C,52,47
[2205] 8DE3 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2206] 8DE5 D6,E0,06        CEQ  >45,V@6(@PGMPTR)   "E" of mergE
       8DE8 2C,45
[2207] 8DEA 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2208] 8DEC 8E,E0,07        CZ   V@7(@PGMPTR)      Check for EOL
       8DEF 2C
[2209] 8DF0 41,09           BR   ERRSYN            Not EOL : SYNTAX ERROR
[2210] 8DF2 4F,79           BR   SAVMG             Go to handle this option
[2211]               * Has to be PROTECTED option here, crunched as unquoted str
[2212] 8DF4 D7,B0,2C G8DF4  DCEQ >C809,V*PGMPTR    Unquoted string with length 9
       8DF7 C8,09
[2213]               *                              has to be PROTECTED

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0039 
FLMGR-359
[2214] 8DF9 41,09           BR   ERRSYN
[2215] 8DFB D7,E0,02        DCEQ >5052,V@2(@PGMPTR) "PR" of PRotected
       8DFE 2C,50,52
[2216] 8E01 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2217] 8E03 D7,E0,04        DCEQ >4F54,V@4(@PGMPTR) "OT" of prOTected
       8E06 2C,4F,54
[2218] 8E09 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2219] 8E0B D7,E0,06        DCEQ >4543,V@6(@PGMPTR) "EC" of protECted
       8E0E 2C,45,43
[2220] 8E11 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2221] 8E13 D7,E0,08        DCEQ >5445,V@8(@PGMPTR) "TE",of protecTEd
       8E16 2C,54,45
[2222] 8E19 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2223] 8E1B D6,E0,0A        CEQ  >44,V@10(@PGMPTR)  "D" of protecteD
       8E1E 2C,44
[2224] 8E20 41,09           BR   ERRSYN             If not : SYNTAX ERROR
[2225] 8E22 8E,E0,0B        CZ   V@11(@PGMPTR)     Check EOL
       8E25 2C
[2226] 8E26 41,09           BR   ERRSYN
[2227] 8E28 90,A3,B9        INC  V@SAPROT
[2228]               ***********************************************************
[2229] 8E2B 8E,80,84 SAZ1   CZ   @RAMTOP           If ERAM NOT present then
[2230] 8E2E 4E,42           BR   G8E42
[2231]               ***** CLEAR THE BREAKPOINT IN VDP ALONE TO SPEED UP *******
[2232] 8E30 BD,52,30        DST  @STLN,@FAC8       End of line # buffer
[2233] 8E33 B2,B0,52 G8E33  AND  >7F,V*FAC8        Clear the breakpoint
       8E36 7F
[2234] 8E37 A3,52,00        DADD 4,@FAC8           Move to the next one
       8E3A 04
[2235] 8E3B C5,52,32        DCH  @ENLN,@FAC8       Until done
[2236] 8E3E 4E,33           BR   G8E33
[2237] 8E40 4E,6C           BR   VSAVZ
[2238] 8E42 06,A0,20 G8E42  CALL UBSUB             Clear the breakpoint in ERAM
[2239] 8E45 BD,02,80        DST  @RAMTOP,@MNUM     Top of memory in ERAM
       8E48 84
[2240] 8E49 A5,02,30        DSUB @STLN,@MNUM
[2241] 8E4C 91,02           DINC @MNUM             # of bytes total in ERAM
[2242] 8E4E BD,00,70        DST  @HIVDP,@VAR0      Top of memory in VDP
[2243] 8E51 A5,00,02        DSUB @MNUM,@VAR0
[2244] 8E54 91,00           DINC @VAR0
[2245]               * Check is there enough memory in VDP to move the program
[2246]               *  text and line number table from ERAM to VDP
[2247] 8E56 0A              GT                  Not enough memory in VDP for sur
[2248] 8E57 4E,BA           BR   GSAVE
[2249]               * RXB PATCH CODE FOR VDPSTACK
[2250]               *       DST  VRAMVS+64+256,@VAR5 * 64 bytes are for safety 
[2251] 8E59 BD,10,6E        DST  @>836E,@VAR5
[2252] 8E5C A3,10,01        DADD 64+256,@VAR5
       8E5F 40
[2253]               * DSR routine give file error when loading a program which
[2254]               *  VDP maximum size and was saved from VDP to be a program
[2255]               *  on disk when ERAM not exist. In order to fix this proble
[2256]               *  restrict the program memory to be 256 bytes less then th
[2257]               *  real space in VDP when ERAM not exist.
[2258] 8E60 C9,00,10        DCHE @VAR5,@VAR0       Not enough memory in VDP, do
[2259]               *                              sequential file save
[2260] 8E63 4E,BA           BR   GSAVE
[2261] 8E65 A7,10,00        DSUB 10,@VAR5        * 10 bytes for control informat
       8E68 0A
[2262] 8E69 06,8F,4D        CALL GVMOV             Enough memory in VDP, move it
[2263]               *                             over and do the normal save l
[2264]               **************** Without ERAM, or after GVMOV *************
[2265]               **************** do the normal save           *************
[2266] 8E6C BD,0A,40 VSAVZ  DST  @FREPTR,@STADDR   Store additional control info

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0040 
FLMGR-359
[2267] 8E6F 93,0A           DDEC @STADDR           Back up some more for 2 byte
[2268] 8E71 BD,B0,0A        DST  @>8370,V*STADDR   First current top of memory
       8E74 70
[2269] 8E75 97,0A           DDECT @STADDR
[2270] 8E77 BD,B0,0A        DST  @STLN,V*STADDR    Then STLN
       8E7A 30
[2271] 8E7B 97,0A           DDECT @STADDR
[2272] 8E7D BD,B0,0A        DST  @ENLN,V*STADDR    Then ENLN
       8E80 32
[2273] 8E81 97,0A           DDECT @STADDR          Then
[2274] 8E83 BD,B0,0A        DST  @STLN,V*STADDR
       8E86 30
[2275] 8E87 B9,B0,0A        DXOR @ENLN,V*STADDR    STLN XORed with ENLN
       8E8A 32
[2276] 8E8B D6,A3,B9        CEQ  1,V@SAPROT        Check is there PROTECTED opti
       8E8E 01
[2277] 8E8F 4E,94           BR   G8E91
[2278] 8E91 83,B0,0A        DNEG V*STADDR          Negate the CHECKSUM to indica
[2279]               *                             LIST/EDIT protection
[2280] 8E94 BD,E0,06 G8E91  DST  @STADDR,V@BUF(@PABPTR)  Save start address in P
       8E97 04,0A
[2281] 8E99 93,0A           DDEC @STADDR
[2282] 8E9B BD,E0,0A        DST  @>8370,V@RNM(@PABPTR)   Compute # of bytes used
       8E9E 04,70
[2283] 8EA0 A5,E0,0A        DSUB @STADDR,V@RNM(@PABPTR)   and store that in PAB
       8EA3 04,0A
[2284] 8EA5 8E,80,84        CZ   @RAMTOP           If ERAM exists then
[2285] 8EA8 6E,B0           BS   G8EAD
[2286] 8EAA BD,30,0C        DST  @BBB1,@STLN       Restore the original STLN, EN
[2287] 8EAD BD,32,08        DST  @CCC1,@ENLN        which points to ERAM
[2288] 8EB0 06,97,61 G8EAD  CALL IOCALL            Call Device Service Routine f
[2289] 8EB3 06              BYTE CZSAVE          * SAVE operation
[2290] 8EB4 06,60,22 LRTOPL CALL KILSYM            Release string space/symbol t
[2291] 8EB7 05,60,12        B    TOPL15            Go back to toplevel
[2292]               ***********************************************************
[2293]               * Open the sequential file, set the PAB
[2294]               * File type             : sequential file
[2295]               * Mode of operation     : output
[2296]               * Data type             : internal
[2297]               * Record type           : variable length records
[2298]               * Logical record length : 254 maximum
[2299] 8EBA 31,00,09 GSAVE  MOVE 9,G@PAB3,V@4(@PABPTR) Build the PAB
       8EBD E0,04,04
       8EC0 8D,24
[2300] 8EC2 96,E0,05        DECT V@FLG(@PABPTR)    Put in the correct I/O mode :
       8EC5 04
[2301]               * Compute the data buffer address
[2302] 8EC6 BD,4A,70        DST  @>8370,@FAC
[2303] 8EC9 A7,4A,00        DSUB 253,@FAC
       8ECC FD
[2304] 8ECD BD,E0,06        DST  @FAC,V@BUF(@PABPTR)
       8ED0 04,4A
[2305] 8ED2 BD,58,4A        DST  @FAC,@EEE1     Save it for later use in GVWITE
[2306] 8ED5 06,97,6E        CALL CDSR           Call device service routine to o
[2307] 8ED8 57,97           BR   ERRZ2B         Return with ERROR indication in
[2308]               *                          Put 8 bytes control info at the
[2309]               *                          beginning of the data buffer
[2310] 8EDA BF,B0,4A        DST  >ABCD,V*FAC       >ABCD indentifies a program f
       8EDD AB,CD
[2311] 8EDF 95,4A           DINCT @FAC              when doing LOAD later
[2312] 8EE1 BD,B0,4A        DST  @STLN,V*FAC       Save STLN in control info
       8EE4 30
[2313] 8EE5 95,4A           DINCT @FAC
[2314] 8EE7 BD,B0,4A        DST  @ENLN,V*FAC       ENLN too

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0041 
FLMGR-359
       8EEA 32
[2315] 8EEB 95,4A           DINCT @FAC
[2316] 8EED BD,B0,4A        DST  @STLN,V*FAC
       8EF0 30
[2317] 8EF1 B9,B0,4A        DXOR @ENLN,V*FAC       Save the checksum
       8EF4 32
[2318] 8EF5 D6,A3,B9        CEQ  1,V@SAPROT        Check is there PROTECTED opti
       8EF8 01
[2319] 8EF9 4E,FE           BR   G8EFB
[2320] 8EFB 83,B0,4A        DNEG V*FAC             Negate the CHECKSUM to indica
[2321]               *                              the LIST/EDIT protection
[2322] 8EFE 95,4A    G8EFB  DINCT @FAC
[2323] 8F00 BD,B0,4A        DST  @RAMTOP,V*FAC     Save the top of memory info
       8F03 80,84
[2324] 8F05 BE,E0,09        ST   10,V@CNT(@PABPTR) Set the caracter count in PAB
       8F08 04,0A
[2325] 8F0A 06,97,61        CALL IOCALL            Call device service routine
[2326] 8F0D 03              BYTE CZWRIT          * With I/O opcode : write, to s
[2327]               *                       the control info for the first reco
[2328]               * Now start to use maximum-length record to write the file
[2329]               * and each record is copied into the VDP from ERAM bofore i
[2330]               * is written
[2331] 8F0E BD,54,30        DST  @STLN,@DDD1       Starting address on ERAM
[2332]               *      DST  @>8370,@EEE1      @EEE1 has been set up before
[2333]               *      DST  253,@EEE1         Starting address of the data
[2334]               *                              buffer on VDP
[2335] 8F11 BD,08,80        DST  @RAMTOP,@CCC1
       8F14 84
[2336] 8F15 A5,08,30        DSUB @STLN,@CCC1
[2337] 8F18 91,08           DINC @CCC1
[2338] 8F1A BE,E0,09        ST   254,V@CNT(@PABPTR) Set the character count of P
       8F1D 04,FE
[2339] 8F1F BF,56,00 G8F1C  DST  254,@FFF1         @FFF1 byte count
       8F22 FE
[2340] 8F23 0F,8B           XML  GVWITE            Move data from ERAM to VDP
[2341] 8F25 06,97,61        CALL IOCALL            Call device service routine
[2342] 8F28 03              BYTE CZWRIT
[2343] 8F29 A3,54,00        DADD 254,@DDD1         Update the source addr on ERA
       8F2C FE
[2344] 8F2D A7,08,00        DSUB 254,@CCC1         # of bytes left to move
       8F30 FE
[2345] 8F31 6F,47           BS   GSAV1             No more bytes to save
[2346] 8F33 CB,08,00        DCHE 254,@CCC1         Leave the last record alone
       8F36 FE
[2347] 8F37 6F,1F           BS   G8F1C
[2348]               * Move the last @CCC1 bytes from ERAM to VDP
[2349] 8F39 BD,56,08        DST  @CCC1,@FFF1       @FFF1 : Byte count
[2350] 8F3C 0F,8B           XML  GVWITE            Write data from ERAM to VDP
[2351] 8F3E BC,E0,09        ST   @CCC1+1,V@CNT(@PABPTR) Update the character cou
       8F41 04,09
[2352]               *                                   in PAB
[2353] 8F43 06,97,61        CALL IOCALL            Call device service routine
[2354] 8F46 03              BYTE CZWRIT
[2355] 8F47 06,97,61 GSAV1  CALL IOCALL
[2356] 8F4A 01              BYTE CZCLOS          * Close the file
[2357] 8F4B 4E,B4           BR   LRTOPL            Continue
[2358]               ***********************************************************
[2359]               * Move the program text & line # table to VDP, and relocate
[2360] 8F4D BD,0C,30 GVMOV  DST  @STLN,@BBB1       Save STLN, ENLN for later use
[2361] 8F50 BD,08,32        DST  @ENLN,@CCC1
[2362] 8F53 BD,54,30        DST  @STLN,@DDD1       Source addr on ERAM
[2363] 8F56 BD,58,10        DST  @VAR5,@EEE1       Destination addr on VDP
[2364] 8F59 BD,0A,58        DST  @EEE1,@STADDR     Use later for RELOCA
[2365] 8F5C BD,56,80        DST  @RAMTOP,@FFF1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0042 
FLMGR-359
       8F5F 84
[2366] 8F60 A5,56,30        DSUB @STLN,@FFF1       # of bytes to move
[2367] 8F63 91,56           DINC @FFF1             @FFF1 : byte count for GVWITE
[2368] 8F65 0F,8B           XML  GVWITE            Move from ERAM to VDP
[2369] 8F67 BD,A3,BC        DST  @RAMTOP,V@OLDTOP  Set up @RAMTOP for old top
       8F6A 80,84
[2370]               *                             of memory
[2371] 8F6C BD,A3,BE        DST  @>8370,V@NEWTOP   Set up @>8370 for new top
       8F6F 70
[2372]               *                             of memory
[2373] 8F70 06,8D,36        CALL RELOCA            Relocate the program
[2374] 8F73 BD,40,30        DST  @STLN,@FREPTR     Set up @FREPTR
[2375] 8F76 93,40           DDEC @FREPTR
[2376] 8F78 00              RTN
[2377]               ***********************************************************
[2378]               * Save the crunched form of a program into a file.
[2379]               * Move the line number and text to the crunch buffer, then
[2380]               * write to the file one line at a time.
[2381]               ***********************************************************
[2382]               * Open the file with:
[2383]               *  I/O opcode            : OPEN
[2384]               *  File type             : SEQUENTIAL file
[2385]               *  Mode of operation     : OUTPUT
[2386]               *  Data type             : DISPLAY type data
[2387]               *  Record type           : VARIABLE LENGTH records
[2388]               *  Data buffer address   : Crunch buffer address
[2389]               *  Logical record length : 163 (length of curnch buffer + 2
[2390]               *                                bytes for line #) maximum
[2391] 8F79 31,00,09 SAVMG  MOVE 9,G@PAB1,V@4(@PABPTR) Build PAB
       8F7C E0,04,04
       8F7F 8F,FC
[2392] 8F81 06,97,68        CALL IOCLZ1         Call the DSR routine to open fil
[2393] 8F84 BD,50,32        DST  @ENLN,@FAC6    Start from the first line #
[2394] 8F87 A7,50,00        DSUB 3,@FAC6        @FAC6 now points to the 1st line
       8F8A 03
[2395]               *                          Write to the file from crunch bu
[2396]               *                           one line at a time
[2397] 8F8B 86,00    G8F88  CLR  @VAR0             Make it a two byte later
[2398] 8F8D 8E,80,84        CZ   @RAMTOP           If ERAM exists then
[2399] 8F90 6F,B9           BS   G8FB6
[2400] 8F92 BD,54,50        DST  @FAC6,@DDD1       Write the 4 bytes (line # and
[2401]               *                              line pointer) from ERAM to
[2402]               *                              crunch buffer
[2403]               *                             @DDD1 : Source address on ERA
[2404] 8F95 BF,58,08        DST  CRNBUF,@EEE1      @EEE1 : Destination address
       8F98 20
[2405]               *                                      on VDP
[2406] 8F99 BF,56,00        DST  4,@FFF1           @FFF1 : byte count
       8F9C 04
[2407] 8F9D 0F,8B           XML  GVWITE            Write data from ERAM to VDP
[2408] 8F9F BD,54,A8        DST  V@CRNBUF+2,@DDD1  Line pointer now points to
       8FA2 22
[2409]               *                              length byte
[2410] 8FA3 93,54           DDEC @DDD1             Get the length of this line
[2411]               *                             @DDD1 : Source address on ERA
[2412] 8FA5 91,56           DINC @FFF1             @FFF1 : Byte count, coming ba
[2413]               *                                     from GVWITE above, =0
[2414] 8FA7 0F,8C           XML  GREAD1            Read the length byte from ERA
[2415] 8FA9 BC,01,58        ST   @EEE1,@VAR0+1     @EEE1 : Destination addr on C
[2416] 8FAC BF,58,08        DST  CRNBUF+2,@EEE1    Write the text from ERAM to 3
       8FAF 22
[2417]               *                             byte of crunch buffer
[2418]               *                             @EEE1 : Destination addr on V
[2419]               *                             @DDD1 : Source addr on ERAM

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0043 
FLMGR-359
[2420] 8FB0 91,54           DINC @DDD1             Back to point to the text
[2421] 8FB2 BD,56,00        DST  @VAR0,@FFF1       @FFF1 : Byte count
[2422] 8FB5 0F,8B           XML  GVWITE            Write data from ERAM to VDP
[2423] 8FB7 4F,D0           BR   G8FCD             ERAM not exist : line # table
[2424]               *                              and text in VDP
[2425] 8FB9 BD,A8,20 G8FB6  DST  V*FAC6,V@CRNBUF   PUT THE LINE # IN
       8FBC B0,50
[2426] 8FBE BD,4C,E0        DST  V@2(@FAC6),@FAC2  Get the line pointer out
       8FC1 02,50
[2427] 8FC3 93,4C           DDEC @FAC2             Line pointer now points to th
[2428]               *                              length byte
[2429] 8FC5 BC,01,B0        ST   V*FAC2,@VAR0+1    Get the length out
       8FC8 4C
[2430]               * Move the text into the crunch buffer
[2431] 8FC9 34,00,A8        MOVE @VAR0,V@1(@FAC2),V@CRNBUF+2
       8FCC 22,E0,01
       8FCF 4C
[2432] 8FD0 B2,A8,20 G8FCD  AND  >7F,V@CRNBUF      Reset possible breakpoint
       8FD3 7F
[2433] 8FD4 95,00           DINCT @VAR0    * Total length=text length+line # len
[2434] 8FD6 BC,E0,09        ST   @VAR0+1,V@CNT(@PABPTR) Store in the cahracter c
       8FD9 04,01
[2435] 8FDB 06,97,61        CALL IOCALL            Call the device service routi
[2436] 8FDE 03              BYTE CZWRIT          * Write
[2437] 8FDF A7,50,00        DSUB 4,@FAC6           Go to the next line #
       8FE2 04
[2438] 8FE3 C9,50,30        DCHE @STLN,@FAC6       Finish moving all
[2439] 8FE6 6F,8B           BS   G8F88
[2440] 8FE8 BF,A8,20        DST  >FFFF,V@CRNBUF    Set up a EOF for the last rec
       8FEB FF,FF
[2441] 8FED BE,E0,09        ST   2,V@CNT(@PABPTR)  Only write this 2 bytes
       8FF0 04,02
[2442] 8FF2 06,97,61        CALL IOCALL            Call the device service routi
[2443] 8FF5 03              BYTE CZWRIT          * Write
[2444] 8FF6 06,97,61        CALL IOCALL            Call the device service routi
[2445] 8FF9 01              BYTE CZCLOS          * Close the file
[2446] 8FFA 4E,B4           BR   LRTOPL            Go back to top level
[2447] 8FFC 00,12,08 PAB1   BYTE >00,>12,>08,>20,>A3,>00,>00,>00,>60 * DV163
       8FFF 20,A3,00
       9002 00,00,60
[2448]               *           >0820 = CRNBUF
[2449]               *           >A3   = 163
[2450]               *           >60   = OFFSET
[2451]               ***********************************************************
[2452]               *                   MERGE ROUTINE
[2453]               * MERGE load a file which is in crunched program form into
[2454]               * the CRNBUF one record (one in) at a time then take the
[2455]               * line # out in FAC, text length into @CHAT, and edit it
[2456]               * into the program. Identify EOF by the last record which
[2457]               * is set up at SAVE time.
[2458]               ***********************************************************
[2459] 9005 06,92,38 MERGE  CALL GPNAME            Close all file, set up PAB
[2460] 9008 DA,45,80        CLOG >80,@FLAG         Check PROTECTION VIOLATION
[2461] 900B 57,DE           BR   ERRPV
[2462]               * To fix the bug #06 in MERGE
[2463] 900D 0F,79           XML  PGMCHR            Check EOL
[2464] 900F 8E,42           CZ   @CHAT
[2465] 9011 41,09           BR   ERRSYN            Not EOL : SYNTAX ERROR
[2466]               * Open the file with
[2467]               *  I/O opcode            : OPEN
[2468]               *  File type             : SEQUENTIAL file
[2469]               *  Mode of operation     : INPUT
[2470]               *  Data type             : DISPLAY type data
[2471]               *  Record type           : VARIABLE LENGTH records

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0044 
FLMGR-359
[2472]               *  Data buffer address   : crunch address
[2473]               *  Logical record length : 163 maximum
[2474] 9013 31,00,09        MOVE 9,G@PAB1,V@4(@PABPTR)  Set up PAB
       9016 E0,04,04
       9019 8F,FC
[2475] 901B 94,E0,05        INCT V@FLG(@PABPTR)    Put in correct I/O mode : >14
       901E 04
[2476] 901F 06,97,68        CALL IOCLZ1            Call the device service routi
[2477]               *                              to open the file
[2478] 9022 06,97,61        CALL IOCALL            Call the device service routi
[2479] 9025 02              BYTE CZREAD          *  to read
[2480] 9026 D7,A8,20        DCEQ >FFFF,V@CRNBUF    If 1st rec is EOF
       9029 FF,FF
[2481] 902B 77,97           BS   ERRZ2B
[2482] 902D 87,80,D6 G902A  DCLR @>83D6            Read in one line and edit it
[2483]               *                              program
[2484] 9030 BC,42,E0        ST   V@CNT(@PABPTR),@CHAT Length of this record
       9033 09,04
[2485] 9035 96,42           DECT @CHAT             Text length = total length-2
[2486]               *                                          (line # length)
[2487]               *                              Put it in @CHAT for EDITLN
[2488] 9037 BD,4A,A8        DST  V@CRNBUF,@FAC     Put the line # in @FAC for ED
       903A 20
[2489] 903B 86,56           CLR  @FAC12            Make it a double byte
[2490] 903D BC,57,42        ST   @CHAT,@FAC13
[2491]               * Move the text up 2 bytes
[2492] 9040 34,56,A8        MOVE @FAC12,V@CRNBUF+2,V@CRNBUF
       9043 20,A8,22
[2493] 9046 BD,A3,9E        DST  @PABPTR,V@MRGPAB  SAVE PAB POINTER
       9049 04
[2494] 904A 06,60,32        CALL EDITLN            EDIT IT TO THE PROGRAM
[2495] 904D 87,04           DCLR @PABPTR           Clear temporary PAB pointer
[2496] 904F C1,04,A3        DEX  V@MRGPAB,@PABPTR  Restore old PAB pointer
       9052 9E
[2497] 9053 06,97,61        CALL IOCALL            CALL THE DEVICE SERVICE ROUTI
[2498] 9056 02              BYTE CZREAD          *  read another record or anoth
[2499]               *                              line
[2500] 9057 D7,A8,20        DCEQ >FFFF,V@CRNBUF    End of EOF
       905A FF,FF
[2501] 905C 50,2D           BR   G902A
[2502]               * Double check EOF record
[2503] 905E D6,E0,09 MERGZ1 CEQ  2,V@CNT(@PABPTR)  I/O ERROR
       9061 04,02
[2504] 9063 57,97           BR   ERRZ2B
[2505] 9065 06,97,61        CALL IOCALL            Call the device service routi
[2506] 9068 01              BYTE CZCLOS          *  close the file
[2507] 9069 4E,B4           BR   LRTOPL            Go back to top level
[2508]               ***********************************************************
[2509]               *                  LIST ROUTINE
[2510]               * List lists a readable copy of the current program imnage
[2511]               * to the specified device. In case no device is specified,
[2512]               * the listing is copied to the screen.
[2513]               *  This routine uses the fact that ERRZZ returns to the
[2514]               * caller if the call has been issued in EDIT which will
[2515]               * reinitiate the variable stuff.
[2516]               ***********************************************************
[2517] 906B DA,45,80 LIST   CLOG >80,@FLAG         PROTECTION VILOATION ERROR  <
[2518] 906E 57,DE           BR   ERRPV                                         <
[2519] 9070 87,14           DCLR @CURLIN           Create some kind of control <
[2520] 9072 87,0E           DCLR @CURINC            for defaults               <
[2521] 9074 BE,08,2D        ST   MINUS,@VARC       Select "-" as separator     <
[2522]               * GKXB GKLIST label
[2523] 9077 06,7A,06        CALL GTLIST            GKXB pick up length
[2524]               * If either CURLIN or CURINC is non-zero, use it

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0045 
FLMGR-359
[2525]               * For zero values replace the default (ENLN-3, STLN)
[2526] 907A 8F,14           DCZ  @CURLIN
[2527] 907C 50,97           BR   G9094
[2528] 907E BD,54,32        DST  @ENLN,@DDD1       Get the first lines line #
[2529] 9081 A7,54,00        DSUB 3,@DDD1           DDD1 : Source address on ERAM
       9084 03
[2530] 9085 06,91,BF        CALL GRSUB3            Read the line # from ERAM/VDP
[2531] 9088 54              BYTE DDD1            * @DDD1 : Source address on ERA
[2532]               *                             Reset possible breakpoint too
[2533] 9089 BD,14,58        DST @EEE1,@CURLIN      Use standard default
[2534] 908C 8F,0E           DCZ @CURINC
[2535] 908E 50,97           BR  G9094
[2536] 9090 06,91,BF LISTZ0 CALL GRSUB3            Read last line # from ERAM/VD
[2537] 9093 30              BYTE STLN           *  @STLN : Source address on ERA
[2538]               *                             Reset possible breakpoint too
[2539] 9094 BD,0E,58        DST  @EEE1,@CURINC     @EEE1 : Destination address o
[2540]               *                             Also default for end line
[2541]               * Now first evaluate what we've got in CURLIN
[2542] 9097 8F,0E    G9094  DCZ  @CURINC           Check for combination xxx-
[2543] 9099 50,A9           BR   G90A6
[2544] 909B 93,20    G9098  DDEC @VARW             Backup to the separation mark
[2545] 909D D6,B0,20        CEQ  SPACE+OFFSET,V*VARW
       90A0 80
[2546] 90A1 70,9B           BS   G9098
[2547] 90A3 D6,B0,20        CEQ  MINUS+OFFSET,V*VARW Select last
       90A6 8D
[2548] 90A7 70,90           BS   LISTZ0
[2549] 90A9 C9,0E,14 G90A6  DCHE @CURLIN,@CURINC   If something like LIST 15-11
[2550] 90AC 70,B1           BS   G90AE
[2551] 90AE BD,0E,14        DST  @CURLIN,@CURINC   Replace byt LIST 15-15
[2552] 90B1 BD,4A,14 G90AE  DST  @CURLIN,@FAC      Prepare for line # search
[2553] 90B4 0F,7E           XML  SPEED             Search the line number table
[2554] 90B6 03              BYTE SEETWO
[2555] 90B7 BD,14,2E        DST  @EXTRAM,@CURLIN   Get first real line # in CURL
[2556] 90BA BD,4A,0E        DST  @CURINC,@FAC
[2557] 90BD 0F,7E           XML  SPEED
[2558] 90BF 03              BYTE SEETWO          * Evaluate second line #
[2559] 90C0 06,91,BF        CALL GRSUB3            Read 2 bytes of data from ERA
[2560] 90C3 2E              BYTE EXTRAM          * @EXTRAM : Source addr on ERAM
[2561]               *                             Reset possible breakpoint too
[2562] 90C4 C5,58,0E        DCH  @CURINC,@EEE1
[2563] 90C7 50,CD           BR   G90CA
[2564] 90C9 A3,2E,00        DADD 4,@EXTRAM         Else take next lower line
       90CC 04
[2565] 90CD BD,0E,2E G90CA  DST  @EXTRAM,@CURINC   Which could be equal to CURLI
[2566] 90D0 BD,2E,14        DST  @CURLIN,@EXTRAM   For use below by LIST
[2567] 90D3 93,2C           DDEC @PGMPTR           Backup to last CHAT
[2568] 90D5 0F,79           XML  PGMCHR            Retrieve last CHAT
[2569] 90D7 8E,42           CZ   @CHAT             Device name available
[2570] 90D9 71,35           BS   G9132
[2571] 90DB 06,81,F4        CALL CLSALL            Close all files that are open
[2572] 90DE BF,6E,09        DST  VRAMVS,@VSPTR     Re-initialize the V-stack
       90E1 58
[2573] 90E2 BD,24,6E        DST  @VSPTR,@STVSPT    And it's base
[2574] 90E5 0F,79           XML  PGMCHR            Get name length in CHAT
[2575] 90E7 BF,04,09        DST  VRAMVS+16,@PABPTR Get entrypoint in PAB
       90EA 68
[2576] 90EB 86,17           CLR  @DSRFLG           Indicate device I/O
[2577] 90ED 31,00,09        MOVE 9,G@PAB,V@4(@PABPTR)
       90F0 E0,04,04
       90F3 91,73
[2578] 90F5 BF,08,09        DST  VRAMVS+16+NLEN,@CCPADR Select start address
       90F8 75
[2579]               *                                   for copy

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0046 
FLMGR-359
[2580]               * GKXB GTLENGTH label
[2581] 90F9 06,97,F0        CALL GTLENG            GKXB Set length in PAB
[2582] 90FC 90,4C           INC  @FAC2             Plus length byte
[2583] 90FE BC,B0,08 LISTZ1 ST   @CHAT,V*CCPADR    Copy the bytes one by one
       9101 42
[2584] 9102 0F,79           XML  PGMCHR            Get next character
[2585] 9104 91,08           DINC @CCPADR           CCPADR ends up with highest a
[2586] 9106 92,4C           DEC  @FAC2             Count total # of characters
[2587] 9108 50,FE           BR   LISTZ1
[2588] 910A 06,97,68        CALL IOCLZ1            Preform OPEN on DSR
[2589] 910D 86,4A           CLR  @FAC              Create double byte PAB length
[2590] 910F BC,07,E0        ST   V@LEN(@PABPTR),@RECLEN Get record length
       9112 08,04
[2591] 9114 BC,4B,07        ST   @RECLEN,@FAC1     Get highest address used
[2592] 9117 A1,4A,08        DADD @CCPADR,@FAC      Compute record length
[2593] 911A BD,E0,06        DST  @CCPADR,V@BUF(@PABPTR) Store it
       911D 04,08
[2594] 911F 8E,80,84        CZ   @RAMTOP           If ERAM exists then
[2595] 9122 71,2B           BS   G9128
[2596] 9124 C5,4A,70        DCH  @>8370,@FAC       Compare with top of
[2597]               *                    VDP : if higher then 'not enough room'
[2598] 9127 77,BE           BS   ERRIO
[2599] 9129 51,30           BR   G912D
[2600] 912B C5,4A,30 G9128  DCH  @STLN,@FAC        Not enough room
[2601] 912E 77,BE           BS   ERRIO
[2602] 9130 BE,06,01 G912D  ST   1,@CCPPTR         Clear first line in output
[2603] 9133 51,3B           BR   G9138
[2604] 9135 BE,7F,1F G9132  ST   VWIDTH+3,@XPT     For common code usage
[2605] 9138 06,97,42        CALL INITKB            Reset current record length
[2606] 913B 8E,80,84 G9138  CZ   @RAMTOP           If ERAM exist then
[2607] 913E 71,43           BS   G9140
[2608] 9140 06,91,7C        CALL GRMLST            Fake it : move each line to t
[2609]               *                              CRUNCH buffer form ERAM
[2610] 9143 06,6A,74 G9140  CALL LLIST             List the current line
[2611] 9146 03              SCAN                   Test for a break key
[2612] 9147 51,51           BR   LISTZ3            No key
[2613] 9149 D6,75,02        CEQ  BREAK,@RKEY
[2614] 914C 71,62           BS   LISTZ4
[2615] 914E 03       LISTZ5 SCAN
[2616] 914F 51,4E           BR   LISTZ5
[2617] 9151 8E,80,84 LISTZ3 CZ   @RAMTOP           If ERAM exists
[2618] 9154 71,59           BS   G9156
[2619] 9156 BD,2E,58        DST  @FAC14,@EXTRAM    Restore the @EXTRAM
[2620] 9159 A7,2E,00 G9156  DSUB 4,@EXTRAM         Pointer to next line
       915C 04
[2621] 915D C5,0E,2E        DCH  @EXTRAM,@CURINC   Display all lines in range
[2622] 9160 51,3B           BR   G9138
[2623] 9162 8E,17    LISTZ4 CZ   @DSRFLG           Device I/O -> output last rec
[2624] 9164 51,70           BR   G916D
[2625] 9166 06,96,A8        CALL OUTREC            Output the last record
[2626] 9169 06,97,61        CALL IOCALL            Close the device properly
[2627] 916C 01              BYTE CZCLOS
[2628] 916D 05,60,1A        B    TOPL10
[2629] 9170 05,60,12 G916D  B    TOPL15            Restart the variable too
[2630]               * PAB image used in LIST function
[2631] 9173 00,12,00 PAB    BYTE 0,>12,0,0,0,0,0,0,OFFSET
       9176 00,00,00
       9179 00,00,60
[2632]               * Move each line in ERAM to CRNBUF area, put line number in
[2633]               * (CRNBUF), put CRNBUF+4 in (CRNBUF+2) which is the line
[2634]               * pointer field, put the text itself from ERAM to (CRNBUF+4
[2635]               * before call LLIST, trick it by moving CRNBUF to @EXTRAM
[2636] 917C 06,91,BF GRMLST CALL GRSUB3            Get line # from ERAM(use GREA
[2637] 917F 2E              BYTE EXTRAM          * @EXTRAM : Source address on E

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0047 
FLMGR-359
[2638]               *                             Reset possible breakpoint too
[2639] 9180 BD,A8,20        DST  @EEE1,V@CRNBUF    Put it in CRNBUF
       9183 58
[2640] 9184 BF,A8,22        DST  CRNBUF+4,V@CRNBUF+2 Put CRNBUF+4 into
       9187 08,24
[2641]               *                              the line pointer field
[2642] 9189 95,54           DINCT @DDD1            Get the pointer to the text
[2643]               *                              from GRAM
[2644] 918B 06,91,AD        CALL GRSUB4            Read the line pointer in (use
[2645]               *                              GREAD1)
[2646] 918E 93,58           DDEC @EEE1             Get the ptr to the length byt
[2647] 9190 06,91,A7        CALL GRSUB2            Read th length from ERAM, use
[2648] 9193 58              BYTE EEE1           *   GREAD1, @EEE1 : Source addre
[2649]               *                               on ERAM
[2650] 9194 BC,57,58        ST   @EEE1,@FFF1+1     Use the length as byte count
[2651]               *                             to move the text from ERAM to
[2652]               *                             VDP CRNBUF+4 area
[2653] 9197 BF,58,08        DST  CRNBUF+4,@EEE1    EEE1 : Destination address on
       919A 24
[2654] 919B 91,54           DINC @DDD1             DDD1 : Source address on ERAM
[2655] 919D 0F,8B           XML  GVWITE            Move data from ERAM to VDP
[2656] 919F BD,58,2E        DST  @EXTRAM,@FAC14    Save for later use
[2657] 91A2 BF,2E,08        DST  CRNBUF,@EXTRAM    Fake it
       91A5 20
[2658] 91A6 00              RTN
[2659]               * SUBROUTINE TO READ 2 BYTES OF DATA FROM ERAM OR VDP WITH
[2660]               * THE OPTION TO RESET THE POSSIBLE BREAKPOINT
[2661] 91A7 88,56    GRSUB2 FETCH @FFF1            Fetch the source address on
[2662] 91A9 BD,54,90        DST  *FFF1,@DDD1        ERAM or VDP
       91AC 56
[2663]                
[2664]               *                             @DDD1 : Source addr  on ERAM
[2665]               *                             or VDP
[2666] 91AD 8E,80,84 GRSUB4 CZ   @RAMTOP           If ERAM exists
[2667] 91B0 71,BA           BS   G91B7
[2668] 91B2 BF,56,00        DST  2,@FFF1           @FFF1 : Byte count
       91B5 02
[2669] 91B6 0F,8C           XML  GREAD1            Read data from ERAM to CPU
[2670] 91B8 51,BE           BR   G91BB
[2671] 91BA BD,58,B0 G91B7  DST  V*DDD1,@EEE1      Read data from VDP to CPU
       91BD 54
[2672] 91BE 00       G91BB  RTN
[2673] 91BF 88,56    GRSUB3 FETCH @FFF1            Fetch the source addr on ERAM
[2674] 91C1 BD,54,90        DST  *FFF1,@DDD1        or VDP
       91C4 56
[2675]               *                             @DDD1 : Source addr on ERAM/V
[2676] 91C5 06,91,AD        CALL GRSUB4            Do the actual read
[2677] 91C8 B3,58,7F        DAND >7FFF,@EEE1       Reset possible breakpoint
       91CB FF
[2678] 91CC 00              RTN
[2679]               *********** REC ROUTINE ***********************************
[2680]               * REC(X) returns the current record to which file X is
[2681]               *  positioned.
[2682] 91CD BD,5C,04 SUBREC DST  @PABPTR,@ARG      Save the current PAB & set ne
[2683] 91D0 06,92,21        CALL SUBEOF            Try to find the correct PAB
[2684] 91D3 C1,5C,04        DEX  @PABPTR,@ARG      @ARG : new PAB
[2685]               *                             @PABPTR : restore current PAB
[2686] 91D6 52,15           BR   EOFZ2             Didn't find the corresponding
[2687] 91D8 BD,4A,E0        DST  V@RNM(@ARG),@FAC  Obtain integer record number
       91DB 0A,5C
[2688] 91DD 0F,80           XML  CIF               Convert integer to floating
[2689] 91DF 0F,75           XML  CONT               and continue
[2690]               ***********************************************************
[2691]               *                         EOF ROUTINE

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0048 
FLMGR-359
[2692]               * EOF(X) returns status codes on file X. The meaning of the
[2693]               * result codes is:
[2694]               *           -1  Physical End Of File
[2695]               *            0  Not at End Of File yet
[2696]               *            1  Logical End Of File
[2697]               ***********************************************************
[2698] 91E1 BD,5C,04 EOF    DST  @PABPTR,@ARG      Save the current PAB and set
[2699]               *                              the new one in SUBEOF
[2700] 91E4 06,92,21        CALL SUBEOF            Try to find the PAB somewhere
[2701] 91E7 57,DA           BR   ERRFE             Can't file
[2702] 91E9 BE,5E,09        ST   CZSTAT,@ARG2      Select status code without
[2703] 91EC C0,E0,04        EX   @ARG2,V@COD(@PABPTR) destorying original code
       91EF 04,5E
[2704] 91F1 06,97,68        CALL IOCLZ1            Get the info from DSR
[2705] 91F4 C1,04,5C        DEX  @ARG,@PABPTR      Restore original PAB and orig
[2706] 91F7 BC,E0,04        ST   @ARG2,V@COD(@ARG)  I/O code
       91FA 5C,5E
[2707] 91FC BC,5E,E0        ST   V@SCR(@ARG),@ARG2 And pick up STATUS
       91FF 0C,5C
[2708] 9201 31,00,08        MOVE 8,G@FLOAT1,@FAC   Get floating 1
       9204 4A,92,19
[2709] 9207 DA,5E,03        CLOG 3,@ARG2           Test EOF bits
[2710] 920A 72,15           BS   EOFZ2             No EOF indication
[2711] 920C DA,5E,02        CLOG 2,@ARG2           Physical EOF
[2712] 920F 72,13           BS   G9210
[2713] 9211 83,4A           DNEG @FAC              Make result -1
[2714] 9213 0F,75    G9210  XML  CONT
[2715] 9215 87,4A    EOFZ2  DCLR @FAC              Create result 0
[2716] 9217 0F,75           XML  CONT
[2717] 9219 40,01,00 FLOAT1 BYTE >40,1,0,0,0,0,0,0   * Floating point -1
       921C 00,00,00
       921F 00,00
[2718] 9221 D6,42,B7 SUBEOF CEQ  LPARZ,@CHAT       * SYNTAX ERROR
[2719] 9224 41,09           BR   ERRSYN
[2720] 9226 0F,74           XML  PARSE             Parse up to the matching ")"
[2721] 9228 FF              BYTE >FF
[2722] 9229 06,93,5F        CALL CHKCNV            Convert and search for PAB
[2723] 922C 77,CE           BS   ERRBV             Avoid 0's and negatives bad v
[2724] 922E BC,62,17        ST   @DSRFLG,@ARG6     @DSRFLG got changed in CHKCON
[2725] 9231 06,93,74        CALL CHKCON            Check and search tiven filenu
[2726] 9234 BC,17,62        ST   @ARG6,@DSRFLG     @DSRFLG to changed CHKCON
[2727] 9237 01              RTNC                   Condition set : file # exists
[2728]               ***********************************************************
[2729]               *      LOAD / SAVE / MERGE UTILITY ROUTINE
[2730]               * GPNAME gets program name from OLD and SAVE
[2731]               * Can also be used for future implementation of REPLACE
[2732]               * statement. Also gives valuable contribution to updating
[2733]               * of program pointers (VSPTR, STVSPT, FLAG, etc...) and
[2734]               * creation of LOAD/SAVE PAB
[2735]               ***********************************************************
[2736] 9238 B2,45,80 GPNAME AND  >80,@FLAG         Avoid returns from ERRZZ rout
[2737] 923B D6,42,C7        CEQ  STRINZ,@CHAT
[2738] 923E 72,45           BS   G9242
[2739] 9240 D6,42,C8        CEQ  NUMZ,@CHAT        * SYNTAX ERROR
[2740] 9243 41,09           BR   ERRSYN
[2741] 9245 06,81,F4 G9242  CALL CLSALL            First close all open files
[2742] 9248 06,60,22        CALL KILSYM            Kill the symbol table
[2743] 924B BF,04,09        DST  VRAMVS+8,@PABPTR  Create PAB as low as possible
       924E 60
[2744] 924F 86,B0,04        CLR  V*PABPTR          Clear PAB with ripple-move
[2745] 9252 35,00,09        MOVE PABLEN-5,V*PABPTR,V@1(@PABPTR)
       9255 E0,01,04
       9258 B0,04
[2746] 925A 0F,79           XML  PGMCHR            Get length of file-specificat

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0049 
FLMGR-359
[2747] 925C A7,04,00        DSUB 4,@PABPTR         Make it a regular PAB
       925F 04
[2748] 9260 BC,E0,0D        ST   @CHAT,V@NLEN(@PABPTR) Copy name length to PAB
       9263 04,42
[2749] 9265 BD,0A,E0        DST  V@NLEN-1(@PABPTR),@STADDR Avoid problems(bugs!)
       9268 0C,04
[2750] 926A 8E,80,89        CZ   @RAMFLG           If ERAM not exist or imperati
[2751] 926D 52,78           BR   G9275
[2752] 926F 34,0A,E0        MOVE @STADDR,V*PGMPTR,V@NLEN+1(@PABPTR)
       9272 0E,04,B0
       9275 2C
[2753] 9276 52,87           BR   G9284
[2754] 9278 BD,56,0A G9275  DST  @STADDR,@FFF1     @FFF1 : Byte count
[2755] 927B BD,54,2C        DST  @PGMPTR,@DDD1     Source address on ERAM
[2756] 927E BD,58,04        DST  @PABPTR,@EEE1
[2757] 9281 A3,58,00        DADD NLEN+1,@EEE1      Destination address on VDP
       9284 0E
[2758] 9285 0F,8B           XML  GVWITE            Write from ERAM to VDP
[2759] 9287 A1,2C,0A G9284  DADD @STADDR,@PGMPTR   Skip the string
[2760]               * OLD and SAVE can only be imperative
[2761] 928A 86,34           CLR  @DATA             Clear DATA line
[2762] 928C 00              RTN                    That's all folks
[2763]               ***********************************************************
[2764]               *           READ / INPUT UTILITY ROUTINES
[2765]               ***********************************************************
[2766] 928D BD,0A,2C GETVAR DST  @PGMPTR,@STADDR   Save token pointer to first c
[2767] 9290 86,10           CLR  @VAR5             Clear # of parsed variables
[2768] 9292 BD,0E,6E        DST  @VSPTR,@VAR4      Save first entry in V-stack
[2769]               * Start parse cycle for IMPUT statement
[2770] 9295 CA,42,80 GETVZ0 CHE  >80,@CHAT         Make sure of varialbe name
[2771] 9298 61,09           BS   ERRSYN
[2772] 929A 0F,7A           XML  SYM               Get correct symbol table entr
[2773] 929C 86,11           CLR  @VAR6             Start with zero paren nesting
[2774] 929E D6,42,B7 GETVZ1 CEQ  LPARZ,@CHAT       Increment counter for "("
[2775] 92A1 52,A5           BR   G92A2
[2776] 92A3 90,11           INC  @VAR6
[2777] 92A5 8E,11    G92A2  CZ   @VAR6             Watch out for final balance
[2778] 92A7 72,B9           BS   G92B6
[2779] 92A9 06,95,B0        CALL CHKEND            Check for unbalenced parenthe
[2780] 92AC 61,09           BS   ERRSYN            Somebody forgot something!!!!
[2781] 92AE D6,42,B6        CEQ  RPARZ,@CHAT       Decrement for ")"
[2782] 92B1 52,B5           BR   G92B2
[2783] 92B3 92,11           DEC  @VAR6
[2784] 92B5 0F,79    G92B2  XML  PGMCHR            Get character following last
[2785] 92B7 52,9E           BR   GETVZ1
[2786] 92B9 0F,77    G92B6  XML  VPUSH             Push entry to V-stack
[2787] 92BB 90,10           INC  @VAR5             Count all pushed variables
[2788] 92BD 06,95,B0        CALL CHKEND            Next should either be EOS or
[2789] 92C0 72,CF           BS   GETVZ2            Found it EOS!!!!
[2790] 92C2 0F,7E           XML  SPEED             Must be at a
[2791] 92C4 00              BYTE SYNCHK          *  comma else
[2792] 92C5 B3              BYTE COMMAZ          *   its an error
[2793] 92C6 06,95,B0        CALL CHKEND            Check for end of statement
[2794] 92C9 52,95           BR   GETVZ0            Haven't found it yet
[2795] 92CB 8E,17           CZ   @DSRFLG           Error for keyboard I/O
[2796] 92CD 41,09           BR   ERRSYN
[2797] 92CF 00       GETVZ2 RTN
[2798]               * Create a temporary string in memory. BYTES contains the l
[2799] 92D0 BF,4C,65 CTSTR  DST  >6500,@FAC2       Indicate string in FAC
       92D3 00
[2800] 92D4 BD,50,0C CTSTR0 DST  @BYTES,@FAC6      Copy string length in FAC6
[2801] 92D7 0F,71           XML  GETSTR            Reserve the string
[2802] 92D9 BD,4E,1C        DST  @SREF,@FAC4       Copy start address of string
[2803] 92DC BF,4A,00        DST  >001C,@FAC        And indicate temp. string >00

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0050 
FLMGR-359
       92DF 1C
[2804] 92E0 00              RTN
[2805]               * Create a temporary string from TEMP5. Length is given
[2806]               * in BYTES.
[2807] 92E1 06,92,D0 CTMPST CALL CTSTR             Create the temporary string
[2808] 92E4 8E,51           CZ   @FAC7
[2809] 92E6 72,EE           BS   G92EB
[2810] 92E8 34,0C,B0        MOVE @BYTES,V*TEMP5,V*SREF
       92EB 1C,B0,66
[2811] 92EE 00       G92EB  RTN                    Non-empty
[2812]               * CHKNUM - Check for numeric argument
[2813] 92EF D6,01,C8 CHKNUM CEQ  NUMZ,@VAR0+1
[2814] 92F2 53,06           BR   G9303
[2815] 92F4 06,93,0F        CALL GETRAM            Get string length
[2816] 92F7 BD,56,34        DST  @DATA,@FAC12      Store entry for conversion
[2817] 92FA 86,00           CLR  @VAR0             Prepare for double action
[2818] 92FC A1,34,00        DADD @VAR0,@DATA       Get end of data field
[2819] 92FF 06,A0,12        CALL CONV1             Convert data to FAC #
[2820]               * Conversion should also end at end of field
[2821] 9302 D5,A3,90        DCEQ @DATA,V@CSNTMP    Set COND according to equalit
       9305 34
[2822] 9306 01       G9303  RTNC                   Back to caller
[2823] 9307 BC,4D,80 GETGFL ST   @RAMTOP,@FAC3     Select target memory
       930A 84
[2824] 930B 8E,4D    GETDAT CZ   @FAC3             Get everything from RAM
[2825] 930D 53,17           BR   G9314
[2826] 930F BC,01,B0 GETRAM ST   V*DATA,@VAR0+1    Get data in VAR0+1
       9312 34
[2827] 9313 86,4D           CLR  @FAC3             Be sure FAC3 = 0 !!!!
[2828] 9315 53,23           BR   G9320
[2829] 9317 BF,56,00 G9314  DST  1,@FFF1           FFF1 : byte count
       931A 01
[2830] 931B BD,54,34        DST  @DATA,@DDD1       DDD1 : source addr on ERAM
[2831] 931E 0F,8C           XML  GREAD1            Read data from ERAM
[2832] 9320 BC,01,58        ST   @EEE1,@VAR0+1     EEE1 : Destination addr on CP
[2833] 9323 91,34    G9320  DINC @DATA             Go to next datum for next tim
[2834] 9325 00              RTN
[2835] 9326 87,50    CHKSTR DCLR @FAC6             Assume we'll have an empty st
[2836] 9328 D6,01,C7        CEQ  STRINZ,@VAR0+1
[2837] 932B 73,32           BS   CHKSZ0
[2838] 932D D6,01,C8        CEQ  NUMZ,@VAR0+1      See ............
[2839] 9330 53,41           BR   EMPSTR
[2840] 9332 06,93,0B CHKSZ0 CALL GETDAT            Next datum is length byte
[2841] 9335 86,50           CLR  @FAC6             Be sure high byte = 0 !!!!
[2842] 9337 BC,51,01        ST   @VAR0+1,@FAC7     Prepare FAC for string assign
[2843] 933A BD,66,34        DST  @DATA,@TEMP5      Save string addr for assignme
[2844] 933D A1,34,50        DADD @FAC6,@DATA       Update DATA for end of field
[2845] 9340 00              RTN
[2846]               * Empty strings are handled below
[2847] 9341 D6,01,B3 EMPSTR CEQ  COMMAZ,@VAR0+1
[2848] 9344 73,4B           BS   G9348
[2849] 9346 06,93,4E        CALL DATEND            Check for end of data stateme
[2850] 9349 53,8F           BR   RTC               Return with COND if not EOS
[2851] 934B 93,34    G9348  DDEC @DATA             Backup data pointer for empti
[2852] 934D 00              RTN
[2853] 934E C0,42,01 DATEND EX   @VAR0+1,@CHAT
[2854] 9351 06,95,B0        CALL CHKEND            Check for EOS (=EOL or "::")
[2855] 9354 C0,42,01        EX   @VAR0+1,@CHAT     Restore original situation
[2856] 9357 01              RTNC
[2857]               ***********************************************************
[2858]               *           OPEN / CLOSE / RESTORE UTILITY ROUTNE
[2859]               * CHKFN - Check for token = "#" and collect and check
[2860]               * filenumber. Also convert filenumber to (two byte) integer
[2861]               * and check for range 0<x<256

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0051 
FLMGR-359
[2862]               ***********************************************************
[2863] 9358 0F,7E    CHKFN  XML  SPEED             Must be at a
[2864] 935A 00              BYTE SYNCHK         *   '#' else
[2865] 935B FD              BYTE NUMBEZ         *    its an error
[2866] 935C 0F,74           XML  PARSE             Parse argument up to ":"
[2867] 935E B5              BYTE COLONZ
[2868]               * Code to check for negative or zero result in floating poi
[2869]               * accumilator. If not... convert to integer and return two
[2870]               * byte integer in FAC
[2871] 935F D6,4C,65 CHKCNV CEQ  STRVAL,@FAC2      String/number mismatch
[2872] 9362 77,C2           BS   ERRSNM
[2873] 9364 86,54           CLR  @FAC10            Clear error-code byte
[2874] 9366 0F,12           XML  CFI               Convert to two byte integer
[2875] 9368 8E,54           CZ   @FAC10            BAD VALUE ERROR
[2876] 936A 57,CE           BR   ERRBV
[2877] 936C DA,4A,80        CLOG >80,@FAC          Negative result
[2878] 936F 53,8F           BR   RTC
[2879] 9371 8F,4A           DCZ  @FAC              And return with COND set/rese
[2880] 9373 01              RTNC
[2881] 9374 BC,17,4B CHKCON ST   @FAC1,@FNUM       Move result into FNUM
[2882]               * Check for high byte not zero (>0255)
[2883] 9377 8E,4A           CZ   @FAC              Bad value error
[2884] 9379 57,CE           BR   ERRBV
[2885]               * Search routine - Search for a given file number in the
[2886]               * chain of allocated PABs.
[2887]               * IOSTRT contains the start of the PAB - chain
[2888] 937B BD,04,3C        DST  @IOSTRT,@PABPTR   Get first link in the chain
[2889]               * Check for last PAB in the chain and exit if found
[2890] 937E 8F,04    CHKFZ1 DCZ  @PABPTR           Check if file # is correct
[2891] 9380 73,92           BS   G938F
[2892] 9382 D4,E0,02        CEQ  @FNUM,V@FIL(@PABPTR)
       9385 04,17
[2893] 9387 73,8F           BS   RTC
[2894] 9389 BD,04,B0        DST  V*PABPTR,@PABPTR  Try the next PAB
       938C 04
[2895] 938D 53,7E           BR   CHKFZ1
[2896] 938F D4,00,00 RTC    CEQ  @>8300,@>8300     Force COND to "SET"
[2897] 9392 01       G938F  RTNC                   Exit with no COND change
[2898]               ***********************************************************
[2899]               * OUTEOF outputs the last record if this record is
[2900]               * non-empty, and if the PAB is open for non-imput mode
[2901]               * (UPDATE, APPEND or OUTPUT).
[2902]               ***********************************************************
[2903] 9393 86,17    OUTEOF CLR  @DSRFLG
[2904] 9395 D6,E0,04        CEQ  CZWRIT,V@COD(@PABPTR) Non-input mode
       9398 04,03
[2905] 939A 53,A8           BR   G93A5
[2906] 939C 8E,E0,03        CZ   V@OFS(@PABPTR)    Non-empty record
       939F 04
[2907] 93A0 73,A8           BS   G93A5
[2908] 93A2 06,96,F8        CALL PRINIT            Initiate for output
[2909] 93A5 06,96,A8        CALL OUTREC            Output and remove pending con
[2910] 93A8 00       G93A5  RTN                    Return to whoever called
[2911]               ***********************************************************
[2912]               * DELPAB routine - delete a given PAB from chain under the
[2913]               * assumption that the PAB exists
[2914]               ***********************************************************
[2915]               * First compute start and end address for block move
[2916] 93A9 BD,0A,E0 DELPAB DST  V@BUF(@PABPTR),@STADDR Get lowest used address
       93AC 06,04
[2917] 93AE 93,0A           DDEC @STADDR           Make that an addr following P
[2918] 93B0 86,08           CLR  @CCPADR           Get highest addr in CCPADR (2
[2919] 93B2 BC,09,E0        ST   V@NLEN(@PABPTR),@CCPADR+1 complete the two byte
       93B5 0D,04

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0052 
FLMGR-359
[2920] 93B7 A2,09,0D        ADD  PABLEN-1,@CCPADR+1 Add PAB length-1
[2921] 93BA A1,08,04        DADD @PABPTR,@CCPADR   Compute actual addr within RA
[2922] 93BD D5,3C,04        DCEQ @PABPTR,@IOSTRT   Watch out for first PAB
[2923] 93C0 73,E9           BS   G93E6
[2924] 93C2 BD,02,3C        DST  @IOSTRT,@MNUM     Figure out where link to PAB
[2925] 93C5 D5,B0,02 G93C2  DCEQ @PABPTR,V*MNUM    Continue while not found
       93C8 04
[2926] 93C9 73,D1           BS   G93CE
[2927] 93CB BD,02,B0        DST  V*MNUM,@MNUM      Defer to next link in chain
       93CE 02
[2928] 93CF 53,C5           BR   G93C2             Short end for code-savings
[2929] 93D1 BD,B0,02 G93CE  DST  V*PABPTR,V*MNUM   Copy link over deleted PAB
       93D4 B0,04
[2930] 93D6 8F,B0,02        DCZ  V*MNUM            Adjust link only if not done
[2931] 93D9 73,E3           BS   G93E0
[2932] 93DB A1,B0,02        DADD @CCPADR,V*MNUM    Add deleted # of bytes for
       93DE 08
[2933] 93DF A5,B0,02        DSUB @STADDR,V*MNUM     link correction
       93E2 0A
[2934] 93E3 BD,04,B0 G93E0  DST  V*MNUM,@PABPTR    Get new PABPTR
       93E6 02
[2935] 93E7 53,FA           BR   G93F7
[2936] 93E9 BD,3C,B0 G93E6  DST  V*PABPTR,@IOSTRT  Update first link
       93EC 04
[2937] 93ED 8F,3C           DCZ  @IOSTRT           Only adjust if not last link
[2938] 93EF 73,F7           BS   G93F4
[2939] 93F1 A1,3C,08        DADD @CCPADR,@IOSTRT   Add deleted # of bytes
[2940] 93F4 A5,3C,0A        DSUB @STADDR,@IOSTRT
[2941] 93F7 BD,04,3C G93F4  DST  @IOSTRT,@PABPTR   Get new PABPTR
[2942]               * Move the bytes below the deleted block up in memory. This
[2943]               * includes both variables and PABs
[2944] 93FA BD,02,0A G93F7  DST  @STADDR,@MNUM     Get # of bytes to move
[2945] 93FD A5,02,40        DSUB @FREPTR,@MNUM
[2946] 9400 BD,06,08        DST  @CCPADR,@CCPPTR   Save destination address
[2947] 9403 8F,02    G9400  DCZ  @MNUM
[2948] 9405 74,14           BS   G9411
[2949] 9407 BC,B0,08        ST   V*STADDR,V*CCPADR Move byte by byte
       940A B0,0A
[2950] 940C 93,0A           DDEC @STADDR           Update source
[2951] 940E 93,08           DDEC @CCPADR            and destination pointers
[2952] 9410 93,02           DDEC @MNUM             Also update counter value
[2953] 9412 54,03           BR   G9400
[2954] 9414 A5,08,0A G9411  DSUB @STADDR,@CCPADR   Compute # of bytes of old PAB
[2955] 9417 8F,04           DCZ  @PABPTR           Avoid trouble with last PAB
[2956] 9419 74,34           BS   G9431
[2957] 941B 8F,B0,04 G9418  DCZ  V*PABPTR          Ad infinitum (or fundum)
[2958] 941E 74,2F           BS   G942C
[2959] 9420 A1,B0,04        DADD @CCPADR,V*PABPTR  Adjust link to next PAB
       9423 08
[2960] 9424 A1,E0,06        DADD @CCPADR,V@BUF(@PABPTR) Update the buffer link
       9427 04,08
[2961] 9429 BD,04,B0        DST  V*PABPTR,@PABPTR  Get next link in chain
       942C 04
[2962] 942D 54,1B           BR   G9418
[2963] 942F A1,E0,06 G942C  DADD @CCPADR,V@BUF(@PABPTR) Update buffer link
       9432 04,08
[2964]               * Adjust symbol table links
[2965] 9434 8F,3E    G9431  DCZ  @SYMTAB
[2966] 9436 74,B7           BS   G94B4
[2967] 9438 D1,3E,06        DCGE @CCPPTR,@SYMTAB   Only update lower links
[2968] 943B 74,B7           BS   G94B4
[2969] 943D A1,3E,08        DADD @CCPADR,@SYMTAB   Get symbol table pointer back
[2970] 9440 BD,04,3E        DST  @SYMTAB,@PABPTR   Get pointer for update
[2971] 9443 8E,80,84 DELPZ1 CZ   @RAMTOP

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0053 
FLMGR-359
[2972] 9446 54,4F           BR   DELPZ2
[2973] 9448 D1,E0,04        DCGE @STLN,V@4(@PABPTR) If imperative
       944B 04,30
[2974] 944D 74,54           BS   G9451
[2975] 944F A1,E0,04 DELPZ2 DADD @CCPADR,V@4(@PABPTR) Adjust name pointer
       9452 04,08
[2976] 9454 D2,B0,04 G9451  CGE  0,V*PABPTR        If string-fix breakpoints
       9457 00
[2977] 9458 74,9E           BS   G949B
[2978] 945A BE,4A,07        ST   >07,@FAC          Mask to get # of dims
[2979] 945D B0,4A,B0        AND  V*PABPTR,@FAC     Get # of dims
       9460 04
[2980] 9461 BD,4C,04        DST  @PABPTR,@FAC2     Pointer to 1st dim max
[2981] 9464 A3,4C,00        DADD 6,@FAC2            or string pointer
       9467 06
[2982] 9468 BF,50,00        DST  1,@FAC6           Number of pointers to change
       946B 01
[2983] 946C 86,4E           CLR  @FAC4             For 2 byte use of option base
[2984] 946E 8E,4A    G946B  CZ   @FAC              While more dimendions
[2985] 9470 74,86           BS   G9483
[2986] 9472 BE,4F,01        ST   1,@FAC5           Assume option base 0
[2987] 9475 A4,4F,43        SUB  @BASE,@FAC5       But correct if base 1
[2988] 9478 A1,4E,B0        DADD V*FAC2,@FAC4      Get dim maximum
       947B 4C
[2989] 947C A9,4E,50        DMUL @FAC6,@FAC4       Multiply it in
[2990] 947F 92,4A           DEC  @FAC              Next dim
[2991] 9481 95,4C           DINCT @FAC2
[2992] 9483 05,94,6E        B    G946B
[2993]               * FAC2 now points at the 1st string pointer
[2994]               * FAC6 contains the # of pointers that need to be changed
[2995] 9486 8F,50    G9483  DCZ  @FAC6             While pointers to cheange
[2996] 9488 74,9E           BS   G949B
[2997] 948A BD,4A,B0        DST  V*FAC2,@FAC       Get pointer to string
       948D 4C
[2998] 948E 8F,4A           DCZ  @FAC              If sting is non-null
[2999] 9490 74,98           BS   G9495
[3000] 9492 BD,EF,FF        DST  @FAC2,V@-3(@FAC)  Fix backpointer
       9495 FD,4A,4C
[3001] 9498 95,4C    G9495  DINCT @FAC2            Point to next pointer
[3002] 949A 93,50           DDEC @FAC6             One less pointer to change
[3003] 949C 54,86           BR   G9483
[3004] 949E 8F,E0,02 G949B  DCZ  V@2(@PABPTR)
       94A1 04
[3005] 94A2 74,B7           BS   G94B4
[3006] 94A4 D1,E0,02        DCGE @CCPPTR,V@2(@PABPTR)
       94A7 04,06
[3007] 94A9 74,B7           BS   G94B4
[3008] 94AB A1,E0,02        DADD @CCPADR,V@2(@PABPTR) Adjust next value link
       94AE 04,08
[3009] 94B0 BD,04,E0        DST  V@2(@PABPTR),@PABPTR Next entry
       94B3 02,04
[3010] 94B5 54,43           BR   DELPZ1
[3011] 94B7 A1,40,08 G94B4  DADD @CCPADR,@FREPTR   Update free word pointer
[3012] 94BA 00              RTN
[3013]               ***********************************************************
[3014]               * CNVDEF - Convert to 2 byte integer and default to 1 on
[3015]               *          negative or 0 ....
[3016]               ***********************************************************
[3017] 94BB 06,93,5F CNVDEF CALL CHKCNV            Check and convert
[3018] 94BE 54,C4           BR   CNVDZ0
[3019] 94C0 BF,4A,00        DST  1,@FAC            Default to 1 or minus and 0
       94C3 01
[3020] 94C4 00       CNVDZ0 RTN                    And return without COND set
[3021]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0054 
FLMGR-359
[3022]               * PARREC parses a possible REC clause in INPUT, PRINT or
[3023]               * RESTORE. In case a comma is detected without a REC clause
[3024]               * following it, the COND is set upon return. In case a REC
[3025]               * clause is specified for a file opened for SEQUENTIAL
[3026]               * access, a * FILE ERROR is given.
[3027]               ***********************************************************
[3028] 94C5 D6,42,B3 PARREC CEQ  COMMAZ,@CHAT      Only check if we have a ","
[3029] 94C8 54,F1           BR   G94EE
[3030] 94CA 0F,79           XML  PGMCHR            Check next token for REC
[3031] 94CC D6,42,DE        CEQ  RECZ,@CHAT        May be USING clause
[3032] 94CF 53,8F           BR   RTC
[3033] 94D1 DA,E0,05        CLOG 1,V@FLG(@PABPTR)
       94D4 04,01
[3034] 94D6 77,DA           BS   ERRFE
[3035] 94D8 0F,79           XML  PGMCHR            Get first character of expres
[3036] 94DA 06,93,93        CALL OUTEOF            Output possible pending outpu
[3037] 94DD 86,E0,03        CLR  V@OFS(@PABPTR)    Clear record offset
       94E0 04
[3038] 94E1 0F,74           XML  PARSE             Translate the expression in R
[3039] 94E3 B5              BYTE COLONZ
[3040] 94E4 06,93,5F        CALL CHKCNV            Check numeric and convert to
[3041] 94E7 D2,4A,00        CGE  0,@FAC             2 byte integer, Bad Value
[3042] 94EA 57,CE           BR   ERRBV
[3043] 94EC BD,E0,0A        DST  @FAC,V@RNM(@PABPTR) Store actual record number
       94EF 04,4A
[3044] 94F1 00       G94EE  RTN
[3045]               ***********************************************************
[3046]               *              DISPLAY / ACCEPT UTILITIES
[3047]               ***********************************************************
[3048] 94F2 06,97,42 DISACC CALL INITKB            PABPTR is used as flag (no DS
[3049] 94F5 D6,42,EF DISPZ1 CEQ  ERASEZ,@CHAT      Check for ERASE ALL
[3050] 94F8 55,1B           BR   G9518
[3051] 94FA DA,04,01        CLOG 1,@PABPTR          already used once
[3052] 94FD 41,09           BR   ERRSYN
[3053] 94FF 0F,79           XML  PGMCHR            Check next token for ALL
[3054] 9501 0F,7E           XML  SPEED
[3055] 9503 00              BYTE SYNCHK          *  has to be ALL
[3056] 9504 EC              BYTE ALLZ
[3057] 9505 07,80           ALL  BKGD+OFFSET       Clear screen to background co
[3058] 9507 BE,7F,03        ST   3,@XPT            Reset pending output pointer
[3059] 950A DA,04,04        CLOG 4,@PABPTR         Didn't use AT yet
[3060] 950D 55,16           BR   G9513
[3061] 950F BE,06,01        ST   1,@CCPPTR         Reset column pointer
[3062] 9512 BF,08,02        DST  SCRNBS+2,@CCPADR   and screen base address
       9515 E2
[3063] 9516 B6,04,01 G9513  OR   1,@PABPTR         Set "ERASE USED" flag
[3064] 9519 54,F5           BR   DISPZ1            Try next token
[3065] 951B D6,42,EE G9518  CEQ  BEEPZ,@CHAT        delay action for BEEP
[3066] 951E 55,2C           BR   G9529
[3067] 9520 DA,04,02        CLOG 2,@PABPTR         Use it only once
[3068] 9523 41,09           BR   ERRSYN
[3069] 9525 B6,04,02        OR   2,@PABPTR         No syntax error detected here
[3070] 9528 0F,79           XML  PGMCHR            Evaluate next token
[3071] 952A 54,F5           BR   DISPZ1            Get set for second pass
[3072] 952C D6,42,F0 G9529  CEQ  ATZ,@CHAT         Generate "AT" clause
[3073] 952F 55,74           BR   G9571
[3074] 9531 DA,04,04        CLOG 4,@PABPTR         Second usage not
[3075] 9534 41,09           BR   ERRSYN
[3076] 9536 0F,79           XML  PGMCHR             allowed....
[3077] 9538 0F,7E           XML  SPEED
[3078] 953A 00              BYTE SYNCHK          * Skip left parenthesis
[3079] 953B B7              BYTE LPARZ
[3080] 953C 0F,74           XML  PARSE             Now parse any expression
[3081] 953E B3              BYTE COMMAZ

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0055 
FLMGR-359
[3082] 953F 0F,7E           XML  SPEED
[3083] 9541 00              BYTE SYNCHK          * Check for "," and skip it
[3084] 9542 B3              BYTE COMMAZ
[3085] 9543 06,94,BB        CALL CNVDEF            Convert to 2 byte numeric
[3086] 9546 BE,4C,18        ST   24,@FAC2          Convert modulo 24 (# screen l
[3087] 9549 06,96,1D        CALL COMMOD            Compute remainder
[3088] 954C 92,4B           DEC  @FAC1             Convert back to 0 (range was
[3089] 954E AA,4B,20        MUL  32,@FAC1          Convert to line base address
[3090] 9551 BD,08,4B        DST  @FAC1,@CCPADR     And repalce CCPADR
[3091] 9554 0F,74           XML  PARSE             Parse column expression
[3092] 9556 B6              BYTE RPARZ
[3093] 9557 0F,7E           XML  SPEED
[3094] 9559 00              BYTE SYNCHK          * Check for ")" at end
[3095] 955A B6              BYTE RPARZ
[3096] 955B 06,94,BB        CALL CNVDEF            Again convert to two byte int
[3097] 955E BE,4C,1C        ST   VWIDTH,@FAC2      Convert modulo video width
[3098] 9561 06,96,1D        CALL COMMOD            Compute remainder
[3099] 9564 BC,06,4B        ST   @FAC1,@CCPPTR     Select current column
[3100] 9567 A1,08,4A        DADD @FAC,@CCPADR      Compute full address
[3101] 956A 91,08           DINC @CCPADR           Adjust for column 0 (offset-1
[3102] 956C B6,04,04        OR   4,@PABPTR         Set "AT-CLAUSE" used flag
[3103] 956F B6,04,20        OR   32,@PABPTR        Set "NON-STANDARD SCREEN ADDR
[3104] 9572 54,F5           BR   DISPZ1            Continue for next item
[3105] 9574 D6,42,EB G9571  CEQ  SIZEZ,@CHAT       "SIZE" clause
[3106] 9577 55,A3           BR   G95A0
[3107] 9579 DA,04,08        CLOG 8,@PABPTR         Only use once
[3108] 957C 41,09           BR   ERRSYN
[3109] 957E 0F,79           XML  PGMCHR            Get character following the S
[3110] 9580 D6,42,B7        CEQ  LPARZ,@CHAT        has to open "("
[3111] 9583 41,09           BR   ERRSYN
[3112] 9585 0F,74           XML  PARSE             And close again ")"
[3113] 9587 FE              BYTE VALIDZ
[3114] 9588 D2,4A,00        CGE  0,@FAC            Change to positive argument
[3115] 958B 75,92           BS   G958F
[3116] 958D 83,4A           DNEG @FAC              For ACCEPT statement with siz
[3117] 958F B6,04,80        OR   >80,@PABPTR        indicate in highest bit
[3118] 9592 06,93,5F G958F  CALL CHKCNV
[3119] 9595 77,CE           BS   ERRBV             * BAD VALUE
[3120] 9597 8E,4A           CZ   @FAC              Also for args >255 (less then
[3121] 9599 57,CE           BR   ERRBV
[3122] 959B BC,05,4B        ST   @FAC1,@PABPTR+1   Copy to PABPTR (always used)
[3123] 959E B6,04,08        OR   8,@PABPTR         Prevent further use
[3124] 95A1 54,F5           BR   DISPZ1             and go on
[3125] 95A3 D6,42,FE G95A0  CEQ  VALIDZ,@CHAT      Exclude VALIDATE option
[3126] 95A6 75,BC           BS   G95B9
[3127]               * Start evaluating ERASE clause here
[3128] 95A8 DA,04,08        CLOG 8,@PABPTR
[3129] 95AB 75,B0           BS   CHKEND
[3130] 95AD 06,95,E2        CALL SIZE1             Evaluate field defined in SIZ
[3131]               * If it's no DISPLAY keyword ( AT, SIZE, BEEP or USING) it
[3132]               * has to be a print separator or colon ":"
[3133]               * If anything is specified is has to be a colon or end of
[3134]               * line... for end-of-line output current record
[3135]               * Check for end of statement
[3136] 95B0 DA,42,80 CHKEND CLOG >80,@CHAT
[3137] 95B3 75,BA           BS   G95B7
[3138] 95B5 CA,42,84        CHE  TREMZ+1,@CHAT
[3139] 95B8 53,8F           BR   RTC
[3140] 95BA 8E,42    G95B7  CZ   @CHAT             Set COND according to CHAT
[3141] 95BC 01       G95B9  RTNC
[3142]               ***********************************************************
[3143]               * NXTCHR - Get next program character - skip all strings,
[3144]               *          numerics and line references...
[3145]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0056 
FLMGR-359
[3146] 95BD 06,95,B0 NXTCHR CALL CHKEND            Check for end of statements
[3147] 95C0 73,8F           BS   RTC               Avoid end of statement
[3148] 95C2 D6,42,C7        CEQ  STRINZ,@CHAT      Skip all strings
[3149] 95C5 75,CC           BS   NXTCZ0
[3150] 95C7 D6,42,C8        CEQ  NUMZ,@CHAT         and numerics/unquoted string
[3151] 95CA 55,D8           BR   G95D5
[3152] 95CC 0F,79    NXTCZ0 XML  PGMCHR            Get string length
[3153] 95CE BC,4B,42        ST   @CHAT,@FAC1       Make that a double please...
[3154] 95D1 86,4A           CLR  @FAC              Hic.... Oops, sorry
[3155] 95D3 A1,2C,4A        DADD @FAC,@PGMPTR      Back to the serious stuff
[3156] 95D6 55,DF           BR   G95DC
[3157] 95D8 D6,42,C9 G95D5  CEQ  LNZ,@CHAT         Line # = skip 2 tokens
[3158] 95DB 55,DF           BR   G95DC
[3159] 95DD 95,2C           DINCT @PGMPTR          <----------- That's the skip
[3160] 95DF 0F,79    G95DC  XML   PGMCHR           Get the next token
[3161] 95E1 00              RTN
[3162]               ***********************************************************
[3163]               *                 PRINT / DISPLAY UTILITES
[3164]               * Use the parameters specified in SIZE for further
[3165]               * evaluation of the limited field length
[3166]               ***********************************************************
[3167] 95E2 DA,04,04 SIZE1  CLOG 4,@PABPTR         Not "AT" clause used
[3168] 95E5 55,FF           BR   G95FC
[3169] 95E7 D6,06,01        CEQ  1,@CCPPTR         Might have to print current
[3170] 95EA 75,FF           BS   G95FC
[3171] 95EC BC,4A,06        ST   @CCPPTR,@FAC      Compute final position after
[3172] 95EF A0,4A,05        ADD  @PABPTR+1,@FAC     in FAC and compare with reco
[3173] 95F2 92,4A           DEC  @FAC
[3174] 95F4 C4,4A,07        CH   @RECLEN,@FAC      Size clause too long
[3175] 95F7 55,FF           BR   G95FC
[3176]               * We can't get here for AT( , ) output, since right margin
[3177]               * limited there
[3178] 95F9 06,96,A8        CALL OUTREC            Advance to next line
[3179] 95FC 06,96,CF        CALL SCRO              Scroll the screeen
[3180] 95FF A4,07,06 G95FC  SUB  @CCPPTR,@RECLEN   Limit field size to available
[3181] 9602 90,07           INC  @RECLEN            space... including current p
[3182] 9604 C4,07,05        CH   @PABPTR+1,@RECLEN
[3183] 9607 56,CB           BR   INITZ1
[3184] 9609 BC,07,05        ST   @PABPTR+1,@RECLEN Only accept if available
[3185] 960C 56,CB           BR   INITZ1            Reinitialize CCPPTR
[3186]               * Copy (converted) numerical datum in string
[3187] 960E BC,0D,56 RSTRING ST  @FAC12,@BYTES+1   Get actual string length
[3188] 9611 86,0C           CLR  @BYTES            Create double byte value
[3189] 9613 06,92,D0        CALL CTSTR             Create a temporary string
[3190] 9616 34,0C,B0        MOVE @BYTES,*FAC11,V*SREF Copy value string
       9619 1C,90,55
[3191] 961C 00              RTN
[3192]               * COMMOD - Compute FAC module FAC2
[3193] 961D AC,4A,4C COMMOD DIV  @FAC2,@FAC        Compute remainder
[3194] 9620 8E,4B           CZ   @FAC1             Avoid zero remainders
[3195] 9622 56,27           BR   G9624
[3196] 9624 BC,4B,4C        ST   @FAC2,@FAC1       Assume maximum remainder
[3197] 9627 86,4A    G9624  CLR  @FAC              Clear upper byte
[3198] 9629 00              RTN
[3199]               * TSTSEP tests for separator in print and branches to the
[3200]               * correct evaluation routine.
[3201]               * If no separator is found, simple return.
[3202]               * Test case end of line
[3203] 962A 06,95,B0 TSTSEP CALL CHKEND
[3204] 962D 56,34           BR   TSTSZ0
[3205] 962F BF,90,73        DST  EOLEX,*SUBSTK     Replace return address with E
       9632 83,95
[3206] 9634 CA,42,B3 TSTSZ0 CHE  COMMAZ,@CHAT
[3207] 9637 56,5C           BR   TSTSZ1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0057 
FLMGR-359
[3208] 9639 C6,42,B5        CH   COLONZ,@CHAT
[3209] 963C 76,5C           BS   TSTSZ1
[3210] 963E BF,90,73        DST  PRSEM,*SUBSTK     Expect it to be a ";"
       9641 83,7A
[3211] 9643 06,83,C5        CALL TSTINT            Test for INTERNAL files
[3212] 9646 56,5C           BR   TSTSZ1            Treat all separators as ";"
[3213] 9648 D6,42,B3        CEQ  COMMAZ,@CHAT
[3214] 964B 56,52           BR   G964F
[3215] 964D BF,90,73        DST  PRTCOM,*SUBSTK
       9650 83,5C
[3216] 9652 D6,42,B5 G964F  CEQ  COLONZ,@CHAT
[3217] 9655 56,5C           BR   TSTSZ1
[3218] 9657 BF,90,73        DST  PRCOL,*SUBSTK
       965A 83,77
[3219] 965C 00       TSTSZ1 RTN
[3220]               * PARFN - Parse string expression and create PAB automatica
[3221]               *         continue in CSTRIN for copy string to PAB
[3222]               * Exit on non-string values
[3223]               *
[3224]               * First evaluate string expression
[3225] 965D 0F,74    PARFN  XML  PARSE             Parse up to next comma    <<<
[3226] 965F B3              BYTE COMMAZ          *                           <<<
[3227] 9660 D6,4C,65        CEQ  STRVAL,@FAC2      Check for "STRING"        <<<
[3228] 9663 57,C2           BR   ERRSNM
[3229] 9665 BD,02,50        DST  @FAC6,@MNUM       Copy length byte in MNUM
[3230] 9668 A2,03,0E        ADD  PABLEN,@MNUM+1    Account for PAB length+contro
[3231] 966B 0F,77           XML  VPUSH             Save start of string somewher
[3232] 966D BD,4A,02        DST  @MNUM,@FAC        Setup for MEMCHK - check for
[3233] 9670 0F,72           XML  MEMCHK             memory overflow
[3234] 9672 77,CA           BS   ERRMEM            * MEMORY FULL
[3235] 9674 0F,78           XML  VPOP              Restore all FAC information a
[3236] 9676 A5,40,02        DSUB @MNUM,@FREPTR     Update free word pointer
[3237] 9679 BD,04,40        DST  @FREPTR,@PABPTR   Assign PAB entry address
[3238] 967C 91,04           DINC @PABPTR           Correct for byte within PAB
[3239] 967E 86,B0,04        CLR  V*PABPTR          Clear PAB plus control info
[3240] 9681 35,00,0D        MOVE PABLEN-1,V*PABPTR,V@1(@PABPTR)  Ripple byte
       9684 E0,01,04
       9687 B0,04
[3241] 9689 BC,E0,03        ST   @MNUM+1,V@OFS(@PABPTR) Save length of PAB
       968C 04,03
[3242] 968E BC,02,51        ST   @FAC7,@MNUM       Compute # of bytes in name
[3243] 9691 BC,E0,0D        ST   @FAC7,V@NLEN(@PABPTR) Store name length
       9694 04,51
[3244] 9696 BC,E0,02        ST   @FNUM,V@FIL(@PABPTR) Copy file number in PAB
       9699 04,17
[3245] 969B BD,08,04        DST  @PABPTR,@CCPADR   Get start addr for string des
[3246] 969E A3,08,00        DADD NLEN+1,@CCPADR    Add offset to actual start ad
       96A1 0E
[3247]               * TRICKY - OPTFLG also results offset added in CSTRIN
[3248] 96A2 86,17           CLR  @OPTFLG           Clear all option flags
[3249] 96A4 0F,84           XML  IO                CSTRIN I/O UTILITY
[3250] 96A6 02              BYTE CSTRIN
[3251] 96A7 00              RTN
[3252]               ***********************************************************
[3253]               *                      OUTREC
[3254]               * OUTREC and INITRC are used to output a record to either
[3255]               * screen or external I/O devices, and to initiate pointers
[3256]               * for further I/O.
[3257]               ***********************************************************
[3258] 96A8 BC,03,07 OUTREC ST   @RECLEN,@MNUM+1   Compute number of characters
[3259] 96AB 90,03           INC  @MNUM+1            positions we should fill
[3260] 96AD 8E,17           CZ   @DSRFLG           Screen I/O
[3261] 96AF 76,D6           BS   G96D3
[3262] 96B1 0F,84           XML  IO                Fill the remainder of the rec

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0058 
FLMGR-359
[3263] 96B3 01              BYTE FILSPC          *  with appropriate fillers
[3264] 96B4 DA,04,08        CLOG 8,@PABPTR           block output on size
[3265] 96B7 53,8F           BR   RTC
[3266] 96B9 DA,04,04        CLOG 4,@PABPTR         "AT CLAUSE USED"
[3267] 96BC 76,CF           BS   SCRO
[3268]               * Next test for xing the end of screen
[3269] 96BE A3,08,00        DADD 4,@CCPADR
       96C1 04
[3270] 96C2 CA,08,03        CHE  3,@CCPADR
[3271] 96C5 56,CB           BR   INITZ1
[3272] 96C7 BF,08,00        DST  2,@CCPADR         Restart at upper left hand
       96CA 02
[3273]               *                              corner of screen
[3274] 96CB BE,06,01 INITZ1 ST   1,@CCPPTR         Reset current column pointer
[3275] 96CE 00              RTN
[3276] 96CF 0F,83    SCRO   XML  SCROLL            Scroll the screen one line
[3277] 96D1 BE,06,01        ST   1,@CCPPTR         Reinitialize CCPPTR
[3278] 96D4 57,57           BR   INTKB0             and reinitialize
[3279]               * This is also entry for last record output
[3280] 96D6 DA,E0,05 G96D3  CLOG >10,V@FLG(@PABPTR) FIXED records
       96D9 04,10
[3281] 96DB 56,E5           BR   G96E2
[3282] 96DD BC,03,07        ST   @RECLEN,@MNUM+1   Ready for space filling
[3283] 96E0 90,03           INC  @MNUM+1           Move to first position outsid
[3284]               *                              record
[3285] 96E2 0F,84           XML  IO                And do it up to end of record
[3286] 96E4 01              BYTE FILSPC
[3287] 96E5 92,06    G96E2  DEC  @CCPPTR           Update last character positio
[3288] 96E7 BC,E0,09        ST   @CCPPTR,V@CNT(@PABPTR) Store # of characters
       96EA 04,06
[3289] 96EC 86,E0,03        CLR  V@OFS(@PABPTR)    Undo pending record offsets
       96EF 04
[3290] 96F0 06,97,61        CALL IOCALL            Call DSR
[3291] 96F3 03              BYTE CZWRIT          *  for WRITE mode
[3292] 96F4 86,09           CLR  @CCPADR+1         Get address at buffer start
[3293] 96F6 57,04           BR   PRZZ0
[3294]               * PRINIT initializes the variable CCPADR, CCPPTR, RECLEN an
[3295]               * DSRFLG, for a given PABPTR.
[3296] 96F8 86,17    PRINIT CLR  @DSRFLG           Indicate external I/O in DSRF
[3297] 96FA BC,07,E0        ST   V@LEN(@PABPTR),@RECLEN  Pick up record length
       96FD 08,04
[3298] 96FF BC,09,E0        ST   V@OFS(@PABPTR),@CCPADR+1 Get offset in record
       9702 03,04
[3299] 9704 BC,06,09 PRZZ0  ST   @CCPADR+1,@CCPPTR  Compute columnar position
[3300] 9707 90,06           INC  @CCPPTR           And convert from offset
[3301] 9709 86,08           CLR  @CCPADR           Clear upper byte
[3302] 970B A1,08,E0        DADD V@BUF(@PABPTR),@CCPADR Compute actual address
       970E 06,04
[3303] 9710 00              RTN
[3304]               ***********************************************************
[3305]               * OSTRNG - Copy the value of the string expression to the
[3306]               *          screen.
[3307]               ***********************************************************
[3308] 9711 BC,0C,51 OSTRNG ST   @FAC7,@BYTES      Pick up the string length
[3309] 9714 8E,0C    G9711  CZ   @BYTES            Output as many records as req
[3310] 9716 77,41           BS   G973E
[3311]               * CHKREC check available space in current record.
[3312]               * If the string to be output is too long, it is chuncked up
[3313]               * into digestable pieces. If the current record is partly
[3314]               * filled up, it is output before any chuncking is done.
[3315] 9718 BC,03,06 CHKREC ST   @CCPPTR,@MNUM+1   Use MNUM for current offset i
[3316] 971B BC,02,07 CHKRZ0 ST   @RECLEN,@MNUM     Compute remaining area
[3317] 971E A4,02,06        SUB  @CCPPTR,@MNUM      between column and end
[3318] 9721 90,02           INC  @MNUM             Also count current column

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0059 
FLMGR-359
[3319] 9723 C8,02,0C        CHE  @BYTES,@MNUM      Won't fit in current record
[3320] 9726 77,33           BS   G9730
[3321] 9728 D6,03,01        CEQ  1,@MNUM+1         Unused record
[3322] 972B 77,36           BS   CHKRZ1
[3323] 972D 06,96,A8        CALL OUTREC            Output whatever we have
[3324] 9730 57,18           BR   CHKREC            And try again
[3325] 9732 00              RTN
[3326] 9733 BC,02,0C G9730  ST   @BYTES,@MNUM      Use actual count if fit
[3327] 9736 A4,0C,02 CHKRZ1 SUB  @MNUM,@BYTES      Update remaining chars count
[3328] 9739 A0,06,02        ADD  @MNUM,@CCPPTR     Also new column pointer
[3329] 973C 0F,84           XML  IO                Copy string to output
[3330] 973E 02              BYTE CSTRIN
[3331] 973F 57,14           BR   G9711             Continue as long as needed
[3332] 9741 00       G973E  RTN
[3333]               ***********************************************************
[3334]               * INITKB - Initialize the variable needed for keyboard outp
[3335]               ***********************************************************
[3336] 9742 86,04    INITKB CLR  @PABPTR           Don't use any DISPLAY options
[3337] 9744 BE,17,60        ST   OFFSET,@DSRFLG    Load for correction of screen
[3338] 9747 BE,06,01        ST   1,@CCPPTR         Assume un-initialized XPT
[3339] 974A C6,7F,02        CH   2,@XPT            * Patch for un-initialized XP
[3340] 974D 57,54           BR   G9751
[3341] 974F BC,06,7F        ST   @XPT,@CCPPTR      Initialize CCPPTR
[3342] 9752 96,06           DECT @CCPPTR           Correct for incorrect XPT off
[3343] 9754 BE,07,1C G9751  ST   VWIDTH,@RECLEN    Get video screen width
[3344] 9757 BC,09,06 INTKB0 ST   @CCPPTR,@CCPADR+1 Initialize screen address
[3345] 975A 86,08           CLR  @CCPADR           Clear upper byte CCPADR
[3346] 975C A3,08,02        DADD SCRNBS+1,@CCPADR  Add start-addr plus comenstat
       975F E1
[3347] 9760 00              RTN
[3348] 9761 88,56    IOCALL FETCH @FAC12           I/O code to FAC12 (BUG!!!)
[3349] 9763 BC,E0,04        ST   @FAC12,V@COD(@PABPTR) Pick up the I/O code
       9766 04,56
[3350] 9768 06,97,6E IOCLZ1 CALL CDSR              Call the DSR routine
[3351] 976B 57,9A           BR   ERRZ2             Give I/O error on error
[3352] 976D 00              RTN                    Or else return
[3353]               * DSR CALL ROUTINE - NORMAL ENTRY
[3354] 976E BE,E0,0C CDSR   ST   OFFSET,V@SCR(@PABPTR)   Always set screen offse
       9771 04,60
[3355] 9773 35,00,1E        MOVE 30,@FAC,V@VROAZ   Save FAC area
       9776 A3,C0,4A
[3356] 9779 BD,56,04        DST  @PABPTR,@FAC12    Get PAB pointer in FAC
[3357] 977C A3,56,00        DADD NLEN,@FAC12       Get PAB pointer in FAC
       977F 0D
[3358] 9780 B2,E0,05        AND  >1F,V@FLG(@PABPTR) Clear error bits for ON ERRO
       9783 04,1F
[3359]               *                       time, I/O process can still be
[3360]               *                        continued
[3361] 9785 06,00,10        CALL CALDSR            Call actual DSR link routine
[3362] 9788 08              BYTE 8
[3363] 9789 35,00,1E        MOVE 30,V@VROAZ,@FAC
       978C 4A,A3,C0
[3364]               * MOVE does not affect status
[3365] 978F 77,96           BS   CDSRZ0            ERROR = ERROR = ERROR
[3366] 9791 DA,E0,05        CLOG >E0,V@FLG(@PABPTR) Set COND if no error
       9794 04,E0
[3367] 9796 01       CDSRZ0 RTNC
[3368]               * ERROR MESSAGES
[3369] 9797 06,80,FB ERRZ2B CALL CLRFRE            Undo allocation of PAB
[3370]               * First check is it error coming from AUTOLD
[3371]               * If it is then do not print the error messege and
[3372]               *  go back to TOPL02
[3373] 979A 31,00,02 ERRZ2  MOVE 2,G@TOPL02,V@AUTTMP
       979D A3,94,60

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0060 
FLMGR-359
       97A0 30
[3374] 97A1 D5,80,8A        DCEQ V@AUTTMP,@RSTK+2
       97A4 A3,94
[3375] 97A6 57,AC           BR   G97A9
[3376] 97A8 BE,73,8A        ST   RSTK+2,@SUBSTK
[3377] 97AB 00              RTN
[3378]               ***********************************************************
[3379]               * Next code is to avoid recursion of errors in CLSALL
[3380]               * routine. If this entry is taken from CLSALL, the stack
[3381]               * will contain CLSLBL as a retrun address in the third leve
[3382]               ***********************************************************
[3383] 97AC A6,73,04 G97A9  SUB  4,@SUBSTK
[3384] 97AF D7,90,73        DCEQ CLSLBL,*SUBSTK
       97B2 81,E9
[3385] 97B4 57,BB           BR   G97B8
[3386] 97B6 06,6A,82 WRNIO  CALL WARNZZ            Give warning to the user
[3387] 97B9 23              BYTE 35                * I/O ERROR but warning
[3388] 97BA 00              RTN                    And return to close routine
[3389] 97BB A2,73,04 G97B8  ADD  4,@SUBSTK         Back up two levels for OLD/SA
[3390] 97BE 06,6A,84 ERRIO  CALL ERRZZ
[3391] 97C1 24              BYTE 36                * I/O ERROR
[3392]               * ERROR messages called in this file
[3393] 97C2 06,6A,84 ERRSNM CALL ERRZZ
[3394] 97C5 07              BYTE 7                 * STRING-NUMBER MISMATCH
[3395] 97C6 06,6A,84 ERRIM  CALL ERRZZ
[3396] 97C9 0A              BYTE 10                * IMAGE ERROR
[3397] 97CA 06,6A,84 ERRMEM CALL ERRZZ
[3398] 97CD 0B              BYTE 11                * MEMORY FULL
[3399] 97CE 06,6A,84 ERRBV  CALL ERRZZ
[3400] 97D1 1E              BYTE 30                * BAD VALUE
[3401] 97D2 06,6A,84 ERRINP CALL ERRZZ
[3402] 97D5 20              BYTE 32                * INPUT ERROR
[3403] 97D6 06,6A,84 ERRDAT CALL ERRZZ
[3404] 97D9 21              BYTE 33                * DATA ERROR
[3405] 97DA 06,6A,84 ERRFE  CALL ERRZZ
[3406] 97DD 22              BYTE 34                * FILE ERROR
[3407] 97DE 06,6A,84 ERRPV  CALL ERRZZ
[3408] 97E1 27              BYTE 39                * PROTECTION VIOLATION
[3409] 97E2 06,6A,84 ERRMUV CALL ERRZZ
[3410] 97E5 09              BYTE 9                 * IMPROPERLY USED NAME
[3411]               * Other errors called in file
[3412]               * ERRSYN    * SYNTAX ERROR                        BYTE  3
[3413]               * ERRST     * STRING TRUNCATED ERROR              BYTE 19
[3414]               * WRNNPP    * NO PROGRAM PRESENT                  BYTE 29
[3415]               * WRNINP    * INPUT ERROR            (WARNING)    BYTE 32
[3416]               * ERRIO     * I/O ERROR                           BYTE 36
[3417]               * WRNIO     * I/O ERROR              (WARNING)    BYTE 36
[3418]               * WRNSNM    * STRING NO. MISMATCH    (WARNING)    BYTE  7
[3419]               ***********************************************************
[3420]               * The following section has been added to fix bugs in INPUT
[3421]               * ACCEPT, and LINPUT statements.
[3422]               ***********************************************************
[3423] 97E6 CA,42,80 BUG01  CHE  >80,@CHAT         Make sure of variable name
[3424] 97E9 61,09           BS   ERRSYN
[3425] 97EB 0F,7A           XML  SYM               Get the information of the
[3426] 97ED 0F,7B           XML  SMB                variable.
[3427] 97EF 00              RTN
[3428]               ***********************************************************
[3429]               * GKXB CODE HERE
[3430] 97F0 BC,4C,42 GTLENG ST   @CHAT,@FAC+2      Moved from LIST routine
[3431] 97F3 BC,E0,08        ST   @XSTLN,V@8(@PABPTR) Store length
       97F6 04,64
[3432] 97F8 00              RTN                       and return
[3433]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0061 
FLMGR-359
[3434]               * RXB ROUTINT TO NOT ALLOW ACCEPT IN EDIT MODE
[3435] 97F9 8E,44    ACCPMM  CZ   @PRGFLG         * EDIT MODE?
[3436] 97FB 49,6E            BR   ACCEP2          * No, program mode return
[3437] 97FD 0F,83            XML  SCROLL          * Scroll screen for error
[3438] 97FF 06,6A,84         CALL ERRZZ           * If imperative - error
[3439] 9802 1B               BYTE 27              * Only legal in a program
[3440]               ***********************************************************
[3441] 9803 D7,E0,02 CIV254 DCEQ >4956,V@2(@PGMPTR) * IV?
       9806 2C,49,56
[3442] 9809 41,09           BR   ERRSYN
[3443] 980B D7,E0,04        DCEQ >3235,V@4(@PGMPTR) * 25?
       980E 2C,32,35
[3444] 9811 41,09           BR   ERRSYN
[3445] 9813 D6,E0,06        CEQ  >34,V@6(@PGMPTR)   * 4?
       9816 2C,34
[3446] 9818 41,09           BR   ERRSYN
[3447] 981A 8E,80,84        CZ   @RAMTOP
[3448] 981D 6E,2B           BS   SAZ1  
[3449] 981F BD,02,80        DST  @RAMTOP,@MNUM     Top of memory in ERAM
       9822 84
[3450] 9823 A5,02,30        DSUB @STLN,@MNUM       Last line of program 
[3451] 9826 91,02           DINC @MNUM             # of bytes total in ERAM
[3452] 9828 CB,02,01        DCHE 288,@MNUM         * 302 bytes
       982B 20
[3453] 982C 6E,BA           BS   GSAVE             * IV254 FORMAT 
[3454] 982E 4E,2B           BR   SAZ1              * PROGRAM FORMAT
[3455]               ***********************************************************
[3456]                      END

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0062 
FLMGR-359
Symbol Table #1 (New,alpha)  
834C AAA        8302 AAA1       00CB ABSZ       896E ACCEP2     896B ACCEPT     
00A4 ACCEPZ     85E5 ACCNM      97F9 ACCPMM     8A47 ACCPZ1     8A8F ACCPZ2     
8ACB ACCPZ3     8B36 ACCPZ4     8A7C ACCPZ5     8B2A ACCPZ6     8A74 ACCPZ7     
8AFC ACCPZ8     8A4F ACCPZ9     03B7 ACCTRY     8302 ACCUM      03AE ACCVRA     
03AC ACCVRW     00EC ALLZ       00BB ANDZ       00F9 APPENZ     835D ARG1       
8367 ARG11      836B ARG15      836C ARG16      835E ARG2       835F ARG3       
8360 ARG4       8361 ARG5       8362 ARG6       8363 ARG7       8364 ARG8       
00DC ASCZ       007C ASSGNV     00CC ATNZ       0022 ATNZZ      00F0 ATZ        
0394 AUTTMP     8A86 AZ1        0008 BACK       8343 BASE       00F1 BASEZ      
8350 BBB        830C BBB1       00EE BEEPZ      0020 BKGD       0002 BREAK      
008E BREAKZ     0006 BUF        038E BUFEND     8346 BUFLEV     038C BUFSRT     
97E6 BUG01      830C BYTES      0010 CALDSR     830A CALIST     009D CALLZ      
834E CCC        8308 CCC1       8308 CCPADD     8308 CCPADR     8306 CCPPTR     
976E CDSR       9796 CDSRZ0     0012 CFI        0018 CHAR2Z     004A CHAR3Z     
8342 CHAT       810D CHECK      935F CHKCNV     9374 CHKCON     95B0 CHKEND     
9358 CHKFN      937E CHKFZ1     92EF CHKNUM     809F CHKPAR     9718 CHKREC     
8834 CHKRM      971B CHKRZ0     9736 CHKRZ1     8328 CHKSEP     9326 CHKSTR     
9332 CHKSZ0     000D CHRTN      00D6 CHRZZ      830E CHSAV      0080 CIF        
00C5 CIRCUZ     9803 CIV254     8196 CLOSE      00A0 CLOSEZ     81C7 CLOSZ1     
80FB CLRFRE     0007 CLRLN      81F4 CLSALL     81E1 CLSAZ0     81E9 CLSLBL     
0009 CNT        94BB CNVDEF     94C4 CNVDZ0     0004 COD        00B5 COLONZ     
002C COMMA      00B3 COMMAZ     961D COMMOD     0070 COMPCT     00B8 CONCZ      
03BB CONFLG     82C9 CONPRT     0075 CONT       0081 CONTIN     A012 CONV1      
00CD COSZ       03BC CPTEMP     A040 CPUBAS     0820 CRNBUF     08BE CRNEND     
007F CRUNCH     0390 CSNTMP     03BA CSNTP1     0002 CSTRIN     92E1 CTMPST     
92D0 CTSTR      92D4 CTSTR0     830E CURINC     8314 CURLIN     007E CURSOR     
0001 CZCLOS     0007 CZDELE     0005 CZLOAD     0000 CZOPEN     0002 CZREAD     
0004 CZREST     0006 CZSAVE     0008 CZSCR      0009 CZSTAT     0003 CZWRIT     
8334 DATA       A008 DATAST     0093 DATAZ      934E DATEND     8354 DDD1       
0089 DEFZ       817C DELET      0099 DELETZ     93A9 DELPAB     9443 DELPZ1     
944F DELPZ2     0087 DELREP     8306 DFLTLM     00E9 DIGITZ     008A DIMZ       
94F2 DISACC     8257 DISPL1     00A2 DISPLZ     94F5 DISPZ1     00C4 DIVIZ      
0003 DLETE      0024 DOLLAR     000A DOWN       8317 DSRFLG     000A DWNARR     
007F EDGECH     6032 EDITLN     8350 EEE        8358 EEE1       0081 ELSEZ      
9341 EMPSTR     02FE ENDSCR     008B ENDZ       8332 ENLN       91E1 EOF        
9215 EOFZ2      8395 EOLEX      00BE EQUALZ     00EF ERASEZ     837C ERCODE     
97CE ERRBV      8322 ERRCOD     97D6 ERRDAT     97DA ERRFE      97C6 ERRIM      
97D2 ERRINP     97BE ERRIO      038A ERRLN      97CA ERRMEM     97E2 ERRMUV     
00A5 ERRORZ     97DE ERRPV      97C2 ERRSNM     8109 ERRSYN     979A ERRZ2      
9797 ERRZ2B     6A84 ERRZZ      8376 EXPZ       00CE EXPZZ      832E EXTRAM     
834B FAC1       8354 FAC10      8355 FAC11      8356 FAC12      8357 FAC13      
8358 FAC14      8359 FAC15      835A FAC16      835B FAC17      834C FAC2       
834D FAC3       834E FAC4       834F FAC5       8350 FAC6       8351 FAC7       
8352 FAC8       8353 FAC9       834E FFF        8356 FFF1       0002 FIL        
0001 FILSPC     8120 FILZZ      00FA FIXEDZ     8345 FLAG       0005 FLG        
9219 FLOAT1     8317 FNUM       8317 FORNET     0009 FORW       008C FORZ       
8340 FREPTR     8125 G8125      8127 G8127      8131 G8131      8157 G8157      
815A G815A      8165 G8165      8169 G8169      81B8 G81B8      81DD G81DD      
8233 G8233      824E G824E      8288 G8288      8293 G8293      82BE G82BE      
82EC G82EC      830D G830D      834F G834F      83A1 G83A1      83B1 G83B1      
83BB G83BB      83C3 G83C3      8423 G8423      842E G842E      8430 G8430      
8438 G8438      8448 G8448      8460 G8460      8463 G8463      84A2 G84A2      
84C3 G84C3      84DB G84DB      851B G851B      8527 G8527      8540 G8540      
8562 G8562      8570 G8570      857C G857C      8581 G8581      8596 G8596      
85A4 G85A4      85B1 G85B1      860B G860B      861E G861E      8643 G8643      
8650 G8650      8661 G8661      867C G867C      867E G867E      86AB G86AB      
86AD G86AD      86C6 G86C6      86DB G86DB      872E G872E      873A G873A      
8752 G8752      875A G875A      8786 G8786      87CF G87CF      87E6 G87E6      
87EA G87EA      880F G880F      8840 G8840      885C G885C      887B G887B      
8885 G8885      8893 G8893      88AF G88AF      88BF G88BF      88D8 G88D8      
88DC G88DC      88E1 G88E1      890B G890B      8941 G8941      895A G895A      
898B G898B      89AA G89AA      89C0 G89C0      89E0 G89E0      89F3 G89F3      
89FD G89FD      8A13 G8A13      8A23 G8A23      8A33 G8A33      8A35 G8A35      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0063 
FLMGR-359
8A58 G8A58      8A66 G8A66      8A9E G8A9E      8AB2 G8AB2      8AB7 G8AB7      
8AC4 G8AC4      8AC8 G8AC8      8ADC G8ADC      8AEB G8AEB      8B0A G8B0A      
8B20 G8B20      8B38 G8B38      8B6B G8B6B      8B73 G8B73      8B8F G8B8F      
8BB3 G8BB3      8C15 G8C15      8C17 G8C17      8CBD G8CBD      8CBF G8CBF      
8CE9 G8CE9      8D6F G8D6F      8D7E G8D7E      8DAB G8DAB      8DAF G8DAF      
8DF4 G8DF4      8E33 G8E33      8E42 G8E42      8E94 G8E91      8EB0 G8EAD      
8EFE G8EFB      8F1F G8F1C      8F8B G8F88      8FB9 G8FB6      8FD0 G8FCD      
902D G902A      9097 G9094      909B G9098      90A9 G90A6      90B1 G90AE      
90CD G90CA      912B G9128      9130 G912D      9135 G9132      913B G9138      
9143 G9140      9159 G9156      9170 G916D      91BA G91B7      91BE G91BB      
9213 G9210      9245 G9242      9278 G9275      9287 G9284      92A5 G92A2      
92B5 G92B2      92B9 G92B6      92EE G92EB      9306 G9303      9317 G9314      
9323 G9320      934B G9348      9392 G938F      93A8 G93A5      93C5 G93C2      
93D1 G93CE      93E3 G93E0      93E9 G93E6      93F7 G93F4      93FA G93F7      
9403 G9400      9414 G9411      941B G9418      942F G942C      9434 G9431      
9454 G9451      946E G946B      9486 G9483      9498 G9495      949E G949B      
94B7 G94B4      94F1 G94EE      9516 G9513      951B G9518      952C G9529      
9574 G9571      9592 G958F      95A3 G95A0      95BA G95B7      95BC G95B9      
95D8 G95D5      95DF G95DC      95FF G95FC      9627 G9624      9652 G964F      
96D6 G96D3      96E5 G96E2      9714 G9711      9733 G9730      9741 G973E      
9754 G9751      97AC G97A9      97BB G97B8      008E GDTECT     930B GETDAT     
9307 GETGFL     930F GETRAM     0071 GETSTR     928D GETVAR     9295 GETVZ0     
929E GETVZ1     92CF GETVZ2     0087 GOSUBZ     0086 GOTOZ      0085 GOZ        
9238 GPNAME     0085 GREAD      008C GREAD1     00C0 GREATZ     917C GRMLST     
91A7 GRSUB2     91BF GRSUB3     91AD GRSUB4     8F47 GSAV1      8EBA GSAVE      
97F0 GTLENG     7A06 GTLIST     8F4D GVMOV      008B GVWITE     0086 GWRITE     
6036 GWSUB      8370 HIVDP      0084 IFZ        00A3 IMAGEZ     9742 INITKB     
6014 INITPG     96CB INITZ1     85F0 INPUT      03AA INPUTP     0092 INPUTZ     
892D INPUZ2     876B INPUZ3     8790 INPUZ4     87B4 INPUZ5     87D4 INPUZ6     
8822 INPUZ7     8768 INPZ2      86CC INPZ3      86E9 INPZ31     8728 INPZ32     
8765 INPZ33     8927 INPZ37     8936 INPZ39     87F6 INPZ65     8818 INPZ67     
0004 INSRT      88E8 INSU1      8906 INSUB1     893B INSUB2     00F5 INTERZ     
9757 INTKB0     8338 INTRIN     861B INTRZ0     862D INTRZ1     869F INTRZ2     
00CF INTZ       0084 IO         9761 IOCALL     9768 IOCLZ1     833C IOSTRT     
8374 KEYBD      6022 KILSYM     0008 LEN        00D5 LENZ       00BF LESSZ      
A006 LINE       885F LINP10     8841 LINPUT     00AA LINPUZ     8312 LINUM      
906B LIST       0002 LISTZ      9090 LISTZ0     90FE LISTZ1     9151 LISTZ3     
9162 LISTZ4     914E LISTZ5     A002 LITS05     6A74 LLIST      8336 LNBUF      
00C9 LNZ        0371 LODFLG     00D0 LOGZ       00B7 LPARZ      8EB4 LRTOPL     
8D32 LRTOPZ     8348 LSUBP      00DF MAXZ       0072 MEMCHK     9005 MERGE      
0008 MERGEZ     905E MERGZ1     002D MINUS      00C2 MINUSZ     00E0 MINZ       
8302 MNUM       837A MOTION     039E MRGPAB     00C3 MULTZ      0088 MVDN       
0089 MVUP       03BE NEWTOP     0096 NEXTZ      000D NLEN       02E2 NLNADD     
8314 NMLEN      830C NMPTR      0374 NOTONE     00BD NOTZ       8328 NUDTAB     
00FD NUMBEZ     0000 NUMBR      00C8 NUMCOZ     00E8 NUMERZ     00C8 NUMZ       
95BD NXTCHR     95CC NXTCZ0     0060 OFFSET     0003 OFS        8BC4 OLD        
8BCA OLD1       821F OLDCD      8227 OLDCZ0     823A OLDCZ1     8D2D OLDER      
03BC OLDTOP     0005 OLDZ       8D8E OLDZ2      8C63 OLDZ3      8C32 OLDZ5      
8C5A OLDZ7      8D16 OLDZ9      8CDE OLDZZ      009B ONZ        8032 OPEN       
009F OPENZ      8106 OPERR      8317 OPTFLG     8045 OPTION     009E OPTIOZ     
8047 OPTIZ0     804C OPTIZ1     8072 OPTZ0      80BE OPTZ01     807C OPTZ02     
80E5 OPTZ03     8081 OPTZ1      80A8 OPTZ2      80AD OPTZ3      80B7 OPTZ4      
80C3 OPTZ5      80DB OPTZ55     80EA OPTZ6      80F4 OPTZ7      00BA ORZ        
9711 OSTRNG     8308 OTHEZ0     8303 OTHEZ1     9393 OUTEOF     00F7 OUTPUZ     
96A8 OUTREC     9173 PAB        8FFC PAB1       8D24 PAB3       000E PABLEN     
8304 PABPTR     965D PARFN      94C5 PARREC     0074 PARSE      00FB PERMAZ     
0079 PGMCHR     832C PGMPTR     00DD PIZ        00C1 PLUSZ      03A0 PMEM       
00D9 POSZ       8377 PRCOL      83A4 PREXIT     8344 PRGFLG     96F8 PRINIT     
8266 PRINT      009C PRINTZ     82B1 PRINZ0     82C4 PRINZ1     82A5 PRNZ10     
837A PRSEM      8381 PRSMZ1     832D PRTAB      835C PRTCOM     83CE PRTNFN     
9704 PRZZ0      03B7 PSCFG      0022 QUOTE      8389 RAMFLG     8386 RAMFRE     
830A RAMPTR     8384 RAMTOP     8378 RANDOM     0095 RANDOZ     8B3A READ       
6A86 READL1     6A76 READLN     0097 READZ      0006 RECALL     08C0 RECBUF     
8827 RECENT     8307 RECLEN     00DE RECZ       00F4 RELATZ     8D36 RELOCA     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0064 
FLMGR-359
8DB3 RELOZ1     009A REMZ       0006 RESEQZ     81FC RESTOR     0094 RESTOZ     
0088 RETURZ     8375 RKEY       00D7 RNDZ       000A RNM        00B6 RPARZ      
00E1 RPTZZ      8388 RSTK       960E RSTRING    938F RTC        8326 RTNG       
00A9 RUNZ       03B9 SAPROT     8DB8 SAVE       0388 SAVEVP     0007 SAVEZ      
8F79 SAVMG      8E2B SAZ1       0384 SBUFLV     007D SCHSYM     008F SCNSMT     
000C SCR        02E0 SCRNBS     96CF SCRO       0083 SCROLL     883A SCRZ       
8B99 SEARCH     0003 SEETWO     00D8 SEGZZ      00B4 SEMICZ     00F6 SEQUEZ     
89A2 SETVW      0386 SEXTRM     0398 SFLAG      00D1 SGNZZ      00D2 SINZ       
03B4 SIZCCP     95E2 SIZE1      00EB SIZEZ      03B6 SIZREC     03B8 SIZXPT     
0396 SLSUBP     007B SMB        831E SMTSRT     0020 SPACE      007E SPEED      
0382 SPGMPT     00D3 SQRZ       8B96 SRDATA     8BBD SRDAZ0     8BB5 SRDAZ1     
831C SREF       0082 SSEPZ      039A SSTEMP     039C SSTMP2     8372 STACK      
830A STADDR     0372 START      00B2 STEPZ      83BD STKMAX     83AF STKMIN     
8330 STLN       0098 STOPZ      8302 STPT       831A STREND     00C7 STRINZ     
8318 STRSP      0065 STRVAL     00DB STRZZ      8324 STVSPT     9221 SUBEOF     
00A8 SUBNDZ     91CD SUBREC     833A SUBTAB     00A7 SUBXTZ     00A1 SUBZ       
007A SYM        0376 SYMBOL     833E SYMTAB     0000 SYNCHK     0392 TABSAV     
00FC TABZ       00D4 TANZ       8366 TEMP5      00B0 THENZ      8379 TIMER      
0034 TONE1      0036 TONE2      6030 TOPL02     601A TOPL10     6012 TOPL15     
8310 TOPSTK     00B1 TOZ        0090 TRACEZ     0083 TREMZ      83C5 TSTINT     
962A TSTSEP     9634 TSTSZ0     965C TSTSZ1     00EA UALPHZ     A020 UBSUB      
008F UNBREZ     00C8 UNQSTZ     0091 UNTRAZ     000B UPARR      00F8 UPDATZ     
000B UPMV       83CF USING      00ED USINGZ     8452 USNGZ0     845E USNGZ1     
8478 USNGZ3     8493 USNGZ4     8533 USNGZ5     85C3 USNGZ9     84E9 USNZ42     
8564 USNZ55     85AA USNZ67     85BE USNZ68     85D3 USNZ95     00DA VAL        
A016 VALCD      03B2 VALIDL     03B0 VALIDP     00FE VALIDZ     8300 VAR0       
8301 VAR1       830E VAR4       8310 VAR5       8311 VAR6       8316 VAR9       
832A VARA       8308 VARC       00F3 VARIAZ     8320 VARW       8304 VARY       
8306 VARY2      837B VDPSTS     008A VGWITE     89C4 VLIDZ0     0078 VPOP       
0077 VPUSH      0958 VRAMVS     03C0 VROAZ      8E6C VSAVZ      001C VWIDTH     
00A6 WARNZ      6A82 WARNZZ     87BB WRNINP     97B6 WRNIO      822C WRNNPP     
8AF8 WRNSNM     87BF WRZZ5      0073 XCNS       8316 XFLAG      00BC XORZ       
8364 XSTLN      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0065 
FLMGR-359
Symbol Table #2 (New,value)  
0000 CZOPEN     0000 NUMBR      0000 SYNCHK     0001 CZCLOS     0001 FILSPC     
0002 BREAK      0002 CSTRIN     0002 CZREAD     0002 FIL        0002 LISTZ      
0003 CZWRIT     0003 DLETE      0003 OFS        0003 SEETWO     0004 COD        
0004 CZREST     0004 INSRT      0005 CZLOAD     0005 FLG        0005 OLDZ       
0006 BUF        0006 CZSAVE     0006 RECALL     0006 RESEQZ     0007 CLRLN      
0007 CZDELE     0007 SAVEZ      0008 BACK       0008 CZSCR      0008 LEN        
0008 MERGEZ     0009 CNT        0009 CZSTAT     0009 FORW       000A DOWN       
000A DWNARR     000A RNM        000B UPARR      000B UPMV       000C SCR        
000D CHRTN      000D NLEN       000E PABLEN     0010 CALDSR     0012 CFI        
0018 CHAR2Z     001C VWIDTH     0020 BKGD       0020 SPACE      0022 ATNZZ      
0022 QUOTE      0024 DOLLAR     002C COMMA      002D MINUS      0034 TONE1      
0036 TONE2      004A CHAR3Z     0060 OFFSET     0065 STRVAL     0070 COMPCT     
0071 GETSTR     0072 MEMCHK     0073 XCNS       0074 PARSE      0075 CONT       
0077 VPUSH      0078 VPOP       0079 PGMCHR     007A SYM        007B SMB        
007C ASSGNV     007D SCHSYM     007E CURSOR     007E SPEED      007F CRUNCH     
007F EDGECH     0080 CIF        0081 CONTIN     0081 ELSEZ      0082 SSEPZ      
0083 SCROLL     0083 TREMZ      0084 IFZ        0084 IO         0085 GOZ        
0085 GREAD      0086 GOTOZ      0086 GWRITE     0087 DELREP     0087 GOSUBZ     
0088 MVDN       0088 RETURZ     0089 DEFZ       0089 MVUP       008A DIMZ       
008A VGWITE     008B ENDZ       008B GVWITE     008C FORZ       008C GREAD1     
008E BREAKZ     008E GDTECT     008F SCNSMT     008F UNBREZ     0090 TRACEZ     
0091 UNTRAZ     0092 INPUTZ     0093 DATAZ      0094 RESTOZ     0095 RANDOZ     
0096 NEXTZ      0097 READZ      0098 STOPZ      0099 DELETZ     009A REMZ       
009B ONZ        009C PRINTZ     009D CALLZ      009E OPTIOZ     009F OPENZ      
00A0 CLOSEZ     00A1 SUBZ       00A2 DISPLZ     00A3 IMAGEZ     00A4 ACCEPZ     
00A5 ERRORZ     00A6 WARNZ      00A7 SUBXTZ     00A8 SUBNDZ     00A9 RUNZ       
00AA LINPUZ     00B0 THENZ      00B1 TOZ        00B2 STEPZ      00B3 COMMAZ     
00B4 SEMICZ     00B5 COLONZ     00B6 RPARZ      00B7 LPARZ      00B8 CONCZ      
00BA ORZ        00BB ANDZ       00BC XORZ       00BD NOTZ       00BE EQUALZ     
00BF LESSZ      00C0 GREATZ     00C1 PLUSZ      00C2 MINUSZ     00C3 MULTZ      
00C4 DIVIZ      00C5 CIRCUZ     00C7 STRINZ     00C8 NUMCOZ     00C8 NUMZ       
00C8 UNQSTZ     00C9 LNZ        00CB ABSZ       00CC ATNZ       00CD COSZ       
00CE EXPZZ      00CF INTZ       00D0 LOGZ       00D1 SGNZZ      00D2 SINZ       
00D3 SQRZ       00D4 TANZ       00D5 LENZ       00D6 CHRZZ      00D7 RNDZ       
00D8 SEGZZ      00D9 POSZ       00DA VAL        00DB STRZZ      00DC ASCZ       
00DD PIZ        00DE RECZ       00DF MAXZ       00E0 MINZ       00E1 RPTZZ      
00E8 NUMERZ     00E9 DIGITZ     00EA UALPHZ     00EB SIZEZ      00EC ALLZ       
00ED USINGZ     00EE BEEPZ      00EF ERASEZ     00F0 ATZ        00F1 BASEZ      
00F3 VARIAZ     00F4 RELATZ     00F5 INTERZ     00F6 SEQUEZ     00F7 OUTPUZ     
00F8 UPDATZ     00F9 APPENZ     00FA FIXEDZ     00FB PERMAZ     00FC TABZ       
00FD NUMBEZ     00FE VALIDZ     02E0 SCRNBS     02E2 NLNADD     02FE ENDSCR     
0371 LODFLG     0372 START      0374 NOTONE     0376 SYMBOL     0382 SPGMPT     
0384 SBUFLV     0386 SEXTRM     0388 SAVEVP     038A ERRLN      038C BUFSRT     
038E BUFEND     0390 CSNTMP     0392 TABSAV     0394 AUTTMP     0396 SLSUBP     
0398 SFLAG      039A SSTEMP     039C SSTMP2     039E MRGPAB     03A0 PMEM       
03AA INPUTP     03AC ACCVRW     03AE ACCVRA     03B0 VALIDP     03B2 VALIDL     
03B4 SIZCCP     03B6 SIZREC     03B7 ACCTRY     03B7 PSCFG      03B8 SIZXPT     
03B9 SAPROT     03BA CSNTP1     03BB CONFLG     03BC CPTEMP     03BC OLDTOP     
03BE NEWTOP     03C0 VROAZ      0820 CRNBUF     08BE CRNEND     08C0 RECBUF     
0958 VRAMVS     6012 TOPL15     6014 INITPG     601A TOPL10     6022 KILSYM     
6030 TOPL02     6032 EDITLN     6036 GWSUB      6A74 LLIST      6A76 READLN     
6A82 WARNZZ     6A84 ERRZZ      6A86 READL1     7A06 GTLIST     8032 OPEN       
8045 OPTION     8047 OPTIZ0     804C OPTIZ1     8072 OPTZ0      807C OPTZ02     
8081 OPTZ1      809F CHKPAR     80A8 OPTZ2      80AD OPTZ3      80B7 OPTZ4      
80BE OPTZ01     80C3 OPTZ5      80DB OPTZ55     80E5 OPTZ03     80EA OPTZ6      
80F4 OPTZ7      80FB CLRFRE     8106 OPERR      8109 ERRSYN     810D CHECK      
8120 FILZZ      8125 G8125      8127 G8127      8131 G8131      8157 G8157      
815A G815A      8165 G8165      8169 G8169      817C DELET      8196 CLOSE      
81B8 G81B8      81C7 CLOSZ1     81DD G81DD      81E1 CLSAZ0     81E9 CLSLBL     
81F4 CLSALL     81FC RESTOR     821F OLDCD      8227 OLDCZ0     822C WRNNPP     
8233 G8233      823A OLDCZ1     824E G824E      8257 DISPL1     8266 PRINT      
8288 G8288      8293 G8293      82A5 PRNZ10     82B1 PRINZ0     82BE G82BE      
82C4 PRINZ1     82C9 CONPRT     82EC G82EC      8300 VAR0       8301 VAR1       

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0066 
FLMGR-359
8302 AAA1       8302 ACCUM      8302 MNUM       8302 STPT       8303 OTHEZ1     
8304 PABPTR     8304 VARY       8306 CCPPTR     8306 DFLTLM     8306 VARY2      
8307 RECLEN     8308 CCC1       8308 CCPADD     8308 CCPADR     8308 OTHEZ0     
8308 VARC       830A CALIST     830A RAMPTR     830A STADDR     830C BBB1       
830C BYTES      830C NMPTR      830D G830D      830E CHSAV      830E CURINC     
830E VAR4       8310 TOPSTK     8310 VAR5       8311 VAR6       8312 LINUM      
8314 CURLIN     8314 NMLEN      8316 VAR9       8316 XFLAG      8317 DSRFLG     
8317 FNUM       8317 FORNET     8317 OPTFLG     8318 STRSP      831A STREND     
831C SREF       831E SMTSRT     8320 VARW       8322 ERRCOD     8324 STVSPT     
8326 RTNG       8328 CHKSEP     8328 NUDTAB     832A VARA       832C PGMPTR     
832D PRTAB      832E EXTRAM     8330 STLN       8332 ENLN       8334 DATA       
8336 LNBUF      8338 INTRIN     833A SUBTAB     833C IOSTRT     833E SYMTAB     
8340 FREPTR     8342 CHAT       8343 BASE       8344 PRGFLG     8345 FLAG       
8346 BUFLEV     8348 LSUBP      834B FAC1       834C AAA        834C FAC2       
834D FAC3       834E CCC        834E FAC4       834E FFF        834F FAC5       
834F G834F      8350 BBB        8350 EEE        8350 FAC6       8351 FAC7       
8352 FAC8       8353 FAC9       8354 DDD1       8354 FAC10      8355 FAC11      
8356 FAC12      8356 FFF1       8357 FAC13      8358 EEE1       8358 FAC14      
8359 FAC15      835A FAC16      835B FAC17      835C PRTCOM     835D ARG1       
835E ARG2       835F ARG3       8360 ARG4       8361 ARG5       8362 ARG6       
8363 ARG7       8364 ARG8       8364 XSTLN      8366 TEMP5      8367 ARG11      
836B ARG15      836C ARG16      8370 HIVDP      8372 STACK      8374 KEYBD      
8375 RKEY       8376 EXPZ       8377 PRCOL      8378 RANDOM     8379 TIMER      
837A MOTION     837A PRSEM      837B VDPSTS     837C ERCODE     8381 PRSMZ1     
8384 RAMTOP     8386 RAMFRE     8388 RSTK       8389 RAMFLG     8395 EOLEX      
83A1 G83A1      83A4 PREXIT     83AF STKMIN     83B1 G83B1      83BB G83BB      
83BD STKMAX     83C3 G83C3      83C5 TSTINT     83CE PRTNFN     83CF USING      
8423 G8423      842E G842E      8430 G8430      8438 G8438      8448 G8448      
8452 USNGZ0     845E USNGZ1     8460 G8460      8463 G8463      8478 USNGZ3     
8493 USNGZ4     84A2 G84A2      84C3 G84C3      84DB G84DB      84E9 USNZ42     
851B G851B      8527 G8527      8533 USNGZ5     8540 G8540      8562 G8562      
8564 USNZ55     8570 G8570      857C G857C      8581 G8581      8596 G8596      
85A4 G85A4      85AA USNZ67     85B1 G85B1      85BE USNZ68     85C3 USNGZ9     
85D3 USNZ95     85E5 ACCNM      85F0 INPUT      860B G860B      861B INTRZ0     
861E G861E      862D INTRZ1     8643 G8643      8650 G8650      8661 G8661      
867C G867C      867E G867E      869F INTRZ2     86AB G86AB      86AD G86AD      
86C6 G86C6      86CC INPZ3      86DB G86DB      86E9 INPZ31     8728 INPZ32     
872E G872E      873A G873A      8752 G8752      875A G875A      8765 INPZ33     
8768 INPZ2      876B INPUZ3     8786 G8786      8790 INPUZ4     87B4 INPUZ5     
87BB WRNINP     87BF WRZZ5      87CF G87CF      87D4 INPUZ6     87E6 G87E6      
87EA G87EA      87F6 INPZ65     880F G880F      8818 INPZ67     8822 INPUZ7     
8827 RECENT     8834 CHKRM      883A SCRZ       8840 G8840      8841 LINPUT     
885C G885C      885F LINP10     887B G887B      8885 G8885      8893 G8893      
88AF G88AF      88BF G88BF      88D8 G88D8      88DC G88DC      88E1 G88E1      
88E8 INSU1      8906 INSUB1     890B G890B      8927 INPZ37     892D INPUZ2     
8936 INPZ39     893B INSUB2     8941 G8941      895A G895A      896B ACCEPT     
896E ACCEP2     898B G898B      89A2 SETVW      89AA G89AA      89C0 G89C0      
89C4 VLIDZ0     89E0 G89E0      89F3 G89F3      89FD G89FD      8A13 G8A13      
8A23 G8A23      8A33 G8A33      8A35 G8A35      8A47 ACCPZ1     8A4F ACCPZ9     
8A58 G8A58      8A66 G8A66      8A74 ACCPZ7     8A7C ACCPZ5     8A86 AZ1        
8A8F ACCPZ2     8A9E G8A9E      8AB2 G8AB2      8AB7 G8AB7      8AC4 G8AC4      
8AC8 G8AC8      8ACB ACCPZ3     8ADC G8ADC      8AEB G8AEB      8AF8 WRNSNM     
8AFC ACCPZ8     8B0A G8B0A      8B20 G8B20      8B2A ACCPZ6     8B36 ACCPZ4     
8B38 G8B38      8B3A READ       8B6B G8B6B      8B73 G8B73      8B8F G8B8F      
8B96 SRDATA     8B99 SEARCH     8BB3 G8BB3      8BB5 SRDAZ1     8BBD SRDAZ0     
8BC4 OLD        8BCA OLD1       8C15 G8C15      8C17 G8C17      8C32 OLDZ5      
8C5A OLDZ7      8C63 OLDZ3      8CBD G8CBD      8CBF G8CBF      8CDE OLDZZ      
8CE9 G8CE9      8D16 OLDZ9      8D24 PAB3       8D2D OLDER      8D32 LRTOPZ     
8D36 RELOCA     8D6F G8D6F      8D7E G8D7E      8D8E OLDZ2      8DAB G8DAB      
8DAF G8DAF      8DB3 RELOZ1     8DB8 SAVE       8DF4 G8DF4      8E2B SAZ1       
8E33 G8E33      8E42 G8E42      8E6C VSAVZ      8E94 G8E91      8EB0 G8EAD      
8EB4 LRTOPL     8EBA GSAVE      8EFE G8EFB      8F1F G8F1C      8F47 GSAV1      
8F4D GVMOV      8F79 SAVMG      8F8B G8F88      8FB9 G8FB6      8FD0 G8FCD      
8FFC PAB1       9005 MERGE      902D G902A      905E MERGZ1     906B LIST       

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0067 
FLMGR-359
9090 LISTZ0     9097 G9094      909B G9098      90A9 G90A6      90B1 G90AE      
90CD G90CA      90FE LISTZ1     912B G9128      9130 G912D      9135 G9132      
913B G9138      9143 G9140      914E LISTZ5     9151 LISTZ3     9159 G9156      
9162 LISTZ4     9170 G916D      9173 PAB        917C GRMLST     91A7 GRSUB2     
91AD GRSUB4     91BA G91B7      91BE G91BB      91BF GRSUB3     91CD SUBREC     
91E1 EOF        9213 G9210      9215 EOFZ2      9219 FLOAT1     9221 SUBEOF     
9238 GPNAME     9245 G9242      9278 G9275      9287 G9284      928D GETVAR     
9295 GETVZ0     929E GETVZ1     92A5 G92A2      92B5 G92B2      92B9 G92B6      
92CF GETVZ2     92D0 CTSTR      92D4 CTSTR0     92E1 CTMPST     92EE G92EB      
92EF CHKNUM     9306 G9303      9307 GETGFL     930B GETDAT     930F GETRAM     
9317 G9314      9323 G9320      9326 CHKSTR     9332 CHKSZ0     9341 EMPSTR     
934B G9348      934E DATEND     9358 CHKFN      935F CHKCNV     9374 CHKCON     
937E CHKFZ1     938F RTC        9392 G938F      9393 OUTEOF     93A8 G93A5      
93A9 DELPAB     93C5 G93C2      93D1 G93CE      93E3 G93E0      93E9 G93E6      
93F7 G93F4      93FA G93F7      9403 G9400      9414 G9411      941B G9418      
942F G942C      9434 G9431      9443 DELPZ1     944F DELPZ2     9454 G9451      
946E G946B      9486 G9483      9498 G9495      949E G949B      94B7 G94B4      
94BB CNVDEF     94C4 CNVDZ0     94C5 PARREC     94F1 G94EE      94F2 DISACC     
94F5 DISPZ1     9516 G9513      951B G9518      952C G9529      9574 G9571      
9592 G958F      95A3 G95A0      95B0 CHKEND     95BA G95B7      95BC G95B9      
95BD NXTCHR     95CC NXTCZ0     95D8 G95D5      95DF G95DC      95E2 SIZE1      
95FF G95FC      960E RSTRING    961D COMMOD     9627 G9624      962A TSTSEP     
9634 TSTSZ0     9652 G964F      965C TSTSZ1     965D PARFN      96A8 OUTREC     
96CB INITZ1     96CF SCRO       96D6 G96D3      96E5 G96E2      96F8 PRINIT     
9704 PRZZ0      9711 OSTRNG     9714 G9711      9718 CHKREC     971B CHKRZ0     
9733 G9730      9736 CHKRZ1     9741 G973E      9742 INITKB     9754 G9751      
9757 INTKB0     9761 IOCALL     9768 IOCLZ1     976E CDSR       9796 CDSRZ0     
9797 ERRZ2B     979A ERRZ2      97AC G97A9      97B6 WRNIO      97BB G97B8      
97BE ERRIO      97C2 ERRSNM     97C6 ERRIM      97CA ERRMEM     97CE ERRBV      
97D2 ERRINP     97D6 ERRDAT     97DA ERRFE      97DE ERRPV      97E2 ERRMUV     
97E6 BUG01      97F0 GTLENG     97F9 ACCPMM     9803 CIV254     A002 LITS05     
A006 LINE       A008 DATAST     A012 CONV1      A016 VALCD      A020 UBSUB      
A040 CPUBAS     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0068 
FLMGR-359
Symbol Table #4 (Def,alpha)  
0034 ACCTON     835C ARG        0032 ATN        0036 BADTON     003B BITREV     
0012 CFI        0014 CNS        002C COS        0010 CSN        8372 DATSTK     
0001 DIVZER     0003 ERRIOV     0006 ERRLOG     0005 ERRNIP     0002 ERRSNN     
0004 ERRSQR     0028 EXP        834A FAC        0006 FADD       000A FCOMP      
0009 FDIV       0008 FMUL       836C FPERAD     0007 FSUB       0038 GETSPACE   
0022 INT        0010 LINK       0018 LOCASE     002A LOG        8370 MEMSIZ     
003D NAMLNK     8300 PAD        0024 PWR        0012 RETURN     000B SADD       
000F SCOMP      000E SDIV       8375 SGN        002E SIN        000D SMUL       
8400 SOUND      0026 SQR        000C SSUB       837C STATUS     0016 STCASE     
8373 SUBSTK     0030 TAN        0007 TRIGER     004A UPCASE     836E VSPTR      
0001 WRNOV      837F XPT        837E YPT        

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0069 
FLMGR-359
Symbol Table #8 (Def,value)  
0001 DIVZER     0001 WRNOV      0002 ERRSNN     0003 ERRIOV     0004 ERRSQR     
0005 ERRNIP     0006 ERRLOG     0006 FADD       0007 FSUB       0007 TRIGER     
0008 FMUL       0009 FDIV       000A FCOMP      000B SADD       000C SSUB       
000D SMUL       000E SDIV       000F SCOMP      0010 CSN        0010 LINK       
0012 CFI        0012 RETURN     0014 CNS        0016 STCASE     0018 LOCASE     
0022 INT        0024 PWR        0026 SQR        0028 EXP        002A LOG        
002C COS        002E SIN        0030 TAN        0032 ATN        0034 ACCTON     
0036 BADTON     0038 GETSPACE   003B BITREV     003D NAMLNK     004A UPCASE     
8300 PAD        834A FAC        835C ARG        836C FPERAD     836E VSPTR      
8370 MEMSIZ     8372 DATSTK     8373 SUBSTK     8375 SGN        837C STATUS     
837E YPT        837F XPT        8400 SOUND      
