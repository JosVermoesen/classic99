99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0001 
Version 2.0 (Weiand 1985)     Options : LCSFPF#########                         
[0001]               ***********************************************************
[0002]                      TITL 'RXB 2024'
[0003]               ***********************************************************
[0004]                      GROM >A000
[0005]               ***********************************************************
[0006]               *           GROM ADDRESSES
[0007]               ***********************************************************
[0008]               *    EQUATES FOR ROUTINES FROM OTHER GROM SECTIONS
[0009]               * GROM >0000
[0010]               * LINK    EQU  >0010          GPLDSRLNK
[0011]               * RETURN  EQU  >0012          Return to GPL inderpeter
[0012]               * STCASE  EQU  >0016          Standard Case
[0013] 0022          GRINT  EQU  >0022             Greatest integer
[0014]               * ACCTON  EQU  >0034          ACCEPT TONE
[0015]               * BADTON  EQU  >0036          HONK TONE
[0016]               * UPCASE  EQU  >004A          Upper Case  
[0017]               * GROM >6000 EQUATES
[0018] 6016          SPRINT EQU  >6016             Initialize sprites
[0019] 6018          CHRTBL EQU  >6018             RXB CALL CHRTBL load char set
[0020] 601C          CHRTAB EQU  >601C             Load default character set
[0021] 601E          SZRUN  EQU  >601E
[0022] 6034          GRSUB1 EQU  >6034             Read data (2 bytes) from ERAM
[0023] 6036          GWSUB  EQU  >6036             Write a few bytes of data to
[0024] 6372          TOPLEV EQU  >6372             RXB CALL USER branch
[0025] 6A78          CHKEND EQU  >6A78             Check end of statement
[0026] 6A7C          DISO   EQU  >6A7C
[0027] 6A7E          ENTER  EQU  >6A7E
[0028] 6A80          ENT09  EQU  >6A80
[0029] 6A82          WARNZZ EQU  >6A82             WARNING MESSAGE ROUTINE
[0030] 6A84          ERRZZ  EQU  >6A84             ERROR MESSAGE ROUTINE
[0031] 63A5          SZNEW  EQU  >63A5             RXB CALL NEW branch
[0032] 63DD          TOPL15 EQU  >63DD             RXB CALL USER branch
[0033]               * GROM >8000
[0034] 8000          DISPL1 EQU  >8000
[0035] 8002          DELET  EQU  >8002
[0036] 8004          PRINT  EQU  >8004
[0037] 8006          INPUT  EQU  >8006
[0038] 8008          OPEN   EQU  >8008
[0039] 800A          CLOSE  EQU  >800A
[0040] 800C          RESTOR EQU  >800C
[0041] 800E          NREAD  EQU  >800E
[0042] 8012          CLSALL EQU  >8012             RXB branch
[0043] 801C          EOF    EQU  >801C
[0044] 801E          ACCEPT EQU  >801E
[0045] 8020          SRDATA EQU  >8020
[0046] 8022          REC    EQU  >8022
[0047] 802C          GRSUB2 EQU  >802C
[0048] 802E          GRSUB3 EQU  >802E
[0049] 8030          LINPUT EQU  >8030
[0050]               * CHARS  EQU  >9CEA             RXB Character Definitions
[0051]               * GROM >E000
[0052] E025          GE025  EQU  >E025             RXB branch EA module
[0053]               ***********************************************************
[0054]               *    Equates for XMLs
[0055] 0000          SYNCHK EQU  >00               SYNCHK XML selector
[0056] 0001          PARCOM EQU  >01               PARse to a COMma selector
[0057] 0002          RANGE  EQU  >02               RANGE selector
[0058]               * FADD   EQU  >06               Floating ADD *RXB RND*
[0059] 0008          FMUL   EQU  >08               Floating MULtiply
[0060] 0009          FDIV   EQU  >09               Floating DIVide
[0061] 000A          FCOMP  EQU  >0A               Floating COMPare
[0062]               * SADD   EQU  >0B               Stack ADD *RXB RND*
[0063] 000C          SSUB   EQU  >0C               Stack SUBtract
[0064] 0010          CSNUM  EQU  >10               Convert String to Number
[0065] 0012          CFI    EQU  >12               Convert to two byte integer

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0002 
RXB 2024
[0066] 0012          FLTINT EQU  >12               Convert floating to integer
[0067] 0071          GETSTR EQU  >71               SYSTEM GET STRING
[0068] 0073          XBCNS  EQU  >73               Convert number to string
[0069] 0074          PARSE  EQU  >74               Parse a value
[0070] 0075          CONT   EQU  >75               Continue parsing
[0071] 0076          EXECG  EQU  >76               Execute a XB stmt or program
[0072] 0077          VPUSH  EQU  >77               Push on value stack
[0073] 0078          VPOP   EQU  >78               Pop off value stack
[0074] 0079          PGMCHR EQU  >79               GET PROGRAM CHARACTER
[0075] 007A          SYM    EQU  >7A               Find SYMBOL entry
[0076] 007B          SMB    EQU  >7B               Find symbol table entry
[0077] 007C          ASSGNV EQU  >7C               Assign VARIABLE
[0078] 007E          SPEED  EQU  >7E               SPEED UP XML
[0079] 0080          CIF    EQU  >80               Convert INTEGER to FLOATING P
[0080] 0082          RTNB   EQU  >82               Return
[0081] 0083          SCROLL EQU  >83               SCROLL THE SCREEN
[0082] 008B          GVWITE EQU  >8B               WRITE DATA FROM GRAM TO VRAM
[0083] 008C          GREAD1 EQU  >8C               READ DATA FROM ERAM
[0084]               ***********************************************************
[0085]               * RXB XML'S ROM 3
[0086] 0074          HCHAR  EQU  >74               HCHAR ASSEMBLY
[0087] 0075          VCHAR  EQU  >75               VCHAR ASSEMBLY
[0088] 0076          ASCHEX EQU  >76               ASC TO HEX ASSEMBLY
[0089] 0077          HPUT   EQU  >77               HPUT ASSEMBLY
[0090] 0078          VPUT   EQU  >78               VPUT ASSEMBLY 
[0091] 0079          CLEARP EQU  >79               CLEAR PRINT ASSEMBLY
[0092] 007A          HGET   EQU  >7A               HGET ASSEMBLY
[0093] 007B          VGET   EQU  >7B               VGET ASSEMBLY
[0094] 007D          CHAR   EQU  >7D               CHAR ASSEMBLY RESET
[0095] 007F          CHRLDR EQU  >7F               LOAD CHARACTER DEFINITIONS
[0096] 0080          COLLSP EQU  >80               COLLIDE SPRITES
[0097] 0081          DCHAR  EQU  >81               CHARACTER & ALL DEFINITIONS
[0098] 0083          SPSPD5 EQU  >83               SPRITE SPEED UP OF SPNUM5
[0099] 0084          SPDEL  EQU  >84               SPRITE SPEED UP DELSPRITE
[0100]               ***********************************************************
[0101]               *    Temporary workspaces in EDIT
[0102]               * PAD   EQU  >8300            TEMPORARY
[0103] 8300          PTFBSL EQU  >8300            Ptr to 1st byte in SPEAK list
[0104] 8300          PHLEN  EQU  >8300            PHrom data LENgth
[0105] 8301          PAD1   EQU  >8301            TEMPORARY
[0106] 8301          PHRADD EQU  >8301            PHRom ADDress
[0107] 8302          PAD2   EQU  >8302            TEMPORARY
[0108] 8302          ACCUM  EQU  >8302            # OF BYTES ACCUMULATOR (4 BYTE
[0109] 8302          MNUM   EQU  >8302            Ussually a counter
[0110] 8302          PTLBSL EQU  >8302            Ptr to last byte in SPEAK list
[0111] 8303          PAD3   EQU  >8303            TEMPORARY
[0112] 8304          PAD4   EQU  >8304            TEMPORARY
[0113] 8304          VARY   EQU  >8304
[0114] 8304          PTEBSL EQU  >8304            Ptr to end byte in SPEAK list
[0115]               * NOTE: PTEBSL points to the end of the temporary speak lis
[0116]               *       whereas PTLBSL points to the last byte actually use
[0117]               *       i.e.    PTFBSL <= PTLBSL <= PTEBSL
[0118] 8306          VARY2  EQU  >8306            Use in MVDN only
[0119] 8306          CCPPTR EQU  >8306            OFFSET WITHIN RECORED (1)
[0120]               *                             or Pointer to current column
[0121] 8306          PAD6   EQU  >8306            TEMPORARY
[0122] 8306          PTFCIS EQU  >8306            Ptr to 1st character in string
[0123] 8307          PAD7   EQU  >8307
[0124] 8308          PAD8   EQU  >8308
[0125] 8308          PTCCIS EQU  >8308            Ptr to current character in st
[0126] 830A          STADDR EQU  >830A            Start address - usually for co
[0127] 830A          PADA   EQU  >830A            Temporary variable
[0128] 830A          PTLCIS EQU  >830A            Ptr to last character in strin
[0129] 830B          PADB   EQU  >830B

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0003 
RXB 2024
[0130] 830C          BYTES  EQU  >830C            BYTE COUNTER
[0131]               *                             or String length for GETSTR
[0132] 830C          PTFCIP EQU  >830C            Ptr to 1st character in phrase
[0133] 830E          VAR4   EQU  >830E
[0134] 830E          PTCCIP EQU  >830E            Ptr to current character in ph
[0135] 8310          TOPSTK EQU  >8310            Top of data stack pointer
[0136] 8310          PAD10  EQU  >8310
[0137] 8310          VAR5   EQU  >8310            VAR5 through VAR5+3 used in RA
[0138] 8310          PTLCIP EQU  >8310            Ptr to last character in phras
[0139] 8311          VAR6   EQU  >8311
[0140] 8312          PAD12  EQU  >8312
[0141] 8312          PTFBPH EQU  >8312            Ptr to 1st byte in PHrom
[0142] 8312          VAR7   EQU  >8312            Used in CHARLY
[0143] 8312          STRPTR EQU  >8312            RXB PATCH CODE
[0144] 8314          PTCCPH EQU  >8314            Ptr to current byte in PHrom
[0145] 8314          VAR9   EQU  >8314             Used in CHARLY
[0146] 8316          PAD16  EQU  >8316             Used in CHARLY
[0147] 8316          XFLAG  EQU  >8316            SCAN FLAG-BITS USED AS BELOW
[0148] 8316          PTLCPH EQU  >8316            Ptr to last byte in PHrom
[0149] 8317          FNUM   EQU  >8317            Current file number for search
[0150]               ***********************************************************
[0151]               *    Permanent workspace variables
[0152] 831C          SREF   EQU  >831C            Temporary string pointer
[0153] 8320          VARW   EQU  >8320            Screen address (CURSOR)
[0154] 8322          ERRCOD EQU  >8322            Return error code from ALC
[0155] 8324          STVSPT EQU  >8324            Value-stack base
[0156] 8326          RTNG   EQU  >8326            Return vector from 9900 code
[0157] 8328          NUDTAB EQU  >8328            Start of NUD table
[0158] 832C          PGMPTR EQU  >832C            Program text pointer (TOKEN)
[0159] 832E          EXTRAM EQU  >832E            Line number table pointer
[0160] 8330          STLN   EQU  >8330            Start of line number table
[0161] 8332          ENLN   EQU  >8332            End of line number table
[0162] 8334          DATA   EQU  >8334            Data pointer for READ
[0163] 8336          LNBUF  EQU  >8336            Line table pointer for READ
[0164] 833E          SYMTAB EQU  >833E            Symbol table pointer
[0165] 8340          FREPTR EQU  >8340            Free space pointer
[0166] 8342          CHAT   EQU  >8342            Current charater/token
[0167] 8344          PRGFLG EQU  >8344            Program/imperative flag
[0168] 8345          FLAG   EQU  >8345            General 8-bit flag
[0169] 8346          BUFLEV EQU  >8346            Crunch-buffer destruction leve
[0170] 8348          LSUBP  EQU  >8348            Last subprogram block on stack
[0171]               * FAC  EQU  >834A            Floating-point ACcurmulator
[0172] 834A          CCHAR  EQU  >834A            Current character
[0173] 834B          FAC1   EQU  >834B
[0174] 834B          SPLFLG EQU  >834B            SPelL out phrase FLaG
[0175] 834C          FAC2   EQU  >834C
[0176] 834C          TOTTIM EQU  >834C            TOTal wait TIMe
[0177]               * NOTE: DATAD must follow immediately after TOTTIM. The
[0178]               *       routine STDATA is counting on this fact!
[0179] 834D          FAC3   EQU  >834D
[0180] 834D          DATAAD EQU  >834D            Speech DATA ADdress
[0181] 834E          FAC4   EQU  >834E
[0182] 834E          CCC    EQU  >834E
[0183] 834E          FFF    EQU  >834E
[0184] 834F          PTLCIL EQU  >834F            Pointer To Last Character In L
[0185] 8350          FAC6   EQU  >8350
[0186] 8350          EEE    EQU  >8350
[0187] 8351          FAC7   EQU  >8351
[0188] 8351          TIMLEN EQU  >8351             TIMe LENgth of timing charact
[0189] 8352          FAC8   EQU  >8352
[0190] 8353          FAC9   EQU  >8353
[0191] 8354          FAC10  EQU  >8354
[0192] 8354          DDD1   EQU  >8354
[0193] 8354          TEMP1  EQU  >8354            TEMPorary CPU location 1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0004 
RXB 2024
[0194] 8355          FAC11  EQU  >8355
[0195] 8356          FAC12  EQU  >8356
[0196] 8356          FFF1   EQU  >8356
[0197] 8356          TEMP2  EQU  >8356            TEMPorary CPU location 2
[0198] 8358          FAC14  EQU  >8358
[0199] 8358          EEE1   EQU  >8358
[0200] 8358          READ   EQU  >8358            Address of speech peripheral
[0201]               *                             READ byte interface
[0202] 8359          FAC15  EQU  >8359
[0203] 835A          WRITE  EQU  >835A            Address of speech peripheral
[0204]               *                             WRITE byte interface
[0205]               * ARG  EQU  >835C            Floating-point ARGument
[0206] 835D          ARG1   EQU  >835D
[0207] 835D          PHDATA EQU  >835D            PHrom DATA
[0208] 835E          ARG2   EQU  >835E
[0209] 835E          PTCBED EQU  >835E            Ptr To Current Byte Ext Data
[0210] 8360          ARG4   EQU  >8360
[0211] 8360          LENCST EQU  >8360            LEN of Current ext data STring
[0212] 8362          ARG6   EQU  >8362
[0213] 8362          LENWST EQU  >8362            LEN of Whole ext data STring
[0214] 8363          ARG7   EQU  >8363
[0215] 8364          ARG8   EQU  >8364
[0216] 8364          STRLEN EQU  >8364            STRing LENgth
[0217] 8364          TEMP4  EQU  >8364
[0218] 8366          TEMP5  EQU  >8366
[0219]               * NOTE: BYTE1, BYTE2, and BYTE3 must be in consecutive memo
[0220]               *       locations, and in the following order for SPGET to
[0221]               *       work!
[0222] 8366          BYTE1  EQU  >8366            BYTE 1
[0223] 8367          BYTE2  EQU  >8367            BYTE 2
[0224] 8368          BYTE3  EQU  >8368            BYTE 3
[0225] 8368          TEMP6  EQU  >8368
[0226] 8369          SPKSTS EQU  >8369            SPeaK StaTus
[0227]               * FPERAD EQU  >836C          Value stack pointer
[0228]               * VSPTR  EQU  >836E          Value stack pointer
[0229]               ***********************************************************
[0230]               * MEMSIZ EQU  >8370           MEMORY SIZE
[0231]               * DATSTK EQU  >8372           DATA STACK
[0232]               * SUBSTK EQU  >8373           SUBROUTINE STACK
[0233] 8374          KEYBD  EQU  >8374             KEYBOARD SELCTION
[0234] 8375          RKEY   EQU  >8375             KEY CODE
[0235] 8376          JOYY   EQU  >8376             JOYSTICK Y POSITION
[0236] 8377          JOYX   EQU  >8377             JOYSTICK X POSITION
[0237] 8378          RANDOM EQU  >8378             RANDOM NUMBER GENERATOR
[0238] 8379          TIMER  EQU  >8379             TIMING REGISTER
[0239] 837A          NOMSPR EQU  >837A             NUMBER OF MOVING SPRITES
[0240] 837B          VDPSTT EQU  >837B             VDP STATUS REGISTER
[0241]               * STATUS EQU  >837C            GPL STATUS BYTE
[0242] 837C          ERCODE EQU  >837C             STATUS REGISTER
[0243] 837D          CB     EQU  >837D             Character Buffer
[0244]               * YPT    EQU  >837E            Screen Location ROW 
[0245]               * XPT    EQU  >837F            Screen Location COL 
[0246]               ***********************************************************
[0247] 8384          RAMTOP EQU  >8384            Highest address in ERAM
[0248] 8386          RAMFRE EQU  >8386            Free pointer in the ERAM
[0249] 8389          RAMFLG EQU  >8389            ERAM flag
[0250] 83C2          GKFLG  EQU  >83C2  * GKXB flag PEEK/LOAD VDP/GROM/QUIT KEY
[0251] 83CE          PRTNFN EQU  >83CE            Sound - previous tone finished
[0252] 83D4          VDPR1  EQU  >83D4      CONTENTS OF VDP REGISTER 1 (KEYSCAN)
[0253]               ***********************************************************
[0254]               *    VDP addresses
[0255] 02E2          NLNADD EQU  >02E2             New LiNe ADDress
[0256] 0300          SPRSAL EQU  >0300             Sprite attribute list
[0257] 0371          LODFLG EQU  >0371             Auto-boot flag

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0005 
RXB 2024
[0258] 0372          START  EQU  >0372             Line to start execution at
[0259]               * Temporary
[0260] 0376          SYMBOL EQU  >0376             Saved symbol table pointer
[0261] 0378          ONECHR EQU  >0378             Used for CHRZ
[0262] 0379          VRMSND EQU  >0379             Sound blocks
[0263] 0382          SPGMPT EQU  >0382             Saved PGMPTR for continue
[0264] 0384          SBUFLV EQU  >0384             Saved BUFLEV for contiue
[0265] 0386          SEXTRM EQU  >0386             Saved EXTRAM for continue
[0266] 0388          SAVEVP EQU  >0388             Saved VSPRT for continue
[0267] 038A          ERRLN  EQU  >038A             On-error line pointer
[0268] 0390          CSNTMP EQU  >0390             Use as temporary stored place
[0269]               *                          or CSN TEMPORARY FOR FAC12
[0270] 0396          SLSUBP EQU  >0396             Saved LSUBP for continue
[0271] 0398          SFLAG  EQU  >0398             Saved on-warning/break bits
[0272] 03AA          SPNUM  EQU  >03AA             Sprite number temporary
[0273] 03BA          CSNTP1 EQU  >03BA             CSN TEMPORARY FOR FAC10
[0274] 03C0          VROAZ  EQU  >03C0             Temporary roll-out area
[0275] 07FF          SPRVB  EQU  >07FF             Sprite velocity block.
[0276] 0820          CRNBUF EQU  >0820             CRuNch BUFfer address
[0277]               ***********************************************************
[0278]               *    IMMEDITATE VALUES
[0279] 0000          NUMBR  EQU  >00               NUMERIC validate
[0280] 0002          LISTZ  EQU  >02
[0281] 0003          X2     EQU  >03
[0282] 0005          OLDZ   EQU  >05
[0283] 0006          RESEQZ EQU  >06
[0284] 0007          SAVEZ  EQU  >07
[0285] 0008          MERGEZ EQU  >08
[0286] 000A          DWNARR EQU  >0A
[0287] 000B          UPARR  EQU  >0B
[0288] 000D          CHRTN  EQU  >0D
[0289] 0020          BKGD   EQU  >20               BACKGROUND CHARACTER
[0290] 0060          OFFSET EQU  >60               OFFSET FOR VIDEO TABLES
[0291] 0065          STRVAL EQU  >65               Value in accum. is string val
[0292]               ***********************************************************
[0293]               * Editting command equates & keys or symbols
[0294] 0002          BREAK  EQU  >02               Break key
[0295] 0003          DLETE  EQU  >03               Delete key
[0296] 0004          INSRT  EQU  >04               Insert key
[0297] 0006          RECALL EQU  >06               Edit-buffer recall
[0298] 0007          CLRLN  EQU  >07               Clear-line key
[0299] 0008          BACK   EQU  >08               Back-space key
[0300] 0009          FORW   EQU  >09               Forward-space key
[0301] 000A          DOWN   EQU  >0A               Down-arrow key
[0302] 000B          UPMV   EQU  >0B               Up-arrow key
[0303] 001C          VWIDTH EQU  >1C               Screen width (PRINT)
[0304] 0020          SPACE  EQU  >20               Space key
[0305] 0022          QUOTE  EQU  >22               "
[0306] 0023          NUMBER EQU  >23               #
[0307] 0024          DOLLAR EQU  >24               $
[0308] 007E          CURSOR EQU  >1E+OFFSET        CURSOR
[0309] 007F          EDGECH EQU  >1F+OFFSET        EDGE character
[0310] 002B          PLUS   EQU  >2B               +
[0311] 002C          COMMAT EQU  >2C               ,
[0312] 002D          MINUS  EQU  >2D               -
[0313] 002D          HYPEN  EQU  >2D               +
[0314] 002E          PERIOD EQU  >2E               .
[0315] 0030          ZERO   EQU  >30               0
[0316] 0039          NINE   EQU  >39               9
[0317] 003A          COLON  EQU  >3A               :
[0318] 003B          SEMICO EQU  >3B               ;
[0319] 003C          LESS   EQU  >3C               <
[0320] 003E          GREAT  EQU  >3E               >
[0321] 0041          A      EQU  >41               A

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0006 
RXB 2024
[0322] 0046          F      EQU  >46               F
[0323]               ***********************************************************
[0324]               *    BASIC TOKEN TABLE
[0325]               *      EQU  >80               spare token
[0326] 0081          ELSEZ  EQU  >81               ELSE
[0327] 0082          SSEPZ  EQU  >82               ::
[0328] 0083          TREMZ  EQU  >83               $
[0329] 0084          IFZ    EQU  >84               IF
[0330] 0085          GOZ    EQU  >85               GO
[0331] 0086          GOTOZ  EQU  >86               GOTO
[0332] 0087          GOSUBZ EQU  >87               GOSUB
[0333] 0088          RETURZ EQU  >88               RETURN
[0334] 0089          DEFZ   EQU  >89               DEF
[0335] 008A          DIMZ   EQU  >8A               DIM
[0336] 008B          ENDZ   EQU  >8B               END
[0337] 008C          FORZ   EQU  >8C               FOR
[0338] 008D          LETZ   EQU  >8D               LET   
[0339] 008E          BREAKZ EQU  >8E               BREAK
[0340] 008F          UNBREZ EQU  >8F               UNBREAK
[0341] 0090          TRACEZ EQU  >90               TRACE
[0342] 0091          UNTRAZ EQU  >91               UNTRACE
[0343] 0092          INPUTZ EQU  >92               INPUT
[0344] 0093          DATAZ  EQU  >93               DATA
[0345] 0094          RESTOZ EQU  >94               RESTORE
[0346] 0095          RANDOZ EQU  >95               RANDOMIZE
[0347] 0096          NEXTZ  EQU  >96               NEXT
[0348] 0097          READZ  EQU  >97               READ
[0349] 0098          STOPZ  EQU  >98               STOP
[0350] 0099          DELETZ EQU  >99               DELETE
[0351] 009A          REMZ   EQU  >9A               REM
[0352] 009B          ONZ    EQU  >9B               ON
[0353] 009C          PRINTZ EQU  >9C               PRINT
[0354] 009D          CALLZ  EQU  >9D               CALL
[0355] 009E          OPTIOZ EQU  >9E               OPTION
[0356] 009F          OPENZ  EQU  >9F               OPEN
[0357] 00A0          CLOSEZ EQU  >A0               CLOSE
[0358] 00A1          SUBZ   EQU  >A1               SUB
[0359] 00A2          DISPLZ EQU  >A2               DISPLAY
[0360] 00A3          IMAGEZ EQU  >A3               IMAGE
[0361] 00A4          ACCEPZ EQU  >A4               ACCEPT
[0362] 00A5          ERRORZ EQU  >A5               ERROR
[0363] 00A6          WARNZ  EQU  >A6               WARNING
[0364] 00A7          SUBXTZ EQU  >A7               SUBEXIT
[0365] 00A8          SUBNDZ EQU  >A8               SUBEND
[0366] 00A9          RUNZ   EQU  >A9               RUN
[0367] 00AA          LINPUZ EQU  >AA               LINPUT
[0368]               *      EQU  >AB               spare token (LIBRARY)
[0369]               *      EQU  >AC               spare token (REAL)
[0370]               *      EQU  >AD               spare token (INTEGER)
[0371]               *      EQU  >AE               spare token (SCRATCH)
[0372]               *      EQU  >AF               spare token
[0373] 00B0          THENZ  EQU  >B0               THEN
[0374] 00B1          TOZ    EQU  >B1               TO
[0375] 00B2          STEPZ  EQU  >B2               STEP
[0376] 00B3          COMMAZ EQU  >B3               ,
[0377] 00B4          SEMICZ EQU  >B4               ;
[0378] 00B5          COLONZ EQU  >B5               :
[0379] 00B6          RPARZ  EQU  >B6               )
[0380] 00B7          LPARZ  EQU  >B7               (
[0381] 00B8          CONCZ  EQU  >B8               &          (CONCATENATE)
[0382]               *      EQU  >B9               spare token
[0383] 00BA          ORZ    EQU  >BA               OR
[0384] 00BB          ANDZ   EQU  >BB               AND
[0385] 00BC          XORZ   EQU  >BC               XOR

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0007 
RXB 2024
[0386] 00BD          NOTZ   EQU  >BD               NOT
[0387] 00BE          EQUALZ EQU  >BE               =
[0388] 00BF          LESSZ  EQU  >BF               <
[0389] 00C0          GREATZ EQU  >C0               >
[0390] 00C1          PLUSZ  EQU  >C1               +
[0391] 00C2          MINUSZ EQU  >C2               -
[0392] 00C3          MULTZ  EQU  >C3               *
[0393] 00C4          DIVIZ  EQU  >C4               /
[0394] 00C5          CIRCUZ EQU  >C5               ^
[0395]               *      EQU  >C6               spare token
[0396] 00C7          STRINZ EQU  >C7               QUOTED STRING
[0397] 00C8          UNQSTZ EQU  >C8               UNQUOTED STRING
[0398] 00C8          NUMZ   EQU  >C8               ALSO NUMERICAL STRING
[0399] 00C8          NUMCOZ EQU  >C8               ALSO UNQUOTED STRING
[0400] 00C9          LNZ    EQU  >C9               LINE NUMBER CONSTANT
[0401]               *      EQU  >CA               spare token
[0402] 00CB          ABSZ   EQU  >CB               ABS
[0403] 00CC          ATNZ   EQU  >CC               ATN
[0404] 00CD          COSZ   EQU  >CD               COS
[0405] 00CE          EXPZZ  EQU  >CE               EXP
[0406] 00CF          INTZ   EQU  >CF               INT
[0407] 00D0          LOGZ   EQU  >D0               LOG
[0408] 00D1          SGNZZ  EQU  >D1               SGN
[0409] 00D2          SINZ   EQU  >D2               SIN
[0410] 00D3          SQRZ   EQU  >D3               SQR
[0411] 00D4          TANZ   EQU  >D4               TAN
[0412] 00D5          LENZ   EQU  >D5               LEN
[0413] 00D6          CHRZZ  EQU  >D6               CHR$
[0414] 00D7          RNDZ   EQU  >D7               RND
[0415] 00D8          SEGZZ  EQU  >D8               SEG$
[0416] 00D9          POSZ   EQU  >D9               POS
[0417] 00DA          VAL    EQU  >DA               VAL
[0418] 00DB          STRZZ  EQU  >DB               STR$
[0419] 00DC          ASCZ   EQU  >DC               ASC
[0420] 00DD          PIZ    EQU  >DD               PI
[0421] 00DE          RECZ   EQU  >DE               REC
[0422] 00DF          MAXZ   EQU  >DF               MAX
[0423] 00E0          MINZ   EQU  >E0               MIN
[0424] 00E1          RPTZZ  EQU  >E1               RPT$
[0425]               *      EQU  >E2               unused
[0426]               *      EQU  >E2               unused
[0427]               *      EQU  >E3               unused
[0428]               *      EQU  >E4               unused
[0429]               *      EQU  >E5               unused
[0430]               *      EQU  >E6               unused
[0431]               *      EQU  >E7               unused
[0432] 00E8          NUMERZ EQU  >E8               NUMERIC
[0433] 00E9          DIGITZ EQU  >E9               DIGIT
[0434] 00EA          UALPHZ EQU  >EA               UALPHA
[0435] 00EB          SIZEZ  EQU  >EB               SIZE
[0436] 00EC          ALLZ   EQU  >EC               ALL
[0437] 00ED          USINGZ EQU  >ED               USING
[0438] 00EE          BEEPZ  EQU  >EE               BEEP
[0439] 00EF          ERASEZ EQU  >EF               ERASE
[0440] 00F0          ATZ    EQU  >F0               AT
[0441] 00F1          BASEZ  EQU  >F1               BASE
[0442]               *      EQU  >F2               spare token (TEMPORARY)
[0443] 00F3          VARIAZ EQU  >F3               VARIABLE
[0444] 00F4          RELATZ EQU  >F4               RELATIVE
[0445] 00F5          INTERZ EQU  >F5               INTERNAL
[0446] 00F6          SEQUEZ EQU  >F6               SEQUENTIAL
[0447] 00F7          OUTPUZ EQU  >F7               OUTPUT
[0448] 00F8          UPDATZ EQU  >F8               UPDATE
[0449] 00F9          APPENZ EQU  >F9               APPEND

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0008 
RXB 2024
[0450] 00FA          FIXEDZ EQU  >FA               FIXED
[0451] 00FB          PERMAZ EQU  >FB               PERMANENT
[0452] 00FC          TABZ   EQU  >FC               TAB
[0453] 00FD          NUMBEZ EQU  >FD               #
[0454] 00FE          VALIDZ EQU  >FE               VALIDATE
[0455]               *      EQU  >FF               ILLEGAL VALUE
[0456]               ***********************************************************
[0457]               * NOTE: FILES EXECSD, SUBS AND PART OF PSCANS ARE IN GROM 5
[0458]               *       AS BELOW:
[0459]               *-------NAME------------------ADDRESS---------BYTES LEFT---
[0460]               *      EXECS                  >A000 - >AD92        5
[0461]               *      SUBS                   >AD98 - >B4DC        2
[0462]               *      PSCANS                 >B4E0 - >B7FA        5
[0463]               *
[0464]               * Some of the error calls at the end of EXECS file are
[0465]               * shared and directly addressed by SUBS file. Any change in
[0466]               * EXECS file which affects the address of error calls will
[0467]               * affect error reference in SUBS file. Make sure to edit
[0468]               * SUBS file in that situation.
[0469]               ***********************************************************
[0470] A000 0F,75           XML  CONT              XML CONT used by subprogram
[0471] A002 43,3A           BR   LITS05            Build FAC entry and GETSTR
[0472] A004 40,90           BR   EXEC              Execute a program
[0473] A006 48,10           BR   LINE
[0474] A008 47,AB           BR   DATAST
[0475] A00A 47,C7           BR   ASC
[0476] A00C 40,9D           BR   EXEC1
[0477] A00E 41,1F           BR   EXEC6D            Save information on a break
[0478] A010 47,47           BR   DELINK            Delink symbol table entry
[0479] A012 48,22           BR   CONV1
[0480] A014 49,6D           BR   SQUISH            Called in error routine in PS
[0481] A016 44,AE           BR   VALCD
[0482] A018 42,81           BR   INTRND
[0483] A01A 40,1A           BR   $
[0484] A01C 48,82           BR   LNKRTN            Routine to go back to XB prog
[0485] A01E 48,FA           BR   SPCOL             Clear breakpoint in line # ro
[0486] A020 46,39           BR   UBSUB             Spare
[0487] A022 40,22           BR   $
[0488] A024 5D,20    GA024  BR   CASCII            RXB SIZE ADDRESS DISPLAY
[0489]               *                  *** Please let me know it you address to
[0490]               *                  *** branches here since it will advance
[0491]               *                  *** the address of link list. Sum
[0492] A026 A0,30    LINK1  DATA LINK2
[0493] A028 05,53,4F        STRI 'SOUND'           SOUND
       A02B 55,4E,44
[0494] A02E A9,A9           DATA XSOUND
[0495] A030 A0,3A    LINK2  DATA LINK3
[0496] A032 05,43,4C        STRI 'CLEAR'           CLEAR
       A035 45,41,52
[0497] A038 A9,89           DATA CLEARZ
[0498] A03A A0,44    LINK3  DATA LINK4
[0499] A03C 05,43,4F        STRI 'COLOR'           COLOR
       A03F 4C,4F,52
[0500] A042 A8,8E           DATA COLORZ
[0501] A044 A0,4E    LINK4  DATA LINK5
[0502] A046 05,47,43        STRI 'GCHAR'           GCHAR   (ASSEMBLY)
       A049 48,41,52
[0503] A04C A8,37           DATA GCHARZ
[0504] A04E A0,58    LINK5  DATA LINK6
[0505] A050 05,48,43        STRI 'HCHAR'           HCHAR   (ASSEMBLY) 
       A053 48,41,52
[0506] A056 AA,6E           DATA HCHARZ
[0507] A058 A0,62    LINK6  DATA LINK7
[0508] A05A 05,56,43        STRI 'VCHAR'           VCHAR   (ASSEMBLY)

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0009 
RXB 2024
       A05D 48,41,52
[0509] A060 AA,88           DATA VCHARZ
[0510] A062 A0,6B    LINK7  DATA LINK8
[0511] A064 04,43,48        STRI 'CHAR'            CHAR    (ASSEMBLY)
       A067 41,52
[0512] A069 AA,FA           DATA CHARLY
[0513] A06B A0,73    LINK8  DATA LINK9
[0514] A06D 03,4B,45        STRI 'KEY'             KEY
       A070 59
[0515] A071 B8,D1           DATA ZKEY
[0516] A073 A0,7D    LINK9  DATA LINKA
[0517] A075 05,4A,4F        STRI 'JOYST'           JOYST
       A078 59,53,54
[0518] A07B B9,EF           DATA ZJOYST
[0519] A07D A0,88    LINKA  DATA LINKB
[0520] A07F 06,53,43        STRI 'SCREEN'          SCREEN
       A082 52,45,45
       A085 4E
[0521] A086 AB,B8           DATA BORDER
[0522] A088 AC,EF    LINKB  DATA LINKS1
[0523] A08A 03,45,52        STRI 'ERR'             ERR
       A08D 52
[0524] A08E AB,EE           DATA ERRWXY
[0525]               ***********************************************************
[0526]               *        START EXECUTION OF A PROGRAM OR STATEMENT
[0527]               * DATA:
[0528]               *      RAM(START) points into line number table at the
[0529]               *      first line to execute
[0530]               *      @PGMFLG contains >FF if executing a program or zero
[0531]               *      if imperative statement
[0532]               ***********************************************************
[0533] A090 8E,44    EXEC   CZ   @PRGFLG           If program
[0534] A092 60,A2           BS   GA0AE
[0535] A094 BD,2E,A3        DST  V@START,@EXTRAM   Line to start execution at
       A097 72
[0536] A098 95,2E           DINCT @EXTRAM          Pointer to text pointer
[0537] A09A 06,A2,81        CALL INTRND            Initialize random number
[0538] A09D BE,7F,03 EXEC1  ST   X2,@XPT           Initialize screen display
[0539] A0A0 40,A6           BR   GA0B2
[0540] A0A2 BF,2C,08 GA0AE  DST  CRNBUF,@PGMPTR    Executing out of crunch buffe
       A0A5 20
[0541] A0A6 BF,26,A0 GA0B2  DST  EXEC20,@RTNG      Address of return from ALC
       A0A9 B0
[0542] A0AA BF,28,A1        DST  NUDTB,@NUDTAB     NUD table address for ALC
       A0AD 3B
[0543] A0AE 0F,76           XML  EXECG             Execute XB
[0544] A0B0 8A,23    EXEC20 CASE @ERRCOD+1         Check type of return
[0545] A0B2 40,D3           BR   EXECND            0 - NORMAL END
[0546] A0B4 41,0E           BR   EXECBK            1 - BREAKPOINT
[0547] A0B6 40,E1           BR   EXECTR            2 - TRACE
[0548] A0B8 47,E8           BR   ERORZ             3 - ERROR
[0549] A0BA 40,C8           BR   WARNGZ            4 - WARNING
[0550] A0BC 41,CE           BR   ONERR             5 - ON ERROR
[0551] A0BE 46,54           BR   UDF               6 - FUNCTION
[0552] A0C0 42,0C           BR   ONBRK             7 - ON BREAK
[0553] A0C2 43,77           BR   CONCAT            8 - CONCATENATE STRINGS "&"
[0554] A0C4 41,9E           BR   ONWARN            9 - ON WARNING
[0555] A0C6 42,23           BR   GPLCAL            A - CALL STATEMENT
[0556] A0C8 C6,73,B0 WARNGZ CH   >B0,@SUBSTK
[0557] A0CB 6C,BF           BS   ERRSO
[0558]               * Stack overflow
[0559]               *                    ALLOW ROOM ON STACK FOR WARNING CALLS
[0560] A0CD 06,6A,82 WRNN01 CALL WARNZZ        ONLY WARNING MSG FROM XB SUPPORT
[0561] A0D0 02              BYTE 2       *         NUMERIC OVERFLOW

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0010 
RXB 2024
[0562] A0D1 41,0A           BR   CLRRTN            Clear ERRCOD and return
[0563]               *                    NORMAL END OF EXECUTION
[0564] A0D3 8E,44    EXECND CZ   @PRGFLG           If imperative mode
[0565] A0D5 40,DD           BR   ERRRDY
[0566] A0D7 06,60,1C        CALL CHRTAB            Load the default character se
[0567] A0DA 05,63,DD        B    TOPL15            Return to top-level
[0568] A0DD 06,6A,84 ERRRDY CALL ERRZZ             Display * READY *
[0569] A0E0 00              BYTE 0
[0570]               * TRACE-MODE turned on - display line number
[0571] A0E1 86,20    EXECTR CLR  @VARW             Clear upper address byte
[0572] A0E3 BC,21,7F        ST   @XPT,@VARW+1      Get current x-pointer
[0573] A0E6 A3,20,02        DADD NLNADD-3,@VARW    Make a valid screen address
       A0E9 DF
[0574] A0EA C7,20,02        DCH  NLNADD+22,@VARW   If might go off screen
       A0ED F8
[0575] A0EE 40,F6           BR   GA102
[0576] A0F0 0F,83           XML  SCROLL            SCROLL to next line
[0577] A0F2 BF,20,02        DST  NLNADD,@VARW      Re-initialize screen address
       A0F5 E2
[0578] A0F6 BE,B0,20 GA102  ST   LESS+OFFSET,V*VARW Display open bracket "("
       A0F9 9C
[0579] A0FA 91,20           DINC @VARW             Increment screen address
[0580] A0FC 06,A7,C7        CALL ASC               Convert line # into ASCII
[0581] A0FF BE,B0,20        ST   GREAT+OFFSET,V*VARW Display close bracket ")"
       A102 9E
[0582] A103 A7,20,02        DSUB NLNADD-4,@VARW    Update the x-pointer
       A106 DE
[0583] A107 BC,7F,21        ST   @VARW+1,@XPT
[0584] A10A 87,22    CLRRTN DCLR @ERRCOD           Clear the return vector
[0585] A10C 0F,82           XML  RTNB              Return to ALC
[0586]               * BREAKPOINT OR BREAK-KEY RECIEVED
[0587] A10E 8E,44    EXECBK CZ   @PRGFLG           If break or program
[0588] A110 61,37           BS   ERRBRK
[0589] A112 BD,52,2E        DST  @EXTRAM,@FAC8     @FAC8 : Source addr in ERAM
[0590] A115 97,52           DDECT @FAC8            Point to the line #
[0591] A117 06,A6,49        CALL UBSUB1            Reset the breakpoint
[0592] A11A 03              SCAN                   Get break key out of queue
[0593] A11B BD,A3,82 EXEC6C DST  @PGMPTR,V@SPGMPT  Save text pointer
       A11E 2C
[0594] A11F BD,A3,86 EXEC6D DST  @EXTRAM,V@SEXTRM  Save line number table pointe
       A122 2E
[0595] A123 BD,A3,88        DST  @VSPTR,V@SAVEVP   Save value stack pointer
       A126 6E
[0596] A127 BD,A3,84        DST  @BUFLEV,V@SBUFLV  Save crunch buffer level
       A12A 46
[0597] A12B BD,A3,96        DST  @LSUBP,V@SLSUBP   Save last subprogram on stack
       A12E 48
[0598] A12F BC,A3,98        ST   @FLAG,V@SFLAG     Save FLAG for continue
       A132 45
[0599] A133 B2,A3,98        AND  >63,V@SFLAG       Only warning and break bits
       A136 63
[0600] A137 06,6A,84 ERRBRK CALL ERRZZ             * BREAKPOINT
[0601] A13A 01              BYTE 1
[0602]               ***********************************************************
[0603]               *               NUD / STATEMENT BRANCH TABLE
[0604]               ***********************************************************
[0605] A13B 41,7D    NUDTB  BR   RECX              'RECORD'              0
[0606] A13D 45,C8           BR   NBREAK            'BREAK'               0
[0607] A13F 45,DA           BR   NUNBRK            'UNBREAK'             0
[0608] A141 45,BE           BR   NTRACE            'TRACE'               0
[0609] A143 45,C3           BR   NUNTRC            'UNTRACE'             0
[0610] A145 41,80           BR   NREADX            'READ'                0
[0611] A147 41,83           BR   PRINTX            'PRINT'               0
[0612] A149 41,7A           BR   SZRUNX            'RUN'                 0

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0011 
RXB 2024
[0613] A14B 41,9B           BR   LINPUX            Reserved for LINPUT   1
[0614] A14D 41,86           BR   RESTOX            'RESTORE'             1
[0615] A14F 43,15           BR   NRNDMZ            'RANDOMIZE'           1
[0616] A151 41,89           BR   INPUTX            'INPUT'               1
[0617] A153 41,8C           BR   OPENX             'OPEN'                1
[0618] A155 41,8F           BR   CLOSEX            'CLOSE'               1
[0619] A157 42,3C           BR   NPI               'PI'                  1
[0620] A159 42,4C           BR   NMAX              'MAX'                 1
[0621] A15B 42,59           BR   NMIN              'MIN'                 2
[0622] A15D 45,65           BR   RPTZ01            'RPT$'                2
[0623] A15F 41,92           BR   ACCEPX            'ACCEPT'              2
[0624] A161 41,77           BR   EOFX              'EOF'                 2
[0625] A163 44,59           BR   ASC01             'ASC'                 2
[0626] A165 44,FA           BR   POS01             'POS'                 2
[0627] A167 44,94           BR   VAL01             'VAL'                 2
[0628] A169 44,6A           BR   STRZ01            'STR$'                2
[0629] A16B 43,CF           BR   SEGZ01            'SEG$'                3
[0630] A16D 41,98           BR   DELETX            'DELETE'              3
[0631] A16F 41,95           BR   DISPLX            'DISPLAY'             3
[0632] A171 44,32           BR   LEN01             'LEN'                 3
[0633] A173 44,3E           BR   CHRZ01            'CHR$'                3
[0634]               *RXB PATCH CODE FOR BASIC RND REPLACEMENT ***********
[0635] A175 42,87           BR   NRND              'RND'                 3      
[0636]               * The following are long branches to another GROM
[0637] A177 05,80,1C EOFX   B    EOF
[0638] A17A 05,60,1E SZRUNX B    SZRUN
[0639] A17D 05,80,22 RECX   B    REC
[0640] A180 05,80,0E NREADX B    NREAD
[0641] A183 05,80,04 PRINTX B    PRINT
[0642] A186 05,80,0C RESTOX B    RESTOR
[0643] A189 05,80,06 INPUTX B    INPUT
[0644] A18C 05,80,08 OPENX  B    OPEN
[0645] A18F 05,80,0A CLOSEX B    CLOSE
[0646] A192 05,80,1E ACCEPX B    ACCEPT
[0647] A195 05,80,00 DISPLX B    DISPL1
[0648] A198 05,80,02 DELETX B    DELET
[0649] A19B 05,80,30 LINPUX B    LINPUT
[0650]               ***********************************************************
[0651]               * FLAGS USED IN EXECUTION MODE:    this needs to be checked
[0652]               *  @FLAG   BIT   RESET               SET
[0653]               *           0
[0654]               *           1    Warning PRINT       PRINT off
[0655]               *           2    Warning NEXT        STOP
[0656]               *           3    Not in UDF          Executing a UDF
[0657]               *           4    TRACE mode          Normal mode
[0658]               *           5
[0659]               *           6    BREAK allowed       BREAK not allowed
[0660]               *           7    No LST/EDT protect  LIST/EDIT protected
[0661]               ***********************************************************
[0662]               * ON WARNING {NEXT | STOP | PRINT}
[0663]               * ON WARNING NEXT  - Causes warning messages to be ignored
[0664]               *                    and execution to continue as if a
[0665]               *                    warning never occurred
[0666]               * ON WARNING STOP  - Causes a warning to be treated as an
[0667]               *                    error - i.e. the message is displayed
[0668]               *                    and execution is halted
[0669]               * ON WARNING PRINT - Causes the default warning handling to
[0670]               *                    be in effect, i.e. any warning
[0671]               *                    messages are printed and execution
[0672]               *                    continues
[0673]               ***********************************************************
[0674] A19E 0F,79    ONWARN XML  PGMCHR            GET OPTION
[0675] A1A0 D6,42,9C        CEQ  PRINTZ,@CHAT      If print
[0676] A1A3 41,AB           BR   GA1B7

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0012 
RXB 2024
[0677] A1A5 B2,45,F9        AND  >F9,@FLAG         Turn on print and contiue
[0678] A1A8 05,A1,C3        B    ONWRN5
[0679] A1AB D6,42,98 GA1B7  CEQ  STOPZ,@CHAT
[0680] A1AE 41,B8           BR   GA1C4
[0681] A1B0 B2,45,FD        AND  NUMBEZ,@FLAG         Turn on print
[0682] A1B3 B6,45,04        OR   >04,@FLAG         Turn on stop
[0683] A1B6 41,C3           BR   ONWRN5
[0684] A1B8 D6,42,96 GA1C4  CEQ  NEXTZ,@CHAT       * SYNTAX ERROR
[0685] A1BB 4C,AF           BR   ERRSYN
[0686] A1BD B6,45,02        OR   >02,@FLAG         Turn off print
[0687] A1C0 B2,45,FB        AND  >FB,@FLAG         Turn off stop
[0688] A1C3 0F,79    ONWRN5 XML  PGMCHR            Check for EOS
[0689] A1C5 06,6A,78 ONWRN7 CALL CHKEND            Error if not EOS
[0690] A1C8 4C,AF           BR   ERRSYN            If not EOS
[0691] A1CA 87,22           DCLR @ERRCOD
[0692] A1CC 0F,75           XML  CONT              Continue
[0693]               ***********************************************************
[0694]               * ON ERROR {line number | STOP}
[0695]               * ON ERROR line number - causes the error routine to build
[0696]               *                        an error stack entry and pass
[0697]               *                        control to the line specified in
[0698]               *                        the most-recently executed
[0699]               *                        on-error-statement
[0700]               * ON ERROR STOP - causes the default error handling
[0701]               *                 conditions to be in effect. i.e. any
[0702]               *                 errors that occur cause execution to halt
[0703]               *                 an a message to be displayed
[0704]               ***********************************************************
[0705] A1CE 0F,79    ONERR  XML  PGMCHR            Get option
[0706] A1D0 D6,42,C9        CEQ  LNZ,@CHAT         If line # then find the line
[0707] A1D3 42,02           BR   GA20E
[0708] A1D5 0F,79           XML  PGMCHR            Get upper byte
[0709] A1D7 BC,4A,42        ST   @CHAT,@FAC
[0710] A1DA 0F,79           XML  PGMCHR            Get lower byte
[0711] A1DC BC,4B,42        ST   @CHAT,@FAC1
[0712] A1DF BD,4C,32        DST  @ENLN,@FAC2
[0713] A1E2 A7,4C,00        DSUB 3,@FAC2           Pointing to 1st line #
       A1E5 03
[0714]               * Consider both ERAM and RAM cases to get line # from the
[0715]               * line number table. Also reset the break bit.
[0716] A1E6 06,80,2E ONERR2 CALL GRSUB3            Get 2 bytes from either RAM/E
[0717] A1E9 4C              BYTE FAC2            * FAC2 has the address
[0718] A1EA D5,4A,58        DCEQ @EEE1,@FAC        If found
[0719] A1ED 61,FA           BS   ONERR4
[0720] A1EF C5,4C,30        DCH  @STLN,@FAC2       Not found
[0721] A1F2 4C,DB           BR   ERRLNF
[0722] A1F4 A7,4C,00        DSUB 4,@FAC2           Goto next line
       A1F7 04
[0723] A1F8 41,E6           BR   ONERR2
[0724] A1FA 95,4C    ONERR4 DINCT @FAC2
[0725] A1FC BD,A3,8A        DST  @FAC2,V@ERRLN
       A1FF 4C
[0726] A200 42,0A           BR   GA216
[0727] A202 D6,42,98 GA20E  CEQ  STOPZ,@CHAT       * SYNTAX ERROR
[0728] A205 4C,AF           BR   ERRSYN
[0729] A207 87,A3,8A        DCLR V@ERRLN           Back to default error handlin
[0730] A20A 41,C3    GA216  BR   ONWRN5            Finish up same as ON WARNING
[0731]               ***********************************************************
[0732]               * ON BREAK {NEXT | STOP}
[0733]               * ON BREAK NEXT - Causes any breakpoints which have been
[0734]               *                 set on statements to be ignored when the
[0735]               *                 statement is encountered and also masks
[0736]               *                 the shift-C key so that it is ignored
[0737]               * ON BREAK STOP - Causes the default break handling to be

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0013 
RXB 2024
[0738]               *                 in force., i.e. execution is halted and
[0739]               *                 the BREAKPOINT message is displayed on
[0740]               *                 the screen
[0741]               ***********************************************************
[0742] A20C 0F,79    ONBRK  XML  PGMCHR            Get next char to find option
[0743] A20E D6,42,98        CEQ  STOPZ,@CHAT       If stop option specified
[0744] A211 42,19           BR   GA225
[0745] A213 B2,45,BF        AND  >BF,@FLAG         break allowed
[0746] A216 05,A2,21        B    GA22D             Don't change this to BR GA22D
[0747] A219 D6,42,96 GA225  CEQ  NEXTZ,@CHAT       If next option number
[0748] A21C 4C,AF           BR   ERRSYN            specified then syntax error
[0749] A21E B6,45,40        OR   >40,@FLAG         If next option specified then
[0750]               *                              break NOT allowed
[0751] A221 41,C3    GA22D  BR   ONWRN5            Finish up same as ON WARNING
[0752]               ***********************************************************
[0753]               * GPLCAL - If a call is made to a subprogram that does not
[0754]               *  not exist either in the BASIC program itself or in the
[0755]               *  internal GPL subprogram list then one final attempt is
[0756]               *  made to find the subprogram at execution time by
[0757]               *  searching for the subprogram in the console or a
[0758]               *  peripheral. If not found there, then a
[0759]               *  *SUBPROGRAM NOT FOUND error occurs
[0760]               *
[0761]               *  Input: the subprogram name is in the FAC and the length
[0762]               *         of the name is in FAC15
[0763]               ***********************************************************
[0764] A223 8E,80,89 GPLCAL CZ   @RAMFLG           Can't try if CPU program
[0765] A226 4C,EB           BR   ERRSNF
[0766] A228 E7,59,00        DSRL 8,@FAC15          Make name length a double
       A22B 08
[0767] A22C A5,2C,59        DSUB @FAC15,@PGMPTR    Point back at name
[0768] A22F 93,2C           DDEC @PGMPTR           Point at name length
[0769] A231 BD,56,2C        DST  @PGMPTR,@FAC12    Set pointer to name
[0770] A234 06,00,10        CALL LINK              Issue 'Call Program Link'
[0771] A237 0A              BYTE 10              * Search subprogram lists
[0772] A238 41,C5           BR   ONWRN7            If all ok, check-end and rtn
[0773] A23A 4C,EB           BR   ERRSNF            If not found, error
[0774]               ***********************************************************
[0775]               *                     NUD FOR PI
[0776]               ***********************************************************
[0777] A23C 31,00,08 NPI    MOVE 8,G@CONPI,@FAC    Load constant PI
       A23F 4A,A2,44
[0778] A242 0F,75           XML  CONT
[0779] A244 40,03,0E CONPI  BYTE >40,3,14,15,92,65,35,90
       A247 0F,5C,41
       A24A 23,5A
[0780]               * 3.1415992653590E+00
[0781]               ***********************************************************
[0782]               *                     NUD FOR MAX
[0783]               ***********************************************************
[0784] A24C 06,A2,61 NMAX   CALL MAXMIN            Combine MAX and MIN
[0785] A24F 0A              GT
[0786] A250 42,57           BR   GA263
[0787] A252 35,00,08 NMAXZ1 MOVE 8,@ARG,@FAC
       A255 4A,5C
[0788] A257 0F,75    GA263  XML  CONT
[0789]               ***********************************************************
[0790]               *                     NUD FOR MIN
[0791]               ***********************************************************
[0792] A259 06,A2,61 NMIN   CALL MAXMIN            Combine MAX and MIN again
[0793] A25C 0A              GT
[0794] A25D 42,52           BR   NMAXZ1
[0795] A25F 0F,75           XML  CONT
[0796]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0014 
RXB 2024
[0797]               *                COMMON MAX / MIN ROUTINE
[0798]               ***********************************************************
[0799] A261 06,AB,92 MAXMIN CALL LPARR             Skip "(" parse, and insure ,
[0800] A264 C6,4C,63        CH   >63,@FAC2         Must be numeric
[0801] A267 6C,B3           BS   ERRSNM
[0802] A269 0F,77           XML  VPUSH             Push l.h. arg on stack
[0803] A26B 0F,74           XML  PARSE             PARSE up to ")"
[0804] A26D B6              BYTE RPARZ
[0805] A26E C6,4C,63        CH   >63,@FAC2         Must be numeric
[0806] A271 6C,B3           BS   ERRSNM
[0807] A273 0F,7E           XML  SPEED             Must be
[0808] A275 00              BYTE SYNCHK        *    at a
[0809] A276 B6              BYTE RPARZ         *      right parenthesis
[0810] A277 35,00,08        MOVE 8,@FAC,@ARG       Save in ARG for compare
       A27A 5C,4A
[0811] A27C 0F,78           XML  VPOP              Get l.h. arg back
[0812] A27E 0F,0A           XML  FCOMP             Compare operands
[0813] A280 00              RTN
[0814]               * RXB PATCH CODE FOR INTRND
[0815] A281 BF,80,C0 INTRND DST  >3567,@>83C0      Random number seed
       A284 35,67
[0816] A286 00              RTN
[0817]               ***********************************************************
[0818]               * RXB BASIC RND REPLACEMENT FROM TI BASIC
[0819] A287 BE,4A,3F NRND   ST   >3F,@FAC       * Exponent    
[0820] A28A BE,10,4B        ST   >4B,@VAR5      * Loop counter
[0821] A28D 02,63    NRND1  RAND >63            * 0?
[0822] A28F 8E,78           CZ   @RANDOM        * No, go on
[0823] A291 42,9D           BR   NRND3     
[0824] A293 92,4A           DEC  @FAC           * 0?
[0825] A295 8E,4A           CZ   @FAC           * End with 0
[0826] A297 62,AA           BS   NRND4          * Go on
[0827] A299 42,8D           BR   NRND1
[0828] A29B 02,63    NRND2  RAND >63            * Till 100
[0829] A29D BC,90,10 NRND3  ST   @RANDOM,*VAR5  * All digits
       A2A0 78
[0830] A2A1 D6,10,51        CEQ  >51,@VAR5      * Till >8351
[0831] A2A4 62,AC           BS   NRND5 
[0832] A2A6 90,10           INC  @VAR5          * Increase loop counter
[0833] A2A8 42,9B           BR   NRND2 
[0834] A2AA 86,4B    NRND4  CLR  @FAC1          * Set 0
[0835] A2AC 0F,75    NRND5  XML  CONT
[0836]               ***********************************************************
[0837] A2AE 0F,79    STRFCH XML  PGMCHR     * SKIP whatever
[0838] A2B0 0F,74    STRPAR XML  PARSE
[0839] A2B2 B6              BYTE RPARZ
[0840] A2B3 00              RTN
[0841] A2B4 06,A2,AE STRGET CALL STRFCH
[0842] A2B7 D6,4C,65        CEQ  >65,@FAC2
[0843] A2BA 4C,B3           BR   ERRSNM      * STRING NUM MISMATCH
[0844] A2BC 00              RTN
[0845] A2BD 06,A2,AE NUMFCH CALL STRFCH
[0846] A2C0 D6,4C,65 NUMSNM CEQ  >65,@FAC2
[0847] A2C3 6C,B3           BS   ERRSNM      * STRING NUM MISMATCH
[0848] A2C5 00              RTN
[0849] A2C6 0F,12    CFIFCH XML  CFI
[0850] A2C8 D6,54,03        CEQ  >03,@FAC+10
[0851] A2CB 6C,E3           BS   ERRBV       * NUMERIC OVERFLOW
[0852] A2CD 00              RTN
[0853] A2CE 06,A2,D7 GETNUM CALL SUBLP3
[0854] A2D1 D6,42,B3 GNRTN  CEQ  >B3,@CHAT
[0855] A2D4 4C,AF           BR   ERRSYN
[0856] A2D6 00              RTN
[0857] A2D7 06,A2,BD SUBLP3 CALL NUMFCH

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0015 
RXB 2024
[0858] A2DA 06,A2,C6        CALL CFIFCH
[0859] A2DD 00              RTN
[0860] A2DE 06,A2,B0 SUBLP4 CALL STRPAR
[0861] A2E1 06,A2,C6        CALL CFIFCH
[0862] A2E4 42,D1           BR   GNRTN
[0863] A2E6 0F,79    NGOOD  XML  PGMCHR
[0864] A2E8 CA,42,80 NGOOD1 CHE  >80,@CHAT
[0865] A2EB 6C,AF           BS   ERRSYN         * ?
[0866] A2ED 06,A3,01        CALL SNDER
[0867] A2F0 D6,4C,65        CEQ  >65,@FAC2
[0868] A2F3 4C,B3           BR   ERRSNM         * STRING NUMBER MISMATCH
[0869] A2F5 BF,4A,00        DST  >001C,@FAC
       A2F8 1C
[0870] A2F9 BD,4E,1C        DST  @SREF,@FAC4
[0871] A2FC BD,50,0C        DST  @BYTES,@FAC6
[0872] A2FF 43,0A           BR   SNDASS
[0873] A301 0F,7A    SNDER  XML  SYM
[0874] A303 0F,7B           XML  SMB
[0875] A305 0F,77           XML  VPUSH
[0876] A307 00              RTN
[0877] A308 0F,80    CIFSND XML  CIF
[0878] A30A 0F,7C    SNDASS XML  ASSGNV
[0879] A30C 00              RTN
[0880] A30D 86,4A    CLRFAC CLR  @FAC
[0881] A30F 35,00,07        MOVE 7,@FAC,@FAC1
       A312 4B,4A
[0882] A314 00              RTN
[0883]               ***********************************************************
[0884]               *                   RANDOMIZE STATEMENT
[0885]               ***********************************************************
[0886]               * RXB PATCH RAMDOMIZE and RANDOMIZE SEED replaced         *
[0887]               ***********************************************************
[0888] A315 06,6A,78 NRNDMZ CALL CHKEND            Seed provider?
[0889] A318 63,26           BS   RNDM1             No
[0890]               * RANDOMIZE given a see value
[0891]               * (99,000,000,000,001 possible starting positions)
[0892]               * (Place-value is ignored in the input number)
[0893] A31A 0F,74           XML  PARSE             Parse the seed
[0894] A31C 83              BYTE TREMZ           * Up to end of statement
[0895] A31D 06,A3,2C        CALL CKSTNM
[0896]               * TI BASIC RAMDOMIZE SEED ***
[0897] A320 BD,80,C0        DST @FAC,@>83C0 Quotation on random number seed
       A323 4A
[0898] A324 0F,75    NRNDCT XML  CONT
[0899]              
[0900]               * TI BASIC RANDOMIZE no seed ***
[0901] A326 BC,80,C1 RNDM1  ST   @>8379,@>83C1
       A329 79
[0902] A32A 0F,75           XML  CONT
[0903] A32C D6,4C,65 CKSTNM CEQ  >65,@FAC2
[0904] A32F 6C,B3           BS   ERRSNM
[0905] A331 00              RTN
[0906]               ***********************************************************
[0907] A332 40,01,00 FLT1   BYTE >40,>01,>00,>00,>00,>00,>00,>00
       A335 00,00,00
       A338 00,00
[0908]               ***********************************************************
[0909]               *                 EXTENDED STRING PACKAGE
[0910]               * THE ROUTINES ARE:
[0911]               *  LITS05 - Move a string literal from the program to the
[0912]               *            string space
[0913]               *  INTARG - Checks that an argument is a numeric and
[0914]               *            converts it from floating point to an integer
[0915]               *  PUSSTR - Checks that an argument is a string and pushes

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0016 
RXB 2024
[0916]               *            it on the stack
[0917]               *  CONCAT - Concatenates 2 strings together
[0918]               *  SEG$   - Segments a string
[0919]               *  LEN    - Puts the length of a string in the FAC
[0920]               *  CHR$   - Converts an integer into its ASCII character
[0921]               *  STR$   - Converts a number into its string equivalent
[0922]               *  VAL    - Converts a string into its numeric equivalent
[0923]               *  POS    - Gives the position of one string within another
[0924]               *  RPT$   - Generates a single string with multiple copies
[0925]               *            of the original string
[0926]               *
[0927]               *      AN ENTRY IN THE FAC LOOKS LIKE:
[0928]               * +------------+-----+----+-------------+-----------------+
[0929]               * |addr of ptr | >65 | xx | addr of str | length of str   |
[0930]               * +------------+-----+----+-------------+-----------------+
[0931]               *     FAC       FAC2  FAC3   FAC4           FAC6
[0932]               ***********************************************************
[0933]               * Support routine for functions to build FAC entry
[0934] A33A 86,50    LITS05 CLR  @FAC6             Need as a double-byte value
[0935] A33C BD,0C,50        DST  @FAC6,@BYTES      LENGTH FOR GETSTR
[0936] A33F BC,52,80        ST   @RAMTOP,@FAC8     Copy ERAM flag for later
       A342 84
[0937] A343 0F,71    LITS07 XML  GETSTR            ALLOCATE STRING SPACE
[0938] A345 BF,4A,00 LITS08 DST  >001C,@FAC        SAVE ADDR OF STRING  (SREF)
       A348 1C
[0939] A349 BD,4E,1C        DST  @SREF,@FAC4       SAVE ADDR OF STRING
[0940] A34C BF,4C,65        DST  >6500,@FAC2       INDICATES A STRING CONSTANT
       A34F 00
[0941]               *********** COPY STRING INTO STRING SPACE *****************
[0942] A350 8F,0C    LITS09 DCZ  @BYTES            If non-null string
[0943] A352 63,6A           BS   GA42B
[0944] A354 8E,52           CZ   @FAC8
[0945] A356 43,5F           BR   GA420
[0946] A358 34,0C,B0        MOVE @BYTES,V*TEMP5,V*SREF
       A35B 1C,B0,66
[0947] A35E 00              RTN
[0948]               *                             Else source string in ERAM
[0949] A35F BD,56,0C GA420  DST  @BYTES,@FFF1      FFF1 : BYTE COUNT
[0950] A362 BD,58,1C        DST  @SREF,@EEE1       EEE1 : DESTINATION ADDR ON VD
[0951] A365 BD,54,66        DST  @TEMP5,@DDD1      DDD1 : Source addr in ERAM
[0952] A368 0F,8B           XML  GVWITE            Move data from ERAM to VDP
[0953] A36A 00       GA42B  RTN
[0954] A36B 86,52    LITS06 CLR  @FAC8             SET FLAG TO VDP
[0955] A36D 43,43           BR   LITS07            JUMP INTO CODE
[0956]               ***********************************************************
[0957]               * PUSSTR - Insures that the entry in the FAC is a string
[0958]               *           and pushes it onto the stack.
[0959]               ***********************************************************
[0960] A36F D6,4C,65 PUSSTR CEQ  >65,@FAC2
[0961] A372 4C,B3           BR   ERRSNM
[0962] A374 0F,77           XML  VPUSH             PUSH THE ARGUMENT
[0963] A376 00              RTN
[0964]               ***********************************************************
[0965]               * CONCAT - CONCATENATES TWO STRINGS TOGETHER
[0966]               *         INPUT  : FLOATING POINT ACCUMULATOR ENTRIES
[0967]               *         OUTPUT : CONCATENATED STRING AND (POSSIBLE)
[0968]               *                  ZEROED BACK-POINTERS FOR THE OLD STRINGS
[0969]               *         USES   : TEMP2, TEMP4 AND TEMP5 AS TEMPORARIES
[0970]               ***********************************************************
[0971] A377 86,23    CONCAT CLR  @ERRCOD+1         CLEAR THE ERROR CODE
[0972] A379 06,A3,6F        CALL PUSSTR            Push the string & get next to
[0973] A37C 0F,74           XML  PARSE             GET THE R.H. ARGUMENT
[0974] A37E B8              BYTE CONCZ
[0975] A37F D6,4C,65        CEQ  >65,@FAC2         If not string - error

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0017 
RXB 2024
[0976] A382 4C,B3           BR   ERRSNM
[0977] A384 BD,0C,50        DST  @FAC6,@BYTES      GET R.H. LENGTH
[0978] A387 A1,0C,E0        DADD V@6(@VSPTR),@BYTES    ADD IN L.H. LENGTH
       A38A 06,6E
[0979] A38C C7,0C,00        DCH  255,@BYTES
       A38F FF
[0980] A390 43,9A           BR   GA45B
[0981] A392 BF,0C,00        DST  255,@BYTES        TRUNCATE IF TOO LONG
       A395 FF
[0982] A396 06,6A,82 WRNST1 CALL WARNZZ            Display warning
[0983] A399 13              BYTE 19                * STRING TRUNCATED message
[0984] A39A BD,68,0C GA45B  DST  @BYTES,@TEMP6     Keep length for later
[0985] A39D 0F,77           XML  VPUSH
[0986] A39F 0F,71           XML  GETSTR            Alloccate the result string
[0987] A3A1 0F,78           XML  VPOP              Retrieve R.H.
[0988] A3A3 35,00,08        MOVE 8,@FAC,@ARG
       A3A6 5C,4A
[0989] A3A8 0F,78           XML  VPOP              Retrieve L.H.
[0990] A3AA BD,66,4E        DST  @FAC4,@TEMP5      Set ptr to L.H. ARG(for FREST
[0991] A3AD BD,0C,50        DST  @FAC6,@BYTES      Length of L.H. ARG
[0992] A3B0 86,52           CLR  @FAC8             Force VDP mode
[0993] A3B2 06,A3,45        CALL LITS08            Set up FAC & copy L.H. ARG in
[0994] A3B5 8F,62           DCZ  @ARG6             If R.H. =0 don't copy
[0995] A3B7 63,CD           BS   CONC06
[0996] A3B9 BD,64,1C        DST  @SREF,@TEMP4      Get ptr to new string
[0997] A3BC A1,64,50        DADD @FAC6,@TEMP4      Ptr to where 2nd string begin
[0998] A3BF A5,68,50        DSUB @FAC6,@TEMP6      Length of 2nd string
[0999]               *                                      (possibly truncated)
[1000] A3C2 63,CD           BS   CONC06
[1001] A3C4 34,68,B0        MOVE @TEMP6,V*ARG4,V*TEMP4     Copy in 2nd string
       A3C7 64,B0,60
[1002]                
[1003] A3CA A1,50,68        DADD @TEMP6,@FAC6      Add in length of 2nd ARG
[1004]               * NOTE: FAC6 already contained length of 1st ARG from the
[1005]               *       parse that was done on it
[1006] A3CD 0F,75    CONC06 XML  CONT              Done.
[1007]               ***********************************************************
[1008]               * SEG$(A$,X,Y) - Extracts the desiginated string from A$.
[1009]               *     X specifies the character position within A$ at
[1010]               *     which the extraction begins. Y specifies the number
[1011]               *     of characters to extract.
[1012]               *     If X or Y is negative an error occurs. If X=0 an
[1013]               *     error occurs. If Y=0 or X > Y then a null string is
[1014]               *     is returned. If the ramaining length in A$ starting
[1015]               *     at the postion specified by X is less than the length
[1016]               *     specified by Y, then the remainder of A$ starting at
[1017]               *     position X is returned.
[1018]               *   INPUT - Control is turned over to SEG$ from PARSE. The
[1019]               *     only requirement is that a SEG$ was encountered.
[1020]               *   OUTPUT - The Floating Point Accumulator is set up with
[1021]               *     the header for the segmented string.
[1022]               *   USES - TEMP2 (Others in calls to GETSTR and LITS08)
[1023]               ***********************************************************
[1024] A3CF 06,AB,92 SEGZ01 CALL LPARR             Insure "(" parse and check ",
[1025] A3D2 06,A3,6F        CALL PUSSTR            Push string and get next toke
[1026] A3D5 0F,7E           XML  SPEED             Get the position
[1027] A3D7 01              BYTE PARCOM       *     within the source string
[1028] A3D8 06,A9,06        CALL INTARG            CHECK & CONVERT ARG TO INTEGE
[1029] A3DB 8F,4A           DCZ  @FAC               CAN'T HAVE VALUE OF 0
[1030] A3DD 6C,E3           BS   ERRBV
[1031] A3DF 0F,77           XML  VPUSH             PUSH THE ARG
[1032] A3E1 0F,74           XML  PARSE             Get extraction length
[1033] A3E3 B6              BYTE RPARZ
[1034] A3E4 0F,7E           XML  SPEED             Must have

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0018 
RXB 2024
[1035] A3E6 00              BYTE SYNCHK       *     ended on
[1036] A3E7 B6              BYTE RPARZ        *      a right parenthesis
[1037] A3E8 06,A9,06        CALL INTARG            CHECK & CONVERT ARG TO INTEGE
[1038] A3EB BD,5C,4A        DST  @FAC,@ARG         Move extraction length
[1039] A3EE 0F,78           XML  VPOP              Get position back
[1040] A3F0 BD,5E,4A        DST  @FAC,@ARG2        Move position
[1041] A3F3 0F,78           XML  VPOP              Retrieve source string
[1042] A3F5 BD,56,5E        DST  @ARG2,@TEMP2      Get position within string
[1043] A3F8 C5,56,50        DCH  @FAC6,@TEMP2      If position > length =>null
[1044] A3FB 64,2E           BS   SEGZ08
[1045] A3FD A1,56,5C        DADD @ARG,@TEMP2       Compute end of substring
[1046] A400 A5,56,50        DSUB @FAC6,@TEMP2      Compute length beyond end
[1047] A403 93,56           DDEC @TEMP2             string
[1048] A405 D3,56,00        DCGE 0,@TEMP2
       A408 00
[1049] A409 44,13           BR   SEGZ06            Fine if substring is shorter
[1050] A40B BD,5C,50        DST  @FAC6,@ARG        Else, truncate length of
[1051]               *                              substring
[1052] A40E A5,5C,5E        DSUB @ARG2,@ARG        Subtract position from source
[1053]               *                              length
[1054] A411 91,5C           DINC @ARG              Increment to include last cha
[1055] A413 BD,0C,5C SEGZ06 DST  @ARG,@BYTES       # of bytes needed for substri
[1056] A416 0F,77           XML  VPUSH             Save source string entry
[1057] A418 0F,71           XML  GETSTR            ALLOCATE RESULT STRING
[1058] A41A 0F,78           XML  VPOP              Restore source string entry
[1059] A41C BD,66,4E        DST  @FAC4,@TEMP5      Pointer to source for FRESTR
[1060]               *                              LITS08
[1061] A41F A1,66,5E        DADD @ARG2,@TEMP5      Pointer to start of substring
[1062] A422 93,66           DDEC @TEMP5            Decrement since zero-based
[1063] A424 BD,50,0C        DST  @BYTES,@FAC6      Set length of string
[1064] A427 86,52           CLR  @FAC8             FORCE VDP MODE
[1065] A429 06,A3,45        CALL LITS08            Copy in & set up FAC
[1066] A42C 0F,75           XML  CONT
[1067] A42E 87,5C    SEGZ08 DCLR @ARG              Extract a null string
[1068] A430 44,13           BR   SEGZ06            >>>JUMP ALWAYS<<<
[1069]               ***********************************************************
[1070]               * LEN(A$) - Calculate the length of a string and leave the
[1071]               *           result in the FAC.
[1072]               *  CONTROL - Turned over to NLEN from the parser.
[1073]               *  USES    - No temporaries.
[1074]               ***********************************************************
[1075] A432 06,A4,A4 LEN01  CALL PARFF             Insure left parenthesis & par
[1076] A435 4C,B3           BR   ERRSNM             If not string value
[1077] A437 BD,4A,50        DST  @FAC6,@FAC        Length
[1078] A43A 0F,80    LEN02  XML  CIF               Convert integer to floating p
[1079] A43C 0F,75           XML  CONT
[1080]               ***********************************************************
[1081]               * CHR$(X) - Takes integer value X and converts the number
[1082]               *           into the ASCII representation for that number.
[1083]               *  CONTROL - Turned over to NCHR by the parser.
[1084]               *  OUTPUT  - FAC is set up with the string entry
[1085]               *  USES    - Uses temproraries when invoking LITS06(LITSTR)
[1086]               ***********************************************************
[1087] A43E 06,A4,A4 CHRZ01 CALL PARFF             Insure left parenthesis & par
[1088] A441 06,A9,06        CALL INTARG            Convert into integer
[1089] A444 BF,0C,00        DST  1,@BYTES          Create a length 1 string
       A447 01
[1090] A448 BC,A3,78        ST   @FAC1,V@ONECHR    Move the value to VDP(for LIT
       A44B 4B
[1091] A44C BF,66,03        DST  ONECHR,@TEMP5     Address of character
       A44F 78
[1092] A450 06,A3,6B        CALL LITS06            Create string and set up FAC
[1093] A453 BF,50,00        DST  1,@FAC6           Length of string
       A456 01

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0019 
RXB 2024
[1094] A457 0F,75           XML  CONT
[1095]               ***********************************************************
[1096]               * ASC(A$) - Takes the numeric value of the first character
[1097]               *           in A$.
[1098]               ***********************************************************
[1099] A459 06,A4,A4 ASC01  CALL PARFF             Insure left parenthesis & par
[1100] A45C 4C,B3           BR   ERRSNM             If not string
[1101] A45E 8E,51           CZ   @FAC7             Bad Argument?
[1102] A460 6C,DF           BS   ERRBA
[1103] A462 BC,4B,B0        ST   V*FAC4,@FAC1      Get the first character
       A465 4E
[1104] A466 86,4A           CLR  @FAC
[1105] A468 44,3A           BR   LEN02             USE COMMON CODE >>>JUMP ALWAY
[1106]               ***********************************************************
[1107]               * STR$(X) - Takes as its imput an integer X and converts it
[1108]               *           to its string representation.
[1109]               *  CONTROL - Turned over to STR$ by the parser.
[1110]               *  USES    - The usual temporaries used by string function
[1111]               *            when it calls LITS06. Uses the Roll-out area
[1112]               *            for a temporary storage area when allocating
[1113]               *            the result string.
[1114]               *  OUTPUT  - FAC is set up in the usual manner for a string
[1115]               ***********************************************************
[1116] A46A 06,A4,A4 STRZ01 CALL PARFF             Insure left parenthesis & par
[1117] A46D 6C,B3           BS   ERRSNM             If not numeric-error
[1118] A46F 86,55           CLR  @FAC11            Select XB floating type
[1119] A471 0F,73           XML  XBCNS             Convert the number to string
[1120] A473 D6,90,55        CEQ  SPACE,*FAC11      If leading space
       A476 20
[1121] A477 44,7D           BR   GA53E
[1122] A479 90,55           INC  @FAC11            Suppress it out
[1123] A47B 92,56           DEC  @FAC12            Shorten the length
[1124] A47D 86,0C    GA53E  CLR  @BYTES            Prepare for 2-byte value
[1125] A47F BC,0D,56        ST   @FAC12,@BYTES+1   Get length of string
[1126] A482 34,0C,A3        MOVE @BYTES,*FAC11,V@VROAZ    Put the string in VDP
       A485 C0,90,55
[1127] A488 BF,66,03        DST  VROAZ,@TEMP5      Copy-from address(for LITSTR)
       A48B C0
[1128] A48C 06,A3,6B        CALL LITS06            Allocate and set up FAC
[1129] A48F BD,50,0C        DST  @BYTES,@FAC6      Put in the length
[1130] A492 0F,75           XML  CONT
[1131]               ***********************************************************
[1132]               * VAL(A$) - Takes as its input a string, A$, and converts
[1133]               *           the string into a number if the string is a
[1134]               *           valid representation of a number.
[1135]               *  CONTROL - From the parser.
[1136]               *  OUTPUT  - FAC contains the floating point number.
[1137]               ***********************************************************
[1138] A494 06,A4,A4 VAL01  CALL PARFF             Insure left parenthesis & par
[1139] A497 4C,B3           BR   ERRSNM             If not string - error
[1140] A499 8E,51           CZ   @FAC7             Can't have null string
[1141] A49B 6C,DF           BS   ERRBA
[1142] A49D 06,A4,AE        CALL VALCD             So bad argument error
[1143] A4A0 6C,DF           BS   ERRBA
[1144] A4A2 0F,75           XML  CONT
[1145]               * Short routine to parse a single argument enclosed in
[1146]               *  parenthesis for a function or a subprogram and set
[1147]               *  condition based upon whether the value parsed was a
[1148]               *  string or a numeric.
[1149] A4A4 06,A9,67 PARFF  CALL COMB              (?
[1150] A4A7 0F,74           XML  PARSE
[1151] A4A9 FF              BYTE >FF               *
[1152] A4AA D6,4C,65        CEQ  >65,@FAC2
[1153] A4AD 01              RTNC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0020 
RXB 2024
[1154] A4AE BD,66,4E VALCD  DST  @FAC4,@TEMP5      Pointer to string
[1155] A4B1 A1,66,50        DADD @FAC6,@TEMP5      Pointer to trailing length by
[1156] A4B4 BD,0C,50        DST  @FAC6,@BYTES      For suppressing trailing blan
[1157] A4B7 91,0C           DINC @BYTES            Prepare for undue subtraction
[1158] A4B9 93,66    GA57C  DDEC @TEMP5            Keep track of end of string
[1159] A4BB 93,0C           DDEC @BYTES            Decrease length of string
[1160] A4BD 64,F6           BS   RTNSET            End up with empty string,
[1161] A4BF D6,B0,66        CEQ  SPACE,V*TEMP5     Wild trailing blanks
       A4C2 20
[1162] A4C3 64,B9           BS   GA57C
[1163] A4C5 91,0C           DINC @BYTES            Allow for terminator
[1164] A4C7 0F,77           XML  VPUSH             Save the ptr to the string
[1165] A4C9 0F,71           XML  GETSTR            Get a new string
[1166] A4CB 0F,78           XML  VPOP              Retrieve the ptr to the strin
[1167] A4CD BD,66,4E        DST  @FAC4,@TEMP5      Get the ptr to the string
[1168] A4D0 86,52           CLR  @FAC8             Force VDP mode
[1169] A4D2 06,A3,50        CALL LITS09            Copy the string and set up FA
[1170] A4D5 A1,0C,1C        DADD @SREF,@BYTES      Point to the trailing length
[1171] A4D8 93,0C           DDEC @BYTES            Point at the last character
[1172] A4DA BE,B0,0C        ST   SPACE,V*BYTES     Put in the terminator
       A4DD 20
[1173] A4DE BD,56,1C        DST  @SREF,@FAC12      Address for the conversion
[1174] A4E1 D6,B0,56 GA5A4  CEQ  SPACE,V*FAC12     While leading spaces
       A4E4 20
[1175] A4E5 44,EB           BR   GA5AE
[1176] A4E7 91,56           DINC @FAC12            Skip leading blank
[1177] A4E9 44,E1           BR   GA5A4
[1178] A4EB 86,4C    GA5AE  CLR  @FAC2             Get rid of string (in case=0)
[1179] A4ED 86,54           CLR  @FAC10            Assume no error
[1180] A4EF 0F,10           XML  CSNUM             Convert it
[1181] A4F1 D5,56,0C        DCEQ @BYTES,@FAC12     Convert all of it?
[1182] A4F4 68,2E           BS   WRNNO             Yes, check overflow & return
[1183] A4F6 D4,00,00 RTNSET CEQ  @PAD,@PAD         No, return with condition set
[1184] A4F9 01              RTNC
[1185]               ***********************************************************
[1186]               * POS(A$,B$,X) - Attempts to match the string, B$, in A$
[1187]               *    beginning at character # X in A$. If X is > LEN(A$), a
[1188]               *    match is not found or A$ is the null string then the
[1189]               *    returned value is 0. If B$ is the null string then the
[1190]               *    returned value is 1. Otherwise, the returned value is
[1191]               *    the column # of the 1st character matched in A$
[1192]               *  CONTROL - Fromn the parser. Returned through common code
[1193]               *            IN LEN.
[1194]               *  USES    - Not temporaries - Utilizes FAC and ARG.
[1195]               ***********************************************************
[1196] A4FA 06,AB,92 POS01  CALL LPARR             Insure "(", parse , insure ",
[1197] A4FD 06,A3,6F        CALL PUSSTR            STACK THE STRING AND GET TOKE
[1198] A500 0F,7E           XML  SPEED             Parse the match string and
[1199] A502 01              BYTE PARCOM      *      insure end on comma
[1200] A503 06,A3,6F        CALL PUSSTR            STACK THE STRING AND GET TOKE
[1201] A506 0F,74           XML  PARSE             Get position
[1202] A508 B6              BYTE RPARZ
[1203] A509 0F,7E           XML  SPEED             Must have
[1204] A50B 00              BYTE SYNCHK          *  ended on a
[1205] A50C B6              BYTE RPARZ           *   right parenthesis
[1206] A50D 06,A9,06        CALL INTARG            Check and convert it
[1207] A510 8F,4A           DCZ  @FAC              Value out of range
[1208] A512 6C,E3           BS   ERRBV
[1209] A514 BD,0C,4A        DST  @FAC,@BYTES       Keep the offset
[1210] A517 93,0C           DDEC @BYTES            Correct for position 0
[1211] A519 0F,78           XML  VPOP              Get match string back
[1212] A51B 35,00,08        MOVE 8,@FAC,@ARG       Put match in ARG
       A51E 5C,4A
[1213] A520 0F,78           XML  VPOP              Get source back

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0021 
RXB 2024
[1214] A522 8E,51           CZ   @FAC7             If source null
[1215] A524 65,61           BS   POS12
[1216] A526 C4,51,0D        CH   @BYTES+1,@FAC7    OFFSET > LENGTH?
[1217] A529 45,61           BR   POS12             Yes, no match possible
[1218] A52B 8E,63           CZ   @ARG7             If null string
[1219] A52D 65,52           BS   POS06
[1220] A52F A1,4E,0C        DADD @BYTES,@FAC4      Adjust ptr for offset
[1221] A532 A4,51,0D        SUB  @BYTES+1,@FAC7    Adjust length
[1222] A535 C8,51,63 POS02  CHE  @ARG7,@FAC7       Enough space left for a match
[1223] A538 45,61           BR   POS12             No, no match possible
[1224] A53A BD,4A,4E        DST  @FAC4,@FAC        Get first ARG
[1225] A53D BD,5C,60        DST  @ARG4,@ARG        Get second ARG
[1226] A540 BC,64,63        ST   @ARG7,@ARG8       And length of second
[1227] A543 D4,B0,5C POS04  CEQ  V*FAC,V*ARG       Compare the characters
       A546 B0,4A
[1228] A548 45,59           BR   POS10             Didn't match
[1229] A54A 91,4A           DINC @FAC              Next in source
[1230] A54C 91,5C           DINC @ARG              Next in match
[1231] A54E 92,64           DEC  @ARG8             Reached end of match?
[1232] A550 45,43           BR   POS04             Not yet, so loop
[1233] A552 90,0D    POS06  INC  @BYTES+1          Matched! Correct for 1 index
[1234] A554 BD,4A,0C POS08  DST  @BYTES,@FAC       Character position of match
[1235] A557 44,3A           BR   LEN02             Convert to floating point
[1236]               * NOTE: Utilizes the LEN code to do the conversion and
[1237]               *       finish up.
[1238] A559 90,0D    POS10  INC  @BYTES+1          Step index of match character
[1239] A55B 92,51           DEC  @FAC7             Move 1 position down 1st
[1240] A55D 91,4E           DINC @FAC4              Argument
[1241] A55F 45,35           BR   POS02             Try to match again
[1242]               * JUMP ALWAYS
[1243] A561 86,0D    POS12  CLR  @BYTES+1          NO MATCH POSSIBLE
[1244] A563 45,54           BR   POS08
[1245]               ***********************************************************
[1246]               * RPT$(A$,X) - Creates a string consisting of X copies of
[1247]               *              A$. If X is negative or non-numeric, an
[1248]               *              exception occurs. If A$ is not a string, an
[1249]               *              exception occurs.
[1250]               ***********************************************************
[1251] A565 06,AB,92 RPTZ01 CALL LPARR             Insure "(", parse, insure ","
[1252] A568 06,A3,6F        CALL PUSSTR            Insure a string and push it
[1253] A56B 0F,74           XML  PARSE             Parse second argument
[1254] A56D B6              BYTE RPARZ
[1255] A56E 0F,7E           XML  SPEED             Must have
[1256] A570 00              BYTE SYNCHK       *     ended on a
[1257] A571 B6              BYTE RPARZ        *      right parenthesis
[1258] A572 06,A9,06        CALL INTARG            Check numeric and convert
[1259] A575 A9,4A,E0        DMUL V@6(@VSPTR),@FAC  Compute result length
       A578 06,6E
[1260] A57A 8F,4B           DCZ  @FAC1
[1261] A57C 65,86           BS   GA649
[1262] A57E 06,6A,82 WRNST2 CALL WARNZZ            Give truncation message
[1263] A581 13              BYTE 19                * STRING TRUNCATED message
[1264] A582 BF,4C,00        DST  255,@FAC2         Make it a maximum string
       A585 FF
[1265] A586 BD,0C,4C GA649  DST  @FAC2,@BYTES      Copy requested string length
[1266] A589 0F,71           XML  GETSTR            Get the new string
[1267] A58B 0F,78           XML  VPOP              Retrieve the original string
[1268]               * At this point BYTES should still contain the length
[1269] A58D BD,5C,50        DST  @FAC6,@ARG        Copy original length in ARG
[1270] A590 8F,0C           DCZ  @BYTES            Zero copies requested
[1271] A592 45,96           BR   GA659
[1272] A594 87,5C           DCLR @ARG              So we copy zero!!!!!!!
[1273] A596 C1,0C,5C GA659  DEX  @ARG,@BYTES       Original length to BYTE
[1274] A599 BD,66,4E        DST  @FAC4,@TEMP5      And also original start addr

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0022 
RXB 2024
[1275] A59C 86,52           CLR  @FAC8             Clear flag for LITS08
[1276] A59E 06,A3,45        CALL LITS08            Create FAC and copy on copy
[1277]               * ARG contains total length now.
[1278] A5A1 BD,50,5C        DST  @ARG,@FAC6        Store new length
[1279] A5A4 A5,5C,0C RPTZ02 DSUB @BYTES,@ARG       Subtract one copy
[1280] A5A7 8F,5C           DCZ  @ARG              <<<<<THE WAY OUT
[1281] A5A9 65,C1           BS   XMLCON
[1282] A5AB A1,1C,0C        DADD @BYTES,@SREF      Compute new start address
[1283] A5AE C5,0C,5C        DCH  @ARG,@BYTES
[1284] A5B1 45,B6           BR   GA679
[1285] A5B3 BD,0C,5C        DST  @ARG,@BYTES       Truncate string
[1286] A5B6 34,0C,B0 GA679  MOVE @BYTES,V*TEMP5,V*SREF
       A5B9 1C,B0,66
[1287] A5BC 45,A4           BR   RPTZ02
[1288]               ***********************************************************
[1289]               *                   TRACE STATEMENT
[1290]               ***********************************************************
[1291] A5BE B6,45,10 NTRACE OR   >10,@FLAG         Set the trace bit
[1292] A5C1 0F,75    XMLCON XML  CONT              Continue on
[1293]               ***********************************************************
[1294]               *                 UNTRACE STATEMENT
[1295]               ***********************************************************
[1296] A5C3 B2,45,EF NUNTRC AND  >EF,@FLAG         Reset the trace bit
[1297] A5C6 0F,75           XML  CONT              Continue on
[1298]               ***********************************************************
[1299]               *          BREAK AND UNBREAK STATEMENTS
[1300]               ***********************************************************
[1301] A5C8 BE,5C,FF NBREAK ST   >FF,@ARG          BREAK flag
[1302] A5CB 06,6A,78        CALL CHKEND            Check for end of statement
[1303] A5CE 45,E1           BR   LINEGP            If not goto LINEGP
[1304] A5D0 93,2C           DDEC @PGMPTR           Back up so CON will rescan en
[1305] A5D2 8E,44           CZ   @PRGFLG           Rative without line #
[1306] A5D4 41,1B           BR   EXEC6C
[1307] A5D6 06,6A,84 ERROLP CALL ERRZZ             Only legal in a program
[1308] A5D9 1B              BYTE 27
[1309] A5DA 86,5C    NUNBRK CLR  @ARG              UNBREAK flag for common
[1310] A5DC 06,6A,78        CALL CHKEND            Check for end of statement
[1311] A5DF 66,34           BS   UNBK01            If end then goto UNBK01
[1312] A5E1 06,A8,10 LINEGP CALL LINE              Get line #
[1313] A5E4 BD,5E,32        DST  @ENLN,@ARG2
[1314] A5E7 A7,5E,00        DSUB >03,@ARG2         1st line #
       A5EA 03
[1315] A5EB C9,5E,30 LNGP1  DCHE @STLN,@ARG2       If line not found
[1316] A5EE 46,2E           BR   WRNLNF
[1317] A5F0 06,80,2E        CALL GRSUB3            Read line # of data from ERAM
[1318] A5F3 5E              BYTE >5E           *   (use GREAD1) or VDP
[1319]               * @ARG2: Source addr in ERAM/VDP, reset possible breakpoint
[1320] A5F4 D5,58,4A        DCEQ @FAC,@EEE1        If line found
[1321] A5F7 65,FF           BS   LNGP2
[1322] A5F9 A7,5E,00        DSUB 4,@ARG2           Next line in VDP or ERAM
       A5FC 04
[1323] A5FD 45,EB           BR   LNGP1
[1324]               * JUMP ALWAYS
[1325] A5FF 8E,80,84 LNGP2  CZ   @RAMTOP           If ERAM exists
[1326] A602 66,17           BS   GA6DA
[1327] A604 B2,58,7F        AND  >7F,@EEE1         Assume UNBREAK flag
[1328] A607 8E,5C           CZ   @ARG              If BREAK flag
[1329] A609 66,0E           BS   GA6D1
[1330] A60B B6,58,80        OR   >80,@EEE1         Set the breakpoint
[1331] A60E 06,60,36 GA6D1  CALL GWSUB             Write a few bytes of data to
[1332]               *                              ERAM (use GWRITE)
[1333] A611 5E,58,01        BYTE >5E,>58,>01     * ARG2,EEE1,1
[1334]               *                            @ARG2: Destination addr on ERA
[1335]               *                            @EEE1: Data

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0023 
RXB 2024
[1336]               *                            1    : Byte count
[1337] A614 05,A6,23        B    LNGP2B
[1338] A617 B2,B0,5E GA6DA  AND  >7F,V*ARG2        Assume UNBREAK flag first
       A61A 7F
[1339] A61B 8E,5C           CZ   @ARG              If BREAK flag
[1340] A61D 66,23           BS   LNGP2B
[1341] A61F B6,B0,5E        OR   >80,V*ARG2        Set the breakpoint
       A622 80
[1342] A623 06,6A,78 LNGP2B CALL CHKEND            Check for end of statement
[1343] A626 66,37           BS   LNGP4             If end then continue
[1344] A628 0F,7E           XML  SPEED             Must be
[1345] A62A 00              BYTE SYNCHK         *     at a
[1346] A62B B3              BYTE COMMAZ         *       comma now
[1347] A62C 45,E1           BR   LINEGP
[1348]               * JUMP ALWAYS
[1349] A62E 06,6A,82 WRNLNF CALL WARNZZ            Note: warning not error
[1350] A631 26              BYTE 38             *  'LINE NOT FOUND'
[1351] A632 46,23           BR   LNGP2B            And contiue on
[1352]               * JUMP ALWAYS
[1353] A634 06,A6,39 UNBK01 CALL UBSUB             Clear all bkpt in line # tabl
[1354] A637 0F,75    LNGP4  XML  CONT              Contiue
[1355]               *     CLEAR ALL BREAKPOINTS
[1356] A639 BD,52,30 UBSUB  DST  @STLN,@FAC8       END OF LINE # BUFFER
[1357] A63C 06,A6,49 GA6FF  CALL UBSUB1            Reset one line # at a time
[1358] A63F A3,52,00        DADD 4,@FAC8           Got to the next line
       A642 04
[1359] A643 C5,52,32        DCH  @ENLN,@FAC8       End of table
[1360] A646 46,3C           BR   GA6FF
[1361] A648 00              RTN
[1362] A649 06,80,2E UBSUB1 CALL GRSUB3            Read the line # from ERAM/VDP
[1363]               *                             Reset possible bkpt too
[1364] A64C 52              BYTE >52            *  @FAC8: Source addr on ERAM/VD
[1365] A64D 06,60,36        CALL GWSUB             Write a few bytes of data to
[1366]               *                              ERAM(use GWRITE) or VDP
[1367] A650 52,58,01        BYTE >52,>58,>01    *  FAC8,EEE1,1
[1368]               *                          @FAC8: Destination adr in ERAM/V
[1369]               *                          @EEE1: Data
[1370]               *                          1    : Byte count
[1371] A653 00              RTN
[1372]               ***********************************************************
[1373]               *                USER DEFINED FUNCTIONS
[1374]               * Subroutine to store away the information of the tokens in
[1375]               * a function reference, go into the 'DEF' statement,
[1376]               * calculate the value of the expression and then resume
[1377]               * execution of the user's program after the reference.
[1378]               * An entry in the FAC and on the stack for a function
[1379]               * reference looks like:
[1380]               * +--------+-----+---------------------+--------+---------+
[1381]               * | PGMPTR | >68 | string/numeric flag | SYMTAB | FREPTR  |
[1382]               * +--------+-----+---------------------+--------+---------+
[1383]               *  FAC      FAC2  FAC3                  FAC4     FAC6
[1384]               *
[1385]               * The 'PGMPTR' is where execution resumes after evaluating
[1386]               * the function. String (80)/numeric(00) flag is function
[1387]               * type. SYMTAB is the old symbol table pointer and FREPTR
[1388]               * is the old free space pointer. These are restored after
[1389]               * the function is evaluated.
[1390]               ***********************************************************
[1391] A654 8E,44    UDF    CZ   @PRGFLG           If imperative
[1392] A656 46,5D           BR   GA720
[1393] A658 8E,80,85        CZ   @RAMTOP+1         And ERAM, error
[1394] A65B 45,D6           BR   ERROLP
[1395] A65D 86,51    GA720  CLR  @FAC7             Assume no args
[1396] A65F 87,22           DCLR @ERRCOD           Clear the error code for cont

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0024 
RXB 2024
[1397] A661 86,5E           CLR  @ARG2             Safety for VPUSH
[1398] A663 86,4C           CLR  @FAC2             Sagety for VPUSH
[1399] A665 D6,42,B7        CEQ  LPARZ,@CHAT
[1400] A668 46,78           BR   GA73B
[1401] A66A 0F,77           XML  VPUSH             Save ptr to function definiti
[1402] A66C 0F,74           XML  PARSE             PARSE to get arg value
[1403] A66E FF              BYTE >FF
[1404] A66F 35,00,08        MOVE 8,@FAC,@ARG       Save PARSE result
       A672 5C,4A
[1405] A674 0F,78           XML  VPOP              Get S.T. ptr to function defi
[1406] A676 90,51           INC  @FAC7             Indicate theat we have an arg
[1407] A678 BC,66,51 GA73B  ST   @FAC7,@TEMP5      Move the parmeter count
[1408] A67B BD,64,4A        DST  @FAC,@TEMP4       S.T. ptr to definition
[1409] A67E 0F,77           XML  VPUSH             Allow room for UDF result
[1410] A680 35,00,08        MOVE 8,@ARG,@FAC       Retrieve parse result
       A683 4A,5C
[1411] A685 0F,77           XML  VPUSH             Save parse result
[1412] A687 BC,4C,B0        ST   V*TEMP4,@FAC2     Get S.T. declarations
       A68A 64
[1413] A68B BC,4D,4C        ST   @FAC2,@FAC3       Do this to save string bit
[1414]               * NOTE: THIS IS TO ALLOW THE CHECKING AFTER THE FUNCTION HA
[1415]               *       BEEN EVALUATED TO MAKE SURE THE FUNCTION
[1416]               *       TYPE (STRING/NUMERIC) MATCHES THE RESULT IT PRODUCE
[1417] A68E B2,4C,07        AND  >07,@FAC2         Mask all but # of parameters
[1418] A691 D4,4C,66        CEQ  @TEMP5,@FAC2
[1419] A694 4C,E7           BR   ERRIAL
[1420]               * Incorrect argument list error above.
[1421] A696 BD,4A,2C        DST  @PGMPTR,@FAC      Will resume execution here
[1422] A699 BE,4C,70        ST   >70,@FAC2         Entering parameter into symbo
[1423]               *                    table while in UDF statement executing
[1424] A69C B2,4D,80        AND  >80,@FAC3         Mask all but string bit
[1425] A69F A7,6E,00        DSUB 16,@VSPTR         Get below parse result
       A6A2 10
[1426]                
[1427] A6A3 BD,4E,3E        DST  @SYMTAB,@FAC4     Save current symbol table ptr
[1428] A6A6 BD,50,40        DST  @FREPTR,@FAC6     Save current free space ptr
[1429] A6A9 0F,77           XML  VPUSH             Save the return info
[1430] A6AB A3,6E,00        DADD 8,@VSPTR          Get back to parse result
       A6AE 08
[1431]               *********** SHIFT EXECUTION TO FUNCTION DEFINITION ********
[1432] A6AF BD,2C,E0        DST  V@6(@TEMP4),@PGMPTR    Set text ptr to definiti
       A6B2 06,64
[1433] A6B4 0F,79           XML  PGMCHR            Get 1st character in the defi
[1434] A6B6 C6,73,A4        CH   >A4,@SUBSTK       Stack overflow
[1435] A6B9 6C,BF           BS   ERRSO
[1436] A6BB 35,00,18        MOVE 24,@PAD,V@VROAZ   Roll out temporaries
       A6BE A3,C0,00
[1437] A6C1 B6,45,08        OR   >08,@FLAG         Set function flag for ENTER
[1438] A6C4 BE,16,80        ST   >80,@XFLAG        Make calls look like ENTERX
[1439] A6C7 D6,42,BE        CEQ  EQUALZ,@CHAT
[1440] A6CA 46,D9           BR   GA79C
[1441]               * NOTE: This is to keep the global/local variables correct
[1442]               *       the event that a function uses another function in
[1443]               *       its evaluation.
[1444] A6CC 86,59           CLR  @FAC15            Create a dummy entry in table
[1445] A6CE 06,6A,80        CALL ENT09              for no-paremter function
[1446] A6D1 97,2C           DDECT @PGMPTR          Back up to equal sign
[1447] A6D3 86,E0,02        CLR  V@2(@VSPTR)       This is to keep ASSGNV(called
       A6D6 6E
[1448]               *                              below) not to screw up in
[1449]               *                              case FAC2 happens to have a
[1450]               *                              value (greater) >65
[1451] A6D7 46,DC           BR   GA79F
[1452] A6D9 06,6A,7E GA79C  CALL ENTER             Enter the parameter

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0025 
RXB 2024
[1453] A6DC 0F,79    GA79F  XML  PGMCHR            Get the '=' (Checked in PSCAN
[1454] A6DE B2,45,F7        AND  >F7,@FLAG         Reset to normal ENTERs
[1455] A6E1 35,00,18        MOVE 24,V@VROAZ,@>8300
       A6E4 00,A3,C0
[1456] A6E7 BE,EF,FF        ST   >68,V@-6(@VSPTR)  Correct stack entry ID
       A6EA FA,6E,68
[1457] A6ED BD,E0,02        DST  V@SYMBOL,V@2(@SYMTAB)  Fudge link to
       A6F0 3E,A3,76
[1458]               *                                   get global values
[1459] A6F3 BD,4A,3E        DST  @SYMTAB,@FAC      Set up for SMB
[1460] A6F6 0F,7B           XML  SMB               Get value space
[1461] A6F8 35,00,08        MOVE 8,@FAC,@FAC8      Destination
       A6FB 52,4A
[1462] A6FD 0F,78           XML  VPOP              Get arg back
[1463] A6FF 35,00,08        MOVE 8,@FAC,@ARG       Argument value
       A702 5C,4A
[1464] A704 35,00,08        MOVE 8,@FAC8,@FAC      Destination
       A707 4A,52
[1465] A709 0F,77           XML  VPUSH             Push to destination
[1466] A70B 35,00,08        MOVE 8,@ARG,@FAC       Argument value
       A70E 4A,5C
[1467] A710 D6,4C,65        CEQ  >65,@FAC2         If a string
[1468] A713 47,1F           BR   GA7E2
[1469] A715 D7,4A,00        DCEQ >001C,@FAC        If not temp
       A718 1C
[1470] A719 67,1F           BS   GA7E2
[1471] A71B BD,4E,B0        DST  V*FAC,@FAC4       Get new location of string
       A71E 4A
[1472]               *                             Parameter was allocated in S.
[1473] A71F 0F,79    GA7E2  XML  PGMCHR            Skip the '='
[1474] A721 0F,7C           XML  ASSGNV            Assign the value to the param
[1475] A723 0F,74           XML  PARSE             PARSE to end of function defi
[1476] A725 83              BYTE TREMZ
[1477]               **** CHECK FOR TYPE MATCH (STRING/STRING OR NUM/NUM)*******
[1478]               **** BETWEEN THE RESULT AND THE FUNCTION TYPE *************
[1479] A726 D6,4C,65        CEQ  >65,@FAC2         If result string
[1480] A729 47,33           BR   GA7F6
[1481] A72B 8E,E0,03        CZ   V@3(@VSPTR)       If functional
       A72E 6E
[1482] A72F 6C,B3           BS   ERRSNM
[1483] A731 47,39           BR   GA7FC              not a string
[1484] A733 8E,E0,03 GA7F6  CZ   V@3(@VSPTR)       If functional
       A736 6E
[1485] A737 4C,B3           BR   ERRSNM
[1486]               ***** NOW RESTORE SYMBOL TABLE AND RESUME *****************
[1487]               ***** EXECUTION AT THE ORIGINAL LINE **********************
[1488] A739 06,A7,47 GA7FC  CALL DELINK            Delink the parameter entry
[1489] A73C BD,2C,E0        DST  V@8(@VSPTR),@PGMPTR Manual pop to get ptr back
       A73F 08,6E
[1490] A741 93,2C           DDEC @PGMPTR           Back up text pointer
[1491] A743 0F,79           XML  PGMCHR            Get next token
[1492] A745 0F,75           XML  CONT
[1493] A747 BD,66,3E DELINK DST  @SYMTAB,@TEMP5    Save addr of S.T. entry just
[1494]               *                             in case entry is a string
[1495]               *                             (must free the string)
[1496] A74A 35,00,04        MOVE 4,V@4(@VSPTR),@SYMTAB  Restore old symbol table
       A74D 3E,E0,04
       A750 6E
[1497]               *                             pointer and free space pointe
[1498]               *                             This handles the freeing of t
[1499]               *                             string value which was assign
[1500]               *                             to the parameter.
[1501] A751 D2,B0,66        CGE  0,V*TEMP5         If string parmeter
       A754 00

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0026 
RXB 2024
[1502] A755 67,89           BS   GA84C
[1503] A757 BD,66,E0        DST  V@6(@TEMP5),@TEMP5 Where the string is
       A75A 06,66
[1504] A75C 8F,66           DCZ  @TEMP5            If non-null string
[1505] A75E 67,70           BS   GA833
[1506] A760 BD,56,EF        DST  V@-3(@TEMP5),@TEMP2 Get backpointer
       A763 FF,FD,66
[1507] A766 C9,56,3E        DCHE @SYMTAB,@TEMP2    If not used
[1508] A769 67,70           BS   GA833
[1509] A76B 87,EF,FF        DCLR V@-3(@TEMP5)      Free up the string
       A76E FD,66
[1510]               * This handles the special case of F$(X$)=X$
[1511]               * The result, which was permanent, must be made a temp.
[1512] A770 D6,4C,65 GA833  CEQ  >65,@FAC2         If string result
[1513] A773 47,87           BR   GA84A
[1514] A775 C9,4A,3E        DCHE @SYMTAB,@FAC      If came from argument
[1515] A778 67,87           BS   GA84A
[1516] A77A 8F,4E           DCZ  @FAC4             If non-null
[1517] A77C 67,83           BS   GA846
[1518] A77E 87,EF,FF        DCLR V@-3(@FAC4)       Clear the backpointer
       A781 FD,4E
[1519] A783 BF,4A,00 GA846  DST  >001C,@FAC        Make it a temp
       A786 1C
[1520] A787 47,93    GA84A  BR   GA856             If numeric parameter
[1521] A789 8E,80,84 GA84C  CZ   @RAMTOP           If ERAM exist
[1522] A78C 67,93           BS   GA856
[1523] A78E A3,80,86        DADD 8,@RAMFRE         Remove 8 bytes of value
       A791 00,08
[1524] A793 A7,6E,00 GA856  DSUB 8,@VSPTR          Trash the stack entry
       A796 08
[1525] A797 00              RTN                    And retrun
[1526] A798 0F,74    ATTNUT XML  PARSE
[1527] A79A B6              BYTE RPARZ
[1528] A79B 06,A3,2C        CALL CKSTNM            CHECK FOR NUMERIC OR STRING
[1529] A79E 0F,7E           XML  SPEED             Insure argument is in
[1530] A7A0 02              BYTE RANGE          *   range of 0-30
[1531] A7A1 00              BYTE 0
[1532] A7A2 00,1E           DATA 30
[1533] A7A4 E6,4B,01        SRL  1,@FAC1           0,1 : 0000        ATTENUATION
[1534]               *                             2,3 : 0001
[1535]               *                             4,5 : 0010
[1536]               *                             6,7 : 0011        ETC...
[1537] A7A7 B6,4B,F0        OR   >F0,@FAC1         REGISTER BITS
[1538] A7AA 00              RTN
[1539]               ***********************************************************
[1540]               * SUBROUTINE TO SET POINTER TO EACH DATUM
[1541]               ***********************************************************
[1542] A7AB 93,36    DATAST DDEC @LNBUF            Point to 1st byte of line ptr
[1543] A7AD 06,80,2C        CALL GRSUB2            Read 2 bytes from VDP or ERAM
[1544] A7B0 36              BYTE LNBUF           *  (use GREAD1), @LNBUF: Source
[1545]               *                           *  address in ERAM or VDP
[1546] A7B1 BD,34,58        DST  @EEE1,@DATA       Put it in @DATA
[1547] A7B4 06,80,20        CALL SRDATA            Look for 'DATA' on the line
[1548] A7B7 47,C6           BR   DATST1            OK, FOUND ANOTHER 'DATA' STMT
[1549] A7B9 97,36           DDECT @LNBUF           NO
[1550] A7BB D5,36,30        DCEQ  @STLN,@LNBUF
[1551] A7BE 67,C4           BS   GA887
[1552] A7C0 93,36           DDEC @LNBUF            Point to 1st token address
[1553] A7C2 47,AB           BR   DATAST
[1554] A7C4 86,34    GA887  CLR  @DATA             Indicate no data
[1555] A7C6 00       DATST1 RTN
[1556]               ***********************************************************
[1557]               * Subroutine to get line number and goto routine to display
[1558]               * it on the screen.

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0027 
RXB 2024
[1559]               ***********************************************************
[1560] A7C7 8E,80,89 ASC    CZ   @RAMFLG
[1561] A7CA 47,D4           BR   GA897
[1562] A7CC BD,5E,EF        DST  V@-2(@EXTRAM),@ARG2   Get line # in
       A7CF FF,FE,2E
[1563] A7D2 47,E2           BR   GA8A5
[1564] A7D4 BF,56,00 GA897  DST  2,@FFF1           @FFF1 : Byte count
       A7D7 02
[1565] A7D8 BD,54,2E        DST  @EXTRAM,@DDD1     @DDD1 : Source addr in ERAM
[1566] A7DB 97,54           DDECT @DDD1
[1567] A7DD 0F,8C           XML  GREAD1            Read data from ERAM
[1568] A7DF BD,5E,58        DST  @EEE1,@ARG2       @EEE1 : Destination addr on C
[1569] A7E2 B2,5E,7F GA8A5  AND  >7F,@ARG2         Reset the breakpoint if any
[1570] A7E5 05,6A,7C        B    DISO
[1571]               ***********************************************************
[1572]               * Code to decode error returned from ALC
[1573]               ***********************************************************
[1574] A7E8 8A,22    ERORZ  CASE @ERRCOD           DECODE ERROR FROM INTERPRETER
[1575] A7EA 4C,AF           BR   ERRSYN            0 SYNTAX ERROR
[1576] A7EC 4C,BB           BR   ERRMEM            1 MEMORY FULL
[1577] A7EE 4C,E3           BR   ERRBV             2 BAD VALUE
[1578] A7F0 4C,DB           BR   ERRLNF            3 LINE NOT FOUND
[1579] A7F2 4C,AF           BR   ERRSYN            4 SYNTAX
[1580] A7F4 4C,D7           BR   ERRBS             5 BAD SUBSCRIPT
[1581] A7F6 4C,B3           BR   ERRSNM            6 STRING-NUMBER MISMATCH
[1582] A7F8 4C,BF           BR   ERRSO             7 STACK OVERFLOW
[1583] A7FA 4C,DF           BR   ERRBA             8 BAD ARGUMENT
[1584] A7FC 4C,D3           BR   ERRRWG            9 RETURN WITHOUT GOSUB
[1585] A7FE 4C,E7           BR   ERRIAL            A INCORRECT ARGUMENT LIST
[1586] A800 4C,C7           BR   ERRFNN            B FOR/NEXT NESTING
[1587] A802 4C,C3           BR   ERRNWF            C NEXT WITHOUT FOR
[1588] A804 4C,B7           BR   ERRMUV            D IMPROPERLY USED NAME
[1589] A806 4C,E7           BR   ERRIAL            E INCORRECT ARGUMENT LIST
[1590] A808 4C,CF           BR   ERRRSC            F RECURSIVE SUBPROGRAM CALL
[1591] A80A 4C,EB           BR   ERRSNF           10 SUBPROGRAM NOT FOUND
[1592] A80C 45,D6           BR   ERROLP           11 ONLY LEGAL IN A PROGRAM
[1593] A80E 4C,CB           BR   ERRSNS           12 MUST BE IN SUBPROGRAM
[1594]               ***********************************************************
[1595]               * SUBROUTINE TO GET LINE # FOLLOWING 'BREAK', 'UNBREAK',
[1596]               * 'RESTORE'
[1597]               ***********************************************************
[1598] A810 D6,42,C9 LINE   CEQ  LNZ,@CHAT         Should be line # reference
[1599] A813 4C,AF           BR   ERRSYN
[1600] A815 0F,79           XML  PGMCHR            Get high order line #
[1601] A817 BC,4A,42        ST   @CHAT,@FAC        Build result in FAC, FAC1
[1602] A81A 0F,79           XML  PGMCHR
[1603] A81C BC,4B,42        ST   @CHAT,@FAC1       Low order line #
[1604] A81F 0F,79           XML  PGMCHR            Get token following line #
[1605] A821 00              RTN
[1606] A822 86,54    CONV1  CLR  @FAC10
[1607] A824 0F,10           XML  CSNUM             Convert String to Number
[1608]               ***********************************************************
[1609] A826 BC,A3,BA        ST   @FAC10,V@CSNTP1
       A829 54
[1610] A82A BD,A3,90        DST  @FAC12,V@CSNTMP Save those in temporary, becaus
       A82D 56
[1611]               *                            in ERROV : WARNING routine hav
[1612]               *                            FAC12 and FAC10 values changed
[1613]               ***********************************************************
[1614] A82E 8E,54    WRNNO  CZ   @FAC10            Numeric overflow
[1615] A830 68,36           BS   GA8F9
[1616] A832 06,6A,82        CALL WARNZZ
[1617] A835 02              BYTE 2
[1618] A836 00       GA8F9  RTN

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0028 
RXB 2024
[1619]               ***********************************************************
[1620]               *                SUBROUTINE FOR 'GCHAR'                   *
[1621]               ***********************************************************
[1622]               * CALL GCHAR(row,column,variable,...)                     *
[1623]               ***********************************************************
[1624] A837 BD,02,7F GCHARZ DST  @XPT,@PAD2     Save XPT:YPT
[1625] A83A 06,AB,92 GCHAR1 CALL LPARR          (?
[1626] A83D 0F,7E           XML  SPEED          Insure in range
[1627] A83F 02              BYTE RANGE          *  of 1 - 24
[1628] A840 01              BYTE 1
[1629] A841 00,18           DATA 24
[1630] A843 92,4B           DEC  @FAC1          Adjust to internal range
[1631] A845 BD,02,7F        DST  @XPT,@PAD2     Save old XPT:YPT
[1632] A848 BC,7E,4B        ST   @FAC1,@YPT     Set row pointer
[1633] A84B 0F,7E           XML  SPEED          Get column value
[1634] A84D 01              BYTE PARCOM         *  and insure a comma
[1635] A84E 0F,7E           XML  SPEED          Insure in range
[1636] A850 02              BYTE RANGE          *  of 1 to 32
[1637] A851 01              BYTE 1
[1638] A852 00,20           DATA 32
[1639] A854 92,4B           DEC  @FAC1          Internal range: 0 - 31
[1640] A856 BC,7F,4B        ST   @FAC1,@XPT     Set column pointer
[1641] A859 06,A9,4E GCHAR2 CALL NUMVAR         Get pointer return variable
[1642] A85C 31,00,08        MOVE 8,G@FLT1,@FAC  Clear FAC
       A85F 4A,A3,32
[1643] A862 BC,4B,7D        ST   @CB,@FAC1      Get the character
[1644] A865 A6,4B,60        SUB  OFFSET,@FAC1   Remove screen offset
[1645] A868 CA,4B,64        CHE  100,@FAC1      100>=?
[1646] A86B 48,75           BR   GCHAR3         No, pass value 
[1647] A86D C0,4C,4B        EX   @FAC1,@FAC2    Swap if over offset size
[1648] A870 AE,4B,64        DIV  100,@FAC1      Set correct range
[1649] A873 90,4A           INC  @FAC           Set from Assembly to XB
[1650] A875 BD,7F,02 GCHAR3 DST  @PAD2,@XPT     Restore XPT:YPT
[1651] A878 0F,7C           XML  ASSGNV         Assign the value to the symbol
[1652] A87A D6,42,B3        CEQ  COMMAZ,@CHAT   ,? 
[1653] A87D 68,3A           BS   GCHAR1         Loop
[1654] A87F BD,7F,02        DST  @PAD2,@XPT     Restore XPT:YPT
[1655] A882 0F,7E    LNKRTN XML  SPEED          Must be at
[1656] A884 00              BYTE SYNCHK    *     a right
[1657] A885 B6              BYTE RPARZ     *      parenthesis
[1658] A886 06,6A,78 LNKRT2 CALL CHKEND         Check end of statement
[1659] A889 4C,AF           BR   ERRSYN         If not end-of-stmt , error
[1660] A88B 06,00,12        CALL RETURN         Return to caller
[1661]               ***********************************************************
[1662]               * CALL COLOR(ALL,FORGROUND,BACKGROUND,...)                *
[1663]               * CALL COLOR(SET#,FORGROUND,BACKGROUND,... )              *
[1664]               * CALL COLOR(SPRITE#,FORGROUND,...)                       *
[1665]               ***********************************************************
[1666] A88E 0F,7E    COLORZ XML  SPEED             Must be
[1667] A890 00              BYTE SYNCHK        *     at a
[1668] A891 B7              BYTE LPARZ         *       left parenthesis
[1669] A892 87,00    COL08  DCLR @PAD              Clear ALL pointer
[1670] A894 D6,42,EC        CEQ  ALLZ,@CHAT        ALL?
[1671] A897 48,A5           BR   COL09             No.
[1672] A899 BE,00,EC        ST   ALLZ,@PAD         Yes, store it in pointer
[1673] A89C 87,4A           DCLR @FAC              Set 0
[1674] A89E 0F,79           XML  PGMCHR            Skip ALL token.
[1675] A8A0 06,B0,97        CALL COMMA2            Skip comma.
[1676] A8A3 48,C3           BR   COL21             Start ALL RXB routine
[1677] A8A5 D6,42,FD COL09  CEQ  NUMBEZ,@CHAT      If sprite number specified
[1678] A8A8 48,BA           BR   COL20
[1679] A8AA 06,B0,0D        CALL SPNUM3             Check sprite number (SPNUM3)
[1680] A8AD 06,A8,FA COL10  CALL SPCOL             Put the color in SAL
[1681] A8B0 D6,42,B3        CEQ  COMMAZ,@CHAT      More color changes

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0029 
RXB 2024
[1682] A8B3 48,82           BR   LNKRTN
[1683] A8B5 06,B0,06        CALL SPNUM2             Skip and get sprite number (
[1684] A8B8 48,AD           BR   COL10
[1685]               * This part for regular color change routine
[1686] A8BA 0F,7E    COL20  XML  SPEED             Parse the character
[1687] A8BC 01              BYTE PARCOM         *   set and insure a comma
[1688] A8BD 0F,7E           XML  SPEED             Insure in range of
[1689] A8BF 02              BYTE RANGE          *   0<= x <= 14
[1690] A8C0 00,00,10        BYTE 0,0,16
[1691] A8C3 A3,4A,08 COL21  DADD >080F,@FAC        Color table addr(>0810 - >081
       A8C6 0F
[1692] A8C7 0F,77           XML  VPUSH             Push table set address
[1693] A8C9 0F,7E           XML  SPEED             Parse the foreground color
[1694] A8CB 01              BYTE PARCOM         *   and insure a comma
[1695] A8CC 06,AB,AF        CALL RAN16             Error if >16 or <1
[1696] A8CF BC,0E,4B        ST   @FAC1,@VAR4       Save it
[1697] A8D2 E2,0E,04        SLL  4,@VAR4           Foreground color in 4 MSBits
[1698] A8D5 0F,74           XML  PARSE             Get background color
[1699] A8D7 B6              BYTE RPARZ
[1700] A8D8 06,AB,AF        CALL RAN16             Error if >16 or <1
[1701] A8DB B4,0E,4B        OR   @FAC1,@VAR4       Background color in 4 LSBits
[1702] A8DE 0F,78           XML  VPOP              Get color table address
[1703] A8E0 BC,B0,4A        ST   @VAR4,V*FAC       Load the colors into the tabl
       A8E3 0E
[1704] A8E4 D6,00,EC        CEQ  ALLZ,@PAD         ALL in pointer.
[1705] A8E7 48,F1           BR   COL22             No.
[1706] A8E9 35,00,0E        MOVE 14,V*FAC,V@1(@FAC) Fill color table with values
       A8EC E0,01,4A
       A8EF B0,4A
[1707] A8F1 D6,42,B3 COL22  CEQ  COMMAZ,@CHAT      End of call. Go back.
[1708] A8F4 48,82           BR   LNKRTN
[1709] A8F6 0F,79           XML  PGMCHR            Skip ","
[1710] A8F8 48,92           BR   COL08             Take care of the next set
[1711]               *      CALL SPCOL -- Changes color of sprite.
[1712]               *                    Called also from SPRITE.
[1713] A8FA 0F,74    SPCOL  XML  PARSE
[1714] A8FC B6              BYTE RPARZ          *  Get the color number
[1715] A8FD 06,AB,AF        CALL RAN16             Check range 1 - 16
[1716] A900 BC,E0,03        ST   @FAC1,V@3(@PAD8)  Store in SAL
       A903 08,4B
[1717] A905 00              RTN
[1718]               ***********************************************************
[1719]               * INTARG - Insures that the value in FAC is a numeric,
[1720]               *          converts it to integer, issues error message if
[1721]               *          necessary or returns.
[1722]               ***********************************************************
[1723] A906 C6,4C,63 INTARG CH   >63,@FAC2         If string - error
[1724] A909 6C,B3           BS   ERRSNM      ERROR STRING NUMBER MISMATCH       
[1725] A90B 86,54           CLR  @FAC10            ASSUME NO ERROR OR WARNING
[1726] A90D 87,6C           DCLR @FPERAD
[1727] A90F 0F,12           XML  FLTINT
[1728] A911 8E,54           CZ   @FAC10            If error
[1729] A913 4C,E3           BR   ERRBV
[1730] A915 D2,4A,00        CGE  0,@FAC            Can't be < zero
[1731] A918 4C,E3           BR   ERRBV
[1732] A91A 00              RTN
[1733]               * FAC IS SET UP WITH F.P. 1
[1734] A91B BC,4B,00 JOYXY  ST   @PAD,@FAC1
[1735] A91E 8E,00           CZ   @PAD              If <>0
[1736] A920 49,26           BR   JOYNZ             No, not zero (0)
[1737] A922 86,4A           CLR  @FAC              (>0000000000000000)
[1738] A924 49,2E           BR   JOYAV             Assign value
[1739] A926 D2,00,00 JOYNZ  CGE  0,@PAD            PAD>=0?
[1740] A929 69,2E           BS   JOYAV             Yes assign value

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0030 
RXB 2024
[1741] A92B BE,4A,BF        ST   >BF,@FAC          Negative value
[1742] A92E 0F,7C    JOYAV  XML  ASSGNV            Assign the value
[1743] A930 00              RTN
[1744] A931 BC,00,4B        ST   @FAC1,@PAD        Keyboard selection
[1745] A934 06,A9,4E        CALL NUMVAR            Get variable for key-code
[1746] A937 D6,42,B3        CEQ  COMMAZ,@CHAT      If not comma - error
[1747] A93A 4C,AF           BR   ERRSYN
[1748] A93C 0F,79           XML  PGMCHR            Get next character
[1749] A93E 06,A9,4E        CALL NUMVAR            Get variable for key-status
[1750] A941 BC,74,00        ST   @PAD,@KEYBD       Keyboard selection
[1751] A944 31,00,08        MOVE 8,G@FLT1,@FAC     Set up float
       A947 4A,A3,32
[1752] A94A 03              SCAN                   SCAN the keyboard
[1753] A94B 86,74           CLR  @KEYBD            Clear the code(No affect on s
[1754] A94D 01              RTNC                   Return scan condition code
[1755]               *
[1756] A94E 0F,7A    NUMVAR XML  SYM               Get the symbol name
[1757] A950 DA,B0,4A        CLOG >C0,V*FAC         Can't be string or function
       A953 C0
[1758] A954 4C,B7           BR   ERRMUV            It is, IMPROPERLY USED NAME E
[1759] A956 0F,7B           XML  SMB               Get value pointer
[1760] A958 0F,77           XML  VPUSH             Put on stack for ASSGNV
[1761] A95A 00              RTN                    And return
[1762]               *
[1763] A95B 80,00,A0 ATTREG DATA >8000,>A000,>C000,
       A95E 00,C0,00
[1764] A961 9F,BF,DF        BYTE >9F,>BF,>DF,>FF,>00,>06
       A964 FF,00,06
[1765] A967 D6,42,B7 COMB   CEQ  LPARZ,@CHAT       If not '(' - error
[1766] A96A 4C,AF           BR   ERRSYN
[1767] A96C 00              RTN
[1768]               *
[1769] A96D 35,00,08 SQUISH MOVE 8,V*FAC8,@FAC     Sneak it out
       A970 4A,B0,52
[1770] A973 BD,58,6E        DST  @VSPTR,@FAC14     Now move stack to squish it
[1771] A976 A5,58,52        DSUB @FAC8,@FAC14        out - # of bytes to move
[1772] A979 69,84           BS   SQU05             If none to move
[1773] A97B 34,58,EF        MOVE @FAC14,V@8(@FAC8),V@-16(@FAC8)
       A97E FF,F0,52
       A981 E0,08,52
[1774] A984 A7,6E,00 SQU05  DSUB 8,@VSPTR
       A987 08
[1775] A988 00              RTN
[1776]               ***********************************************************
[1777]               *                 SUBPROGRAM FOR CLEAR                    *
[1778]               ***********************************************************
[1779]               * CALL CLEAR                                              *
[1780]               ***********************************************************
[1781] A989 07,80    CLEARZ ALL  SPACE+OFFSET      Clear the screen
[1782] A98B BE,7F,03        ST   3,@XPT            Initialize screen pointer
[1783] A98E 48,86           BR   LNKRT2            Return to caller
[1784]               ***********************************************************
[1785]               * CALL CLEARPRINT                                         *
[1786]               ***********************************************************
[1787] A990 86,8F,DD CLRPZ  CLR  @>6004       Set ROM 3 page
       A993 04
[1788] A994 0F,79           XML  CLEARP       Disply them
[1789] A996 48,86           BR   LNKRT2  
[1790]               ***********************************************************
[1791]               * INIALIZATION DATA FOR SOUND
[1792] A998 42,0B,12 FLTS   BYTE >42,>0B,>12,>22,>00,>00,>00,>00
       A99B 22,00,00
       A99E 00,00
[1793] A9A0 01,FF,01 SNDREG BYTE >01,>FF,>01,>04,>9F,>BF,>DF,>FF,>00

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0031 
RXB 2024
       A9A3 04,9F,BF
       A9A6 DF,FF,00
[1794]               ***********************************************************
[1795]               *                SUBPROGRAM FOR 'SOUND'                   *
[1796]               * CALL SOUND(duration,frequency,volume1,...)              *
[1797]               * Builds 2 blocks in VDP RAM                              *
[1798]               * 1st BLOCK : >01,<ATTENUATION FOR NOISE>,<INTERRUPT COUNT>
[1799]               * 2nd BLOCK : >04,>9F,>BF,>DF,>FF,>00                     *
[1800]               ***********************************************************
[1801] A9A9 D7,80,CC XSOUND DCEQ VRMSND,@>83CC     Insure previous sound started
       A9AC 03,79
[1802] A9AE 69,A9           BS   XSOUND
[1803] A9B0 31,00,09        MOVE 9,G@SNDREG,V@VRMSND
       A9B3 A3,79,A9
       A9B6 A0
[1804] A9B7 06,AB,92        CALL LPARR             Duration in milliseconds
[1805] A9BA D2,4A,00        CGE  0,@FAC            Don't wait for completion
[1806] A9BD 69,C4           BS   GAA39
[1807] A9BF 83,4A           DNEG @FAC                of previous sound
[1808] A9C1 87,80,CE        DCLR @PRTNFN           Make GPL interpeters stop pre
[1809] A9C4 0F,7E    GAA39  XML  SPEED             Insure duration
[1810] A9C6 02              BYTE RANGE           *  is in range
[1811] A9C7 01              BYTE 1               *   of 1 - 4250
[1812] A9C8 10,9A           DATA 4250
[1813]               * Convert duration into 1/60s of a second
[1814] A9CA AB,4A,00        DMUL 6,@FAC            Duration * 6
       A9CD 06
[1815] A9CE AF,4A,00        DDIV 100,@FAC          (duration * 6) / 100
       A9D1 64
[1816] A9D2 8E,4B           CZ   @FAC1             If duration =0
[1817] A9D4 49,D8           BR   GAA4D
[1818] A9D6 90,4B           INC  @FAC1             Set it to 1/60th of a second
[1819] A9D8 BC,A3,7B GAA4D  ST   @FAC1,V@VRMSND+2    3rd byte of the 1st block
       A9DB 4B
[1820]               *                          | INTERUPT COUNT
[1821]               ***********************************************************
[1822]               *      SOUND TABLE OF 10 BYTES IN CPU RAM (>00 - >09)
[1823]               * >00 - >05 : FREQUENCY CONTROL
[1824]               * >06 - >08 : ATTENUATION CONTROL
[1825]               * >09       : NOISE CONTROL(non-zero = noise encountered)
[1826]               * >0A       : POINTER FOR CURRENT FREQENCY CONTROL
[1827]               * >0B       : POINTER FOR CURRENT ATTENUATION CONTROL
[1828]               *                    >00 , >01 FOR REG 0;
[1829]               *                    >02 , >03 FOR REG 1;
[1830]               *                    >04 , >05 FOR REG 2;
[1831]               * REG0 : >8000, REG1 : >A000, REG3 : >C000
[1832]               * INITIALIZE ATTENUATION CONTROL
[1833]               * REG0 : >9F, REG1 : >BF, REG2 : >DF
[1834]               ***********************************************************
[1835] A9DC 31,00,0C        MOVE 12,G@ATTREG,@>8300
       A9DF 00,A9,5B
[1836] A9E2 0F,7E    SOUND1 XML  SPEED             Parse the frequency value
[1837] A9E4 01              BYTE PARCOM         *   and insure a comma
[1838] A9E5 06,A3,2C        CALL CKSTNM            Must be a numeric
[1839] A9E8 D2,4A,00        CGE  0,@FAC            Noise if negative
[1840] A9EB 4A,2A           BR   SOUND2
[1841] A9ED 31,00,08        MOVE 8,G@FLTS,@ARG     Constant 111834
       A9F0 5C,A9,98
[1842] A9F3 0F,09           XML  FDIV              P = 111834/FREQUENCY
[1843] A9F5 0F,7E           XML  SPEED             Insure in range
[1844] A9F7 02              BYTE RANGE
[1845] A9F8 03              BYTE 3               * Range: 3 - 1023
[1846] A9F9 03,FF           DATA 1023
[1847]               * GET THE 4 L.S.Bits BITS AND 6 M.S.Bits OF 'P'

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0032 
RXB 2024
[1848] A9FB EB,4A,00        DSRC 4,@FAC
       A9FE 04
[1849] A9FF E6,4A,04        SRL  4,@FAC
[1850] AA02 B5,90,0A        DOR  @FAC,*STADDR  1st byte of frequency control byt
       AA05 4A
[1851]               *                         BIT   7   6   5   4   3   2   1
[1852]               *                               1  <REG>    0  <L.S.B. 4 OF
[1853]               *                         2nd byte of frequency control byt
[1854]               *                               0   0   <M.S.B. 6 of 'P'
[1855] AA06 94,0A           INCT @STADDR           Advance ponter for next time
[1856] AA08 06,A7,98        CALL ATTNUT            Get attenuation
[1857]               *                        BIT    7   6   5   4   3   2   1
[1858]               *                               1   <REG>   1   0   0   0
[1859] AA0B B0,90,0B        AND  @FAC1,*PADB         1   <REG>   1   <ATTN/2 DB>
       AA0E 4B
[1860] AA0F 90,0B           INC  @PADB             Advance pointer for next time
[1861]               * CHECK FOR END OF SOUND CALL
[1862] AA11 D6,42,B6 SOUND3 CEQ  RPARZ,@CHAT       End of statement?
[1863] AA14 6A,48           BS   SOUND5
[1864] AA16 0F,7E           XML  SPEED             If not right parenthesis
[1865] AA18 00              BYTE SYNCHK        *    then must be at
[1866] AA19 B3              BYTE COMMAZ        *      a comma
[1867]              
[1868] AA1A D6,0A,06        CEQ  6,@STADDR         If not 3 regs yet
[1869] AA1D 49,E2           BR   SOUND1
[1870]               * 3 sound regs already - so must be noise control
[1871] AA1F 0F,7E           XML  SPEED             Get frequency (should be nois
[1872] AA21 01              BYTE PARCOM        *     and insure a comma
[1873] AA22 06,A3,2C        CALL CKSTNM            Must be a numeric value
[1874] AA25 D2,4A,00        CGE  0,@FAC            If not noise-error
[1875] AA28 6C,E3           BS   ERRBV
[1876]               * NOISE CONTROL
[1877] AA2A D6,09,FF SOUND2 CEQ  >FF,@>8309        * BAD ARGUMENT ERROR
[1878] AA2D 4C,DF           BR   ERRBA
[1879] AA2F 83,4A           DNEG @FAC              -(FREQUENCY)
[1880] AA31 0F,7E           XML  SPEED             Insure in range
[1881] AA33 02              BYTE RANGE         *    of 1 - 8
[1882] AA34 01              BYTE 1             *
[1883] AA35 00,08           DATA 8
[1884] AA37 92,4B           DEC  @FAC1             0 - 7 (2nd BIT: 'T')
[1885]               *                                           OTH, 1ST BITS:
[1886] AA39 BC,09,4B        ST   @FAC1,@>8309
[1887] AA3C B6,09,E0        OR   >E0,@>8309        Noise control byte:
[1888]               *                        BIT  7   6   5   4   3   2   1   0
[1889]               *                             1   1   1   0   0  <T>  < S >
[1890]               * PUT ATTENUATION IN THE 2ND BYTE OF 1ST BLOCK
[1891] AA3F 06,A7,98        CALL ATTNUT
[1892] AA42 BC,A3,7A        ST   @FAC1,V@VRMSND+1
       AA45 4B
[1893]               *                             1   1   1   1   < ATTN/2  DB>
[1894] AA46 4A,11           BR   SOUND3            Go check for end of list
[1895] AA48 86,10    SOUND5 CLR  @VAR5             Pointer to sound table
[1896] AA4A 8E,80,CE SND05  CZ   @PRTNFN           Wait untild previous
[1897] AA4D 6A,59           BS   SOUND6
[1898] AA4F 03              SCAN                   Is finished and
[1899] AA50 4A,4A           BR   SND05              look for a break-key
[1900] AA52 D6,75,02        CEQ  BREAK,@RKEY       If not break-key
[1901] AA55 4A,4A           BR   SND05
[1902] AA57 41,1B           BR   EXEC6C            If BREAK-KEY encountered
[1903]               * LOAD SOUND TABLE
[1904] AA59 BC,81,00 SOUND6 ST   *VAR5,@>8400      SOUND ADDRESS PORT
       AA5C 90,10
[1905] AA5E 90,10           INC  @VAR5             Next byte in table
[1906] AA60 D6,10,0A        CEQ  >0A,@VAR5         If not finished

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0033 
RXB 2024
[1907] AA63 4A,59           BR   SOUND6
[1908] AA65 BF,4A,03        DST  VRMSND,@FAC       Where the 2 blocks are
       AA68 79
[1909] AA69 F6,4A,01        I/O  1,@FAC            Start sound from VDP list
[1910] AA6C 48,82           BR   LNKRTN            Return to caller
[1911]               ***********************************************************
[1912]               * CALL HCHAR(row,column,character#,repetition[,...])      *
[1913]               ***********************************************************
[1914] AA6E 06,A9,67 HCHARZ CALL COMB              (?
[1915] AA71 06,AA,A2 HCHAR1 CALL HVRC              Get X, Y values
[1916] AA74 06,AA,C3        CALL HVCHR             character#
[1917] AA77 8F,4A           DCZ  @FAC              If 0 characters
[1918] AA79 6A,81           BS   HCHAR2
[1919] AA7B 86,8F,DD        CLR  @>6004            Set ROM 3 page
       AA7E 04
[1920] AA7F 0F,74           XML  HCHAR             Disply them
[1921] AA81 D6,42,B3 HCHAR2 CEQ  COMMAZ,@CHAT
[1922] AA84 6A,71           BS   HCHAR1
[1923] AA86 48,82           BR   LNKRTN            Return to XB
[1924]               ***********************************************************
[1925]               * CALL VCHAR(row,column,character#,repetition[,...])      *
[1926]               ***********************************************************
[1927] AA88 06,A9,67 VCHARZ CALL COMB              (?
[1928] AA8B 06,AA,A2 VCHAR1 CALL HVRC              Get X, Y values
[1929] AA8E 06,AA,C3        CALL HVCHR             character#
[1930] AA91 8F,4A           DCZ  @FAC              If 0 characters
[1931] AA93 6A,9B           BS   VCHAR2
[1932] AA95 86,8F,DD        CLR  @>6004            Set ROM 3 page
       AA98 04
[1933] AA99 0F,75           XML  VCHAR             Disply them
[1934] AA9B D6,42,B3 VCHAR2 CEQ  COMMAZ,@CHAT      COMMA?   
[1935] AA9E 6A,8B           BS   VCHAR1            No run again
[1936] AAA0 48,82           BR   LNKRTN            Done
[1937]               ***********************************************************
[1938]               * SUBROUTINE TO GET ROW, COLUMN VALUES
[1939]               ***********************************************************
[1940]               * Get ROW, COLUMN VALUES AND NUMBER OF CHARACTERS
[1941] AAA2 06,A2,BD HVRC   CALL NUMFCH          * Get ROW
[1942] AAA5 0F,7E           XML  SPEED             Insure in range
[1943] AAA7 02              BYTE RANGE           *  of 1 - 24
[1944] AAA8 01              BYTE 1
[1945] AAA9 00,18           DATA 24
[1946] AAAB 92,4B           DEC  @FAC1           * Adjust for Assembly
[1947] AAAD E3,4A,00        DSLL 5,@FAC          * FAC times 32  
       AAB0 05
[1948] AAB1 BD,02,4A        DST  @FAC,@PAD2      * VDP ADDRESS
[1949] AAB4 06,A2,BD        CALL NUMFCH          * Get Column
[1950] AAB7 0F,7E           XML  SPEED           *  Insure in range
[1951] AAB9 02              BYTE RANGE           *  of 1 to 32
[1952] AABA 01              BYTE 1
[1953] AABB 00,20           DATA 32
[1954] AABD 92,4B           DEC  @FAC1           * Adjust for Assembly: 0 - 31
[1955] AABF A1,02,4A        DADD @FAC,@PAD2      * Set column pointer
[1956] AAC2 00              RTN
[1957]               * Get Character minus OFFSET
[1958] AAC3 06,A2,D7 HVCHR  CALL SUBLP3          * Get character number
[1959] AAC6 A2,4B,60        ADD  OFFSET,@FAC1    * Add OFFSET
[1960] AAC9 BD,00,4B        DST  @FAC1,@PAD      * Pass value
[1961] AACC BF,4A,00 HVCHR1 DST  1,@FAC          * ASSUME 1 REPETITION
       AACF 01
[1962] AAD0 D6,42,B6        CEQ  RPARZ,@CHAT     * If not right parenthesis
[1963] AAD3 6A,D8           BS   HVCHS           * Yes return
[1964] AAD5 06,A2,D7        CALL SUBLP3          * Skip comma, Get repetition
[1965] AAD8 00       HVCHS  RTN                  * Return

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0034 
RXB 2024
[1966]               ***********************************************************
[1967] AAD9 06,AB,92 RGPHV  CALL LPARR             Insure '(', parse, insure ','
[1968] AADC 0F,7E    GPHVRC XML  SPEED             Insure in range
[1969] AADE 02              BYTE RANGE           *  of 1 - 24
[1970] AADF 01              BYTE 1
[1971] AAE0 00,18           DATA 24
[1972] AAE2 92,4B           DEC  @FAC1           * Adjust for Assembly
[1973] AAE4 E3,4A,00        DSLL 5,@FAC          * FAC times 32  
       AAE7 05
[1974] AAE8 BD,02,4A        DST  @FAC,@PAD2      * VDP ADDRESS
[1975] AAEB 0F,7E           XML  SPEED           * Get column value
[1976] AAED 01              BYTE PARCOM          *  and insure a comma
[1977] AAEE 0F,7E           XML  SPEED           *  Insure in range
[1978] AAF0 02              BYTE RANGE           *  of 1 to 32
[1979] AAF1 01              BYTE 1
[1980] AAF2 00,20           DATA 32
[1981] AAF4 92,4B           DEC  @FAC1           * Adjust for Assembly: 0 - 31
[1982] AAF6 A1,02,4A        DADD @FAC,@PAD2      * Set column pointer
[1983] AAF9 00              RTN
[1984]               ***********************************************************
[1985]               * CALL CHAR(char#,pattern,...)                            *
[1986]               * CALL CHAR(ALL,pattern,...)                              *
[1987]               ***********************************************************
[1988] AAFA 06,A9,67 CHARLY CALL COMB            (?
[1989] AAFD 0F,79    CHAR5  XML  PGMCHR          Skip "(" or ","
[1990] AAFF D6,42,EC        CEQ  ALLZ,@CHAT      ALL token?
[1991] AB02 4B,13           BR   CHAR2           No
[1992] AB04 0F,79           XML  PGMCHR          Skip ALL token
[1993] AB06 D6,42,B3        CEQ  COMMAZ,@CHAT    ,?
[1994] AB09 4C,AF           BR   ERRSYN          SYNTAX ERROR
[1995] AB0B 86,16           CLR  @PAD16          ALL FLAG
[1996] AB0D BF,14,00        DST  >0032,@VAR9     Starting char
       AB10 32
[1997] AB11 4B,1F           BR   CHAR1           Skip normal CHAR
[1998] AB13 BE,16,FF CHAR2  ST   >FF,@PAD16      No ALL flag
[1999] AB16 0F,74           XML  PARSE           Get char number 
[2000] AB18 B6              BYTE RPARZ
[2001] AB19 06,BC,AF        CALL S1ET9F          30 - 159?
[2002] AB1C BD,14,4A        DST  @FAC,@VAR9      Move to PAD2 30 - 159
[2003] AB1F 06,A2,B4 CHAR1  CALL STRGET          Check and get String
[2004] AB22 86,8F,DD CHARLD CLR  @>6004          Set ROM 3 page
       AB25 04
[2005] AB26 0F,81           XML  DCHAR 
[2006] AB28 D7,5C,99        DCEQ >994A,@ARG
       AB2B 4A
[2007] AB2C 6C,DF           BS   ERRBA           ERROR BAD ARGUEMENT
[2008] AB2E 8E,16           CZ   @PAD16          ALL FLAG?
[2009] AB30 4B,47           BR   CHARL4          NO
[2010] AB32 BF,16,04        DST  >0400,@PAD16    SET UP INDEX COUNTER
       AB35 00
[2011] AB36 35,00,08 CHRFIL MOVE 8,@>8300,V@0(@PAD16)
       AB39 E0,00,16
       AB3C 00
[2012] AB3D A3,16,00        DADD 8,@PAD16          COUNTER+8
       AB40 08
[2013] AB41 D7,16,07        DCEQ >0780,@PAD16     End of Char Table? 
       AB44 80
[2014] AB45 4B,36           BR   CHRFIL          No, loop
[2015] AB47 D6,42,B3 CHARL4 CEQ  COMMAZ,@CHAT    More specified?
[2016] AB4A 6A,FD           BS   CHAR5
[2017] AB4C 48,82           BR   LNKRTN          Return
[2018]               ***********************************************************
[2019]               *              SUBPROGRAM FOR 'KEY'                       *
[2020]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0035 
RXB 2024
[2021]               ***********************************************************
[2022]               * CALL KEY(key-unit,return-variable,status-variable,...)   
[2023]               * CALL KEY(string,key-unit,return-variable,status-variable,
[2024]               ***********************************************************
[2025] AB4E 06,BA,51 KEY    CALL SPAR              GET KEY UNIT
[2026]               * RXB PATCH LABEL ************
[2027] AB51 0F,7E    GABD1  XML  SPEED             Insure in range
[2028] AB53 02              BYTE RANGE          *   of 0 - 5
[2029] AB54 00              BYTE 0
[2030] AB55 00,05           DATA 5
[2031] AB57 06,B8,DB        CALL KEYJOY            Get variables for code and st
[2032]               *                              and scan keyboard
[2033]               *                             KEYJOY returns key status
[2034] AB5A 6B,65           BS   KEY1B             KEY STATUS = 1
[2035] AB5C 83,4A           DNEG @FAC              Assume status = -1
[2036] AB5E D6,75,FF        CEQ  >FF,@RKEY         But correct if = 0
[2037] AB61 4B,65           BR   KEY1B
[2038] AB63 87,4A           DCLR @FAC              KEY STATUS = 0
[2039] AB65 0F,7C    KEY1B  XML  ASSGNV            Assign value in variable
[2040] AB67 BF,4A,40        DST  >4001,@FAC        Re-store F.P. 1 in FAC
       AB6A 01
[2041] AB6B 8E,75           CZ   @RKEY             If key-code = 0
[2042] AB6D 6B,8D           BS   KEY2
[2043] AB6F D6,75,FF        CEQ  >FF,@RKEY         No key depressed,
[2044] AB72 6B,89           BS   KEY1C              key code assigned to -1
[2045]               * FORMAT FOR KEYCODES ABOVE 99 ADDED FOR 99/4A HIGHEST
[2046]               * KEYCODE (OTHER THAN >FF) IS >C6=198
[2047]               * 5/7/81
[2048] AB74 CA,75,64        CHE  100,@RKEY
[2049] AB77 4B,84           BR   GAC04
[2050] AB79 90,4A           INC  @FAC
[2051] AB7B A6,75,64        SUB  100,@RKEY
[2052] AB7E BC,4C,75        ST   @RKEY,@FAC2       FLOATING FORMAT (>4001__00000
[2053] AB81 05,AB,87        B    GAC07
[2054] AB84 BC,4B,75 GAC04  ST   @RKEY,@FAC1       FLOATING FORMAT (>40__0000000
[2055] AB87 4B,8F    GAC07  BR   KEY2A
[2056] AB89 83,4A    KEY1C  DNEG @FAC              KEY CODE ASSIGNED TO -1
[2057] AB8B 4B,8F           BR   KEY2A
[2058] AB8D 87,4A    KEY2   DCLR @FAC              (>000000000000000)
[2059] AB8F 0F,7C    KEY2A  XML  ASSGNV            ASSIGN VALUE TO VARIABLE
[2060]               * RXB PATCH CODE *************
[2061]               *      BR   LNKRTN
[2062] AB91 00              RTN
[2063]               ***********************************************************
[2064]               * INSURE LEFT PARENTHESIS AND THEN PARSE TO A COMMA
[2065]               ***********************************************************
[2066]               * RXB PATCH CODE
[2067] AB92 D6,42,B3 LPARR  CEQ  COMMAZ,@CHAT
[2068] AB95 6B,9D           BS   CPAR
[2069] AB97 0F,7E           XML  SPEED           *  Must be
[2070] AB99 00              BYTE SYNCHK          *  at a
[2071] AB9A B7              BYTE LPARZ           *    left parenthesis
[2072] AB9B 4B,A1           BR   CPAR2
[2073] AB9D 0F,7E    CPAR   XML  SPEED
[2074] AB9F 00              BYTE SYNCHK
[2075] ABA0 B3              BYTE COMMAZ
[2076]               * RXB PATCH LABEL ***********
[2077] ABA1 0F,74    CPAR2  XML  PARSE             Do the parse
[2078] ABA3 B3              BYTE COMMAZ          * Stop on a comma
[2079] ABA4 0F,7E           XML  SPEED           *  Must be
[2080] ABA6 00              BYTE SYNCHK          *  at a
[2081] ABA7 B3              BYTE COMMAZ          *    left comma
[2082] ABA8 00              RTN
[2083]               *****************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0036 
RXB 2024
[2084] ABA9 0F,7E    CPAR3  XML  SPEED           * Similar to LPARR
[2085] ABAB 00,B3           DATA COMMAZ          * Syntax check ,
[2086] ABAD 4B,A1           BR   CPAR2           * Parse value
[2087]               ***********************************************************
[2088]               * SUBROUTINE FOR 'RANGE' USED IN ALL SOUND AND GRAPHICS
[2089]               ***********************************************************
[2090] ABAF 0F,7E    RAN16  XML  SPEED             Insure in range
[2091] ABB1 02              BYTE RANGE          *   of 1 to 16
[2092] ABB2 01              BYTE 1
[2093] ABB3 00,10           DATA 16
[2094] ABB5 92,4B           DEC  @FAC1             Adjust to internal range
[2095] ABB7 00              RTN
[2096]               ***********************************************************
[2097]               * CALL SCREEN(background-color,...)                        
[2098]               * CALL SCREEN(ON,...)                                      
[2099]               * CALL SCREEN(OFF,...)                                     
[2100]               ***********************************************************
[2101]               *  Subroutine to control border color
[2102]               * Character background is also affected since transparent
[2103]               *  is used.
[2104] ABB8 D6,42,B7 BORDER CEQ  LPARZ,@CHAT     * If not '(' - error
[2105] ABBB 4C,AF           BR   ERRSYN          * ERROR SYNTAX
[2106] ABBD 06,A2,AE BORAGN CALL STRFCH          * Skip ( or , and get it  
[2107] ABC0 D7,B0,4E        DCEQ >4F46,V*FAC4    * OF? SCREEN OFF      
       ABC3 4F,46
[2108] ABC5 4B,CD           BR   SCRON           * No, check for ON
[2109] ABC7 B2,80,D4        AND  >BF,@VDPR1      * TURN OFF SCREEN
       ABCA BF
[2110] ABCB 4B,D8           BR   LDSCRN          * Return to XB program
[2111] ABCD D7,B0,4E SCRON  DCEQ >4F4E,V*FAC4    * ON? SCREEN ON
       ABD0 4F,4E
[2112] ABD2 4B,E0           BR   BORDES          * Must be a number
[2113] ABD4 B6,80,D4        OR   >40,@VDPR1      * TURN ON SCREEN
       ABD7 40
[2114] ABD8 3D,00,01 LDSCRN MOVE 1,@VDPR1,#1     * LOAD REGISTER 1
       ABDB 01,80,D4
[2115] ABDE 4B,E7           BR   BORCRN          * Return to XB program
[2116] ABE0 92,4B    BORDES DEC  @FAC1           * Adjust to internal range
[2117] ABE2 3D,00,01        MOVE 1,@FAC1,#7      * Load VDP register
       ABE5 07,4B
[2118] ABE7 D6,42,B3 BORCRN CEQ  >B3,@CHAT       * , COMMA?
[2119] ABEA 6B,BD           BS   BORAGN          * MORE SO REPEAT
[2120] ABEC 48,82           BR   LNKRTN          * Return to XB program
[2121]               ***********************************************************
[2122]               * ERRWXY - Is the subroutine for CALL ERR(W,X,Y,Z)
[2123]               *  The parameters indicate:
[2124]               *   W - The error code # of the error
[2125]               *   X - Indicates whether execution(-1) error or
[2126]               *       I/O (0-255) error on LUNO 0-255
[2127]               *   Y - Indicates the severity code of the error
[2128]               *   Z - Line number of the error
[2129]               *   ERR Can be called with 2 forms:
[2130]               *       CALL ERR(W,X,Y,Z) and CALL ERR(W,X)
[2131]               *   If ERR is called and no error has occured then all
[2132]               *   values returned are zero.
[2133]               ***********************************************************
[2134] ABEE BD,52,6E ERRWXY DST  @VSPTR,@FAC8      Get a temp VSPTR
[2135] ABF1 C5,52,24 GAC99  DCH  @STVSPT,@FAC8     While not a bottom of stack
[2136] ABF4 4C,28           BR   GACD0
[2137] ABF6 BC,5C,E0        ST   V@2(@FAC8),@ARG   Keep ID code in ARG area
       ABF9 02,52
[2138] ABFB D6,5C,69        CEQ  >69,@ARG          *** ERROR entry
[2139] ABFE 4C,07           BR   GACAF
[2140] AC00 06,A9,6D        CALL SQUISH            Squish it out of the stack

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0037 
RXB 2024
[2141] AC03 0F,77           XML  VPUSH             Put permanent copy of error
[2142]               *                              entry on stack
[2143] AC05 4C,34           BR   ERR10             Jump out now
[2144]               * Jump always
[2145] AC07 D6,5C,67 GACAF  CEQ  >67,@ARG          *** FOR entry
[2146] AC0A 4C,12           BR   GACBA
[2147] AC0C A7,52,00        DSUB 32,@FAC8          Skip it
       AC0F 20
[2148] AC10 4C,26           BR   GACCE
[2149] AC12 D6,5C,66 GACBA  CEQ  >66,@ARG          *** GOSUB entry
[2150] AC15 4C,1D           BR   GACC5
[2151] AC17 A7,52,00        DSUB 8,@FAC8           Skip it
       AC1A 08
[2152] AC1B 4C,26           BR   GACCE
[2153] AC1D D6,5C,6A GACC5  CEQ  >6A,@ARG          * SYNTAX ERROR
[2154] AC20 4C,AF           BR   ERRSYN
[2155] AC22 A7,52,00        DSUB 16,@FAC8          Skip it
       AC25 10
[2156] AC26 4B,F1    GACCE  BR   GAC99
[2157] AC28 BF,4A,00 GACD0  DST  >0080,@FAC        No error entry there so
       AC2B 80
[2158] AC2C BF,4C,69        DST  >6900,@FAC2        fake one
       AC2F 00
[2159] AC30 87,4E           DCLR @FAC4
[2160] AC32 87,50           DCLR @FAC6
[2161] AC34 0F,77    ERR10  XML  VPUSH             Push the temporary entry on
[2162]               *                              top of stack
[2163]               * Code to get "W" in
[2164] AC36 06,A9,67        CALL COMB              Check for left parenthesis
[2165] AC39 06,AC,A4        CALL ERRC05            Pick up user's symbol
[2166] AC3C BC,4B,EF        ST   V@-8(@VSPTR),@FAC1 Get error code
       AC3F FF,F8,6E
[2167] AC42 0F,80           XML  CIF               Convert it to floating
[2168] AC44 0F,7C           XML  ASSGNV            Assign it
[2169]               * Code to get "X" in
[2170] AC46 06,AC,9F        CALL ERRCOM            Check syntax & get user's sym
[2171] AC49 DA,EF,FF        CLOG >80,V@-7(@VSPTR)  If execution
       AC4C F9,6E,80
[2172] AC4F 4C,5B           BR   GAD03
[2173] AC51 31,00,08        MOVE 8,G@FLT1,@FAC     Make it such
       AC54 4A,A3,32
[2174] AC57 83,4A           DNEG @FAC              Make it a negative
[2175] AC59 4C,63           BR   GAD0B
[2176] AC5B BC,4B,EF GAD03  ST   V@-5(@VSPTR),@FAC1 Get I/O LUNO number
       AC5E FF,FB,6E
[2177] AC61 0F,80           XML  CIF               Convert it to floating
[2178] AC63 0F,7C    GAD0B  XML  ASSGNV
[2179]               * Code to get "Y" in
[2180] AC65 D6,42,B6        CEQ  RPARZ,@CHAT       If long form of CALL ERR
[2181] AC68 6C,9A           BS   GAD42
[2182] AC6A 06,AC,9F        CALL ERRCOM            Check syntax & get user's sym
[2183] AC6D BC,4B,EF        ST   V@-7(@VSPTR),@FAC1 Get severity code
       AC70 FF,F9,6E
[2184] AC73 B2,4B,7F        AND  >7F,@FAC1         Reset execution  /  I/O flag
[2185] AC76 0F,80           XML  CIF               Convert it
[2186] AC78 0F,7C           XML  ASSGNV            Assign it
[2187]               * Code to get "Z" in
[2188] AC7A 06,AC,9F        CALL ERRCOM            Check syntax & get symbol
[2189] AC7D BD,4C,EF        DST  V@-2(@VSPTR),@FAC2 Get line pointer
       AC80 FF,FE,6E
[2190] AC83 BD,4A,4C        DST  @FAC2,@FAC
[2191] AC86 8F,4C           DCZ  @FAC2             If line number exists
[2192] AC88 6C,96           BS   GAD3E
[2193] AC8A 97,4C           DDECT @FAC2            Point to the line #

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0038 
RXB 2024
[2194] AC8C 06,60,34        CALL GRSUB1            Read line # (2 bytes) from VD
[2195]               *                              or ERAM (use GREAD)
[2196] AC8F 4C              BYTE >4C             * @FAC2: Source addr on ERAM/VD
[2197] AC90 BD,4A,50        DST  @EEE,@FAC         Put the line # in FAC
[2198] AC93 B2,4A,7F        AND  >7F,@FAC          Reset the breakpoint if any
[2199] AC96 0F,80    GAD3E  XML  CIF               Convert it
[2200] AC98 0F,7C           XML  ASSGNV            Assign it
[2201] AC9A 0F,78    GAD42  XML  VPOP              Trash the temporary entry
[2202] AC9C 05,A8,82        B    LNKRTN            Return from subprogram
[2203]               * Must be long branch because of AND above
[2204] AC9F D6,42,B3 ERRCOM CEQ  COMMAZ,@CHAT      Check for comma
[2205] ACA2 4C,AF           BR   ERRSYN
[2206] ACA4 0F,79    ERRC05 XML  PGMCHR            Get the next character
[2207] ACA6 0F,7A           XML  SYM               Collect name & s.t. entry
[2208] ACA8 0F,7B           XML  SMB               Get value space
[2209] ACAA 0F,77           XML  VPUSH             Push it
[2210] ACAC 86,4A           CLR  @FAC              Set up for conversion
[2211] ACAE 00              RTN
[2212]               * CHANGE IN ADDRESS OF THE ERROR CALLS WILL AFFECT
[2213]               * THE FILE SUBS.....
[2214]               *     ERROR messages called from this file
[2215] ACAF 06,6A,84 ERRSYN CALL ERRZZ             * SYNTAX ERROR
[2216] ACB2 03              BYTE 3             *   (shared by SUBS)
[2217] ACB3 06,6A,84 ERRSNM CALL ERRZZ             * STRING-NUMBER MISMATCH
[2218] ACB6 07              BYTE 7             *   (shared by SUBS)
[2219] ACB7 06,6A,84 ERRMUV CALL ERRZZ             * IMPROPERLY USED NAME
[2220] ACBA 09              BYTE 9
[2221] ACBB 06,6A,84 ERRMEM CALL ERRZZ             * MEMORY FULL
[2222] ACBE 0B              BYTE 11
[2223] ACBF 06,6A,84 ERRSO  CALL ERRZZ             * STACK OVERFLOW
[2224] ACC2 0C              BYTE 12
[2225] ACC3 06,6A,84 ERRNWF CALL ERRZZ             * NEXT WITHOUT FOR
[2226] ACC6 0D              BYTE 13
[2227] ACC7 06,6A,84 ERRFNN CALL ERRZZ             * FOR/NEXT NESTING
[2228] ACCA 0E              BYTE 14
[2229] ACCB 06,6A,84 ERRSNS CALL ERRZZ             * MUST BE IN SUBPROGRAM
[2230] ACCE 0F              BYTE 15
[2231] ACCF 06,6A,84 ERRRSC CALL ERRZZ             * RECURSIVE SUBPROGRAM CALL
[2232] ACD2 10              BYTE 16
[2233] ACD3 06,6A,84 ERRRWG CALL ERRZZ             * RETURN WITHOUT GOSUB
[2234] ACD6 12              BYTE 18
[2235] ACD7 06,6A,84 ERRBS  CALL ERRZZ             * BAD SUBSCRIPT
[2236] ACDA 14              BYTE 20
[2237] ACDB 06,6A,84 ERRLNF CALL ERRZZ             * LINE NOT FOUND
[2238] ACDE 16              BYTE 22
[2239] ACDF 06,6A,84 ERRBA  CALL ERRZZ             * BAD ARGUMENTS
[2240] ACE2 1C              BYTE 28
[2241] ACE3 06,6A,84 ERRBV  CALL ERRZZ             * BAD VALUE
[2242] ACE6 1E              BYTE 30            *   (shared by SUBS)
[2243] ACE7 06,6A,84 ERRIAL CALL ERRZZ             * INCORRECT ARGUMENT LIST
[2244] ACEA 1F              BYTE 31            *   (shared by SUBS)
[2245] ACEB 06,6A,84 ERRSNF CALL ERRZZ             * SUBPROGRAM NOT FOUND
[2246] ACEE 25              BYTE 37
[2247]               * Other error messages appear in this program
[2248]               * ERRRDY      * READY                        DATA 0
[2249]               * ERRBRK      * BREAK POINT                  DATA 1
[2250]               * ERROLP      * ONLY LEGAL IN A PROGRAM      DATA 27
[2251]               *
[2252]               * WRNN01      * NUMERIC OVERFLOW             DATA 2
[2253]               * WRNS02
[2254]               * WRNST1      * STRING TRUNCATED             DATA 19
[2255]               * WRNST2
[2256]               * WRNLNF      * LINE NOT FOUND               DATA 38
[2257]               *

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0039 
RXB 2024
[2258]               ***********************************************************
[2259]               * SUBROUTINE LINK LIST
[2260] ACEF AC,FA    LINKS1 DATA LINKS2
[2261] ACF1 06,53,50        STRI 'SPRITE'         SPRITE
       ACF4 52,49,54
       ACF7 45
[2262] ACF8 AE,35           DATA SPRTE
[2263] ACFA AD,08    LINKS2 DATA LINKS3
[2264] ACFC 09,44,45        STRI 'DELSPRITE'      DELSPRITE
       ACFF 4C,53,50
       AD02 52,49,54
       AD05 45
[2265] AD06 AE,66           DATA SPRDEL
[2266] AD08 AD,15    LINKS3 DATA LINKS4
[2267] AD0A 08,50,4F        STRI 'POSITION'       POSITION
       AD0D 53,49,54
       AD10 49,4F,4E
[2268] AD13 AE,8E           DATA SPRPOS
[2269] AD15 AD,1F    LINKS4 DATA LINKS5
[2270] AD17 05,43,4F        STRI 'COINC'          CONIC
       AD1A 49,4E,43
[2271] AD1D B8,B5           DATA ZSCOI
[2272] AD1F AD,2B    LINKS5 DATA LINKS6
[2273] AD21 07,4D,41        STRI 'MAGNIFY'        MAGNIFY
       AD24 47,4E,49
       AD27 46,59
[2274] AD29 AF,04           DATA SPRMAG
[2275] AD2B AD,36    LINKS6 DATA LINKS7
[2276] AD2D 06,4D,4F        STRI 'MOTION'         MOTION
       AD30 54,49,4F
       AD33 4E
[2277] AD34 AF,21           DATA SPRMOV
[2278] AD36 AD,41    LINKS7 DATA LINKS8
[2279] AD38 06,4C,4F        STRI 'LOCATE'         LOCATE
       AD3B 43,41,54
       AD3E 45
[2280] AD3F AF,31           DATA SPRLOC
[2281] AD41 AD,4D    LINKS8 DATA LINKS9
[2282] AD43 07,50,41        STRI 'PATTERN'        PATTERN
       AD46 54,54,45
       AD49 52,4E
[2283] AD4B AF,45           DATA SPRPAT
[2284] AD4D AD,5A    LINKS9 DATA LINKSA
[2285] AD4F 08,44,49        STRI 'DISTANCE'       DISTANCE
       AD52 53,54,41
       AD55 4E,43,45
[2286] AD58 B8,C4           DATA ZDIST
[2287] AD5A AD,62    LINKSA DATA LINKSB
[2288] AD5C 03,53,41        STRI 'SAY'            SAY
       AD5F 59
[2289] AD60 B0,C0           DATA SAY
[2290] AD62 AD,6C    LINKSB DATA LINKSC
[2291] AD64 05,53,50        STRI 'SPGET'          SPGET   
       AD67 47,45,54
[2292] AD6A B2,17           DATA SPGET
[2293] AD6C AD,78    LINKSC DATA LINKSD
[2294] AD6E 07,43,48        STRI 'CHARSET'        CHARSET
       AD71 41,52,53
       AD74 45,54
[2295] AD76 AF,BD           DATA CHRSET
[2296] AD78 AD,82    LINKSD DATA LINKSE
[2297] AD7A 05,4F,4E        STRI 'ONKEY'          ONKEY
       AD7D 4B,45,59
[2298] AD80 B9,3C           DATA  ZONKEY

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0040 
RXB 2024
[2299] AD82 AD,8C    LINKSE DATA LINKSF
[2300] AD84 05,4D,4F        STRI 'MOVES'          MOVES
       AD87 56,45,53
[2301] AD8A B5,11           DATA MOVES
[2302] AD8C AD,95    LINKSF DATA LINKSG
[2303] AD8E 04,48,50        STRI 'HPUT'           HPUT
       AD91 55,54
[2304] AD93 B7,90           DATA HPUTZ
[2305] AD95 AD,9E    LINKSG DATA LINKSH
[2306] AD97 04,56,50        STRI 'VPUT'           VPUT
       AD9A 55,54
[2307] AD9C B7,A0           DATA VPUTZ
[2308] AD9E AD,A7    LINKSH DATA LINKSI
[2309] ADA0 04,48,47        STRI 'HGET'           HGET
       ADA3 45,54
[2310] ADA5 B7,DD           DATA HGETZ 
[2311] ADA7 AD,B0    LINKSI DATA LINKSJ
[2312] ADA9 04,56,47        STRI 'VGET'           VGET
       ADAC 45,54
[2313] ADAE B7,F0           DATA VGETZ
[2314] ADB0 AD,BC    LINKSJ DATA LINKSK
[2315] ADB2 07,47,4D        STRI 'GMOTION'        GMOTION
       ADB5 4F,54,49
       ADB8 4F,4E
[2316] ADBA B8,22           DATA GMOT
[2317] ADBC AD,C8    LINKSK DATA LINKSL
[2318] ADBE 07,52,4D        STRI 'RMOTION'        RMOTION
       ADC1 4F,54,49
       ADC4 4F,4E
[2319] ADC6 B8,59           DATA RMOT
[2320] ADC8 AD,D0    LINKSL DATA LINKSM
[2321] ADCA 03,48,45        STRI 'HEX'            HEX
       ADCD 58
[2322] ADCE B5,FE           DATA HEX
[2323] ADD0 AD,D7    LINKSM DATA LINKSN
[2324] ADD2 02,49,4F        STRI 'IO'             IO
[2325] ADD5 B6,CB           DATA RXBIO
[2326] ADD7 AD,E5    LINKSN DATA LINKSO
[2327] ADD9 09,4A,4F        STRI 'JOYMOTION'      JOYMOTION
       ADDC 59,4D,4F
       ADDF 54,49,4F
       ADE2 4E
[2328] ADE3 BA,78           DATA ZJOMO
[2329] ADE5 AD,F3    LINKSO DATA LINKSP
[2330] ADE7 09,4A,4F        STRI 'JOYLOCATE'      JOYLOCATE 
       ADEA 59,4C,4F
       ADED 43,41,54
       ADF0 45
[2331] ADF1 BB,32           DATA ZJOLO
[2332] ADF3 AD,FF    LINKSP DATA LINKSQ
[2333] ADF5 07,49,4E        STRI 'INVERSE'        INVERSE
       ADF8 56,45,52
       ADFB 53,45
[2334] ADFD BB,D4           DATA INVERS
[2335] ADFF AE,0C    LINKSQ DATA LINKSR
[2336] AE01 08,53,57        STRI 'SWAPCHAR'       SWAPCHAR
       AE04 41,50,43
       AE07 48,41,52
[2337] AE0A BC,11           DATA SWCHR
[2338] AE0C AE,1A    LINKSR DATA LINKSS       
[2339] AE0E 09,53,57        STRI 'SWAPCOLOR'      SWAPCOLOR
       AE11 41,50,43
       AE14 4F,4C,4F
       AE17 52

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0041 
RXB 2024
[2340] AE18 BC,43           DATA SWCLR
[2341] AE1A AE,29    LINKSS DATA LINKST
[2342] AE1C 0A,43,4C        STRI 'CLEARPRINT'     CLEARPRINT       
       AE1F 45,41,52
       AE22 50,52,49
       AE25 4E,54
[2343] AE27 A9,90           DATA  CLRPZ
[2344] AE29 C0,10    LINKST DATA >C010  * LINK LIST IN >C000          
[2345] AE2B 07,43,4F        STRI 'COLLIDE'        COLLIDE
       AE2E 4C,4C,49
       AE31 44,45
[2346] AE33 BC,BD           DATA COLLZ
[2347]               ***********************************************************
[2348]               * CALL SPRITE(#SPRITE,CHAR,COLOR,Y,X,(YSPEED,XSPEED),...) *
[2349]               ***********************************************************
[2350] AE35 06,A9,67 SPRTE  CALL COMB             Check sprite mode and skip "(
[2351] AE38 06,B0,06        CALL SPNUM2            Get sprite number
[2352] AE3B 06,B0,3C SPRT3  CALL SPCHR             Put character number for spri
[2353] AE3E 0F,7E           XML  SPEED             Check for comma and skip it
[2354] AE40 00              BYTE SYNCHK
[2355] AE41 B3              BYTE COMMAZ        
[2356] AE42 06,A8,FA        CALL SPCOL             Put sprite color in SAL(SPCOL
[2357] AE45 0F,7E           XML  SPEED             Insure at a comma  
[2358] AE47 00              BYTE SYNCHK          * Syntax checker
[2359] AE48 B3              BYTE COMMAZ          * Only COMMA is valid
[2360] AE49 06,B0,1F        CALL SPLOC             Put location of sprite in SAL
[2361] AE4C BD,B0,08        DST  @PAD4+1,V*PAD8    Put in location of sprite
       AE4F 05
[2362]               * Finish defining SAL. Check if velocity is specified
[2363] AE50 D6,42,B3 SPRT4  CEQ  COMMAZ,@CHAT      Finished!!!!!
[2364] AE53 48,82           BR   LNKRTN
[2365] AE55 0F,79           XML  PGMCHR            Skip COMMA
[2366] AE57 D6,42,FD        CEQ  NUMBEZ,@CHAT      Next sprite specified
[2367] AE5A 4E,61           BR   GAEBB
[2368] AE5C 06,B0,0D        CALL SPNUM3            Get the next sprite number
[2369] AE5F 4E,3B           BR   SPRT3             And go!
[2370] AE61 06,B0,4E GAEBB  CALL SPMOVE            Get the velocity first
[2371] AE64 4E,50           BR   SPRT4
[2372]               ***********************************************************
[2373]               * CALL DELSPRITE(#SPR,...)                                *
[2374]               * CALL DESPRITE(ALL)                                      *
[2375]               ***********************************************************
[2376] AE66 06,A9,67 SPRDEL CALL COMB              Insure at '('
[2377] AE69 0F,79    SPDEL1 XML  PGMCHR            Skip "(" or ","
[2378] AE6B D6,42,FD        CEQ  NUMBEZ,@CHAT      If sprite number
[2379] AE6E 4E,85           BR   GAEF6             No, must be ALL  
[2380] AE70 0F,79           XML  PGMCHR            Skip "#"
[2381] AE72 0F,74           XML  PARSE             Parse the sprite number
[2382] AE74 B6              BYTE RPARZ
[2383] AE75 06,B0,12        CALL SPNUM4            Check and convert number
[2384]               * Sprite handling code for speeeding up XB   2/4/2024
[2385] AE78 86,8F,DD        CLR  @>6004          * SET ROM 3 ON
       AE7B 04
[2386] AE7C 0F,84           XML  SPDEL           * ASSEMBLY REPLACEMENT
[2387] AE7E D6,42,B3 SPDEL2 CEQ  COMMAZ,@CHAT      If more sprites
[2388] AE81 6E,69           BS   SPDEL1            LOOP
[2389] AE83 48,82           BR   LNKRTN            Return to caller
[2390] AE85 0F,7E    GAEF6  XML  SPEED             Must have 'ALL' else error
[2391] AE87 00              BYTE SYNCHK
[2392] AE88 EC              BYTE ALLZ
[2393] AE89 06,60,16        CALL SPRINT            Reinitialize all sprites
[2394] AE8C 48,82    GAEFD  BR   LNKRTN            Return to caller
[2395]               ***********************************************************
[2396]               * CALL POSTION(#SPR,Y,X,...)                              *

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0042 
RXB 2024
[2397]               ***********************************************************
[2398] AE8E 06,A9,67 SPRPOS CALL COMB             Check for sprites and skip "(
[2399] AE91 06,B0,06 SPRP02 CALL SPNUM2            Check sprite number
[2400] AE94 06,B0,AD        CALL PREPN             Prepare Y-position return v  
[2401] AE97 0F,7E           XML  SPEED           * SPEED CHECK
[2402] AE99 00              BYTE SYNCHK          * Syntax checker
[2403] AE9A B3              BYTE COMMAZ          * Only COMMA is valid
[2404] AE9B BD,00,B0        DST  V*PAD8,@PAD       Read X, Y position
       AE9E 08
[2405] AE9F BC,4B,00        ST   @PAD,@FAC1        Get Y position
[2406] AEA2 D6,4B,FE        CEQ  >FE,@FAC1
[2407] AEA5 4E,AB           BR   GAF1C
[2408] AEA7 95,4A           DINCT @FAC             Get 256 as an output
[2409] AEA9 4E,AD           BR   GAF1E
[2410] AEAB 94,4B    GAF1C  INCT @FAC1             Regular adjustment for user
[2411] AEAD 06,AE,C2 GAF1E  CALL SPRP03            Check, convert & assign value
[2412] AEB0 06,B0,AD        CALL PREPN             Prepare X-pos return variable
[2413] AEB3 BC,4B,01        ST   @PAD+1,@FAC1      Get X position
[2414] AEB6 91,4A           DINC @FAC              Adjust for the user
[2415] AEB8 06,AE,C2        CALL SPRP03            Check, convert & assign value
[2416] AEBB D6,42,B3        CEQ  COMMAZ,@CHAT      If not finished
[2417] AEBE 6E,91           BS   SPRP02
[2418] AEC0 48,82           BR   LNKRTN             
[2419] AEC2 0F,80    SPRP03 XML  CIF               Convert integer to float
[2420] AEC4 D7,00,C0        DCEQ >C000,@PAD        If hidden sprite
       AEC7 00
[2421] AEC8 4E,CC           BR   GAF3D
[2422] AECA 87,4A           DCLR @FAC              Return value zero
[2423] AECC 0F,7C    GAF3D  XML  ASSGNV            Assign to variable
[2424] AECE 00              RTN
[2425]               ***********************************************************
[2426]               * CALL COINC(#SPR,#SPR,TOLERANCE,CODE,...)                *
[2427]               * CALL COINC(#SPR,YLOC,XLOC,TOLERANCE,CODE,...)           *
[2428]               * CALL COINC(ALL,variable,...)                            *
[2429]               ***********************************************************
[2430] AECF 06,A9,67 SPRCOI CALL COMB              (?
[2431] AED2 0F,79           XML  PGMCHR            Skip "("
[2432] AED4 D6,42,EC        CEQ  ALLZ,@CHAT        Check coinc of all sprites
[2433] AED7 4E,E5           BR   GAF56
[2434] AED9 0F,79           XML  PGMCHR            Skip "ALL"
[2435] AEDB 06,B0,97        CALL COMMA2            Check and skip ","
[2436] AEDE DA,7B,20        CLOG >20,@VDPSTT       Check VDP status
[2437] AEE1 70,A7           BS   NR
[2438] AEE3 4E,FB           BR   GAF6C
[2439] AEE5 06,AF,7D GAF56  CALL CODIST            Get distance of 2 sprites
[2440] AEE8 06,B0,94        CALL COMMA             Get tolerance level
[2441] AEEB 0F,7E           XML  SPEED
[2442] AEED 02              BYTE RANGE           * Check against range
[2443] AEEE 00              BYTE 0               * FAC has tolerance level
[2444] AEEF 00,FF           DATA 255
[2445] AEF1 C5,00,4A        DCH  @FAC,@PAD         Y-loc out of range
[2446] AEF4 70,A7           BS   NR
[2447] AEF6 C5,04,4A        DCH  @FAC,@PAD4        X-loc out of range
[2448] AEF9 70,A7           BS   NR
[2449]               * If no conincidence just return zero
[2450] AEFB 06,B0,AD GAF6C  CALL PREPN             Prepare for numeric output
[2451] AEFE BF,4A,BF        DST  >BFFF,@FAC        Store -1 in FAC
       AF01 FF
[2452] AF02 50,AA           BR   AR
[2453]               ***********************************************************
[2454]               * CALL MAGNIFY(magnification factor=1 - 4)                *
[2455]               * CALL MAGNIFY(number,number,number)                      *
[2456]               * CALL MAGNIFY(variable,variable,variable)                *
[2457]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0043 
RXB 2024
[2458] AF04 06,A9,67 SPRMAG CALL COMB             Insure at "("
[2459] AF07 0F,79    SPRMLP XML  PGMCHR            Skip the "("
[2460] AF09 0F,74           XML  PARSE             Parse the magnification facto
[2461] AF0B B6              BYTE RPARZ          
[2462] AF0C 0F,7E           XML  SPEED
[2463] AF0E 02              BYTE RANGE            * Magnification 1 to 4
[2464] AF0F 01              BYTE 1              
[2465] AF10 00,04           DATA 4
[2466]               * Next statement adding >DF to subtract 1 from FAC
[2467] AF12 A2,4B,DF        ADD  >DF,@FAC1         Turn on screen and interrupt
[2468] AF15 3D,00,01        MOVE 1,@FAC1,#1        Store it to VDP register 1
       AF18 01,4B
[2469] AF1A D6,42,B3        CEQ  COMMAZ,@CHAT      COMMA?
[2470] AF1D 6F,07           BS   SPRMLP            Yes, loop
[2471] AF1F 48,82           BR   LNKRTN            Return to XB
[2472]               ***********************************************************
[2473]               * CALL MOTION(#SPR,YSPEED,XSPEED,...)                     *
[2474]               ***********************************************************
[2475] AF21 06,A9,67 SPRMOV CALL COMB              Insure at "("
[2476] AF24 05,B9,FF SPRMV2 B    SPGS              # or ALL or GO or STOP
[2477] AF27 06,B0,4E SPRMV3 CALL SPMOVE            Store velocity
[2478] AF2A D6,42,B3 SPRMV4 CEQ  COMMAZ,@CHAT      Loop if more
[2479] AF2D 6F,24           BS   SPRMV2
[2480] AF2F 48,82           BR   LNKRTN
[2481]               ***********************************************************
[2482]               * CALL LOCATE(#SPR,YLOC,XLOC,...)                         *
[2483]               ***********************************************************
[2484] AF31 06,A9,67 SPRLOC CALL COMB              Insure at "("
[2485] AF34 06,B0,06 SPRLC2 CALL SPNUM2            Check sprite number
[2486] AF37 06,B0,1F        CALL SPLOC             Read location
[2487] AF3A BD,B0,08        DST  @PAD4+1,V*PAD8    Put in sprite location
       AF3D 05
[2488] AF3E D6,42,B3        CEQ  COMMAZ,@CHAT      Loop if more
[2489] AF41 6F,34           BS   SPRLC2
[2490] AF43 48,82           BR   LNKRTN
[2491]               ***********************************************************
[2492]               * CALL PATTERN(#SPR,CHAR,...)                             *
[2493]               ***********************************************************
[2494] AF45 06,A9,67 SPRPAT CALL COMB             Insure at "("
[2495] AF48 06,B0,06 SPRPT2 CALL SPNUM2            Get sprite number
[2496] AF4B 06,B0,3C        CALL SPCHR             Set the sprite character
[2497] AF4E D6,42,B3        CEQ  COMMAZ,@CHAT      Loop if more
[2498] AF51 6F,48           BS   SPRPT2
[2499] AF53 48,82           BR   LNKRTN
[2500]               ***********************************************************
[2501]               * CALL DISTANCE(#1,#2,DISTANCE,...)                       *
[2502]               * CALL DISTANCE(#1,Y,X,DISTANCE,...)                      *
[2503]               ***********************************************************
[2504] AF55 06,A9,67 DIST   CALL COMB             Insure at "("
[2505]               * RXB PATCH LABEL ************
[2506] AF58 0F,79    GAFC4  XML  PGMCHR            Skip "("
[2507] AF5A 06,AF,7D        CALL CODIST            Get distance in Y and X
[2508] AF5D 06,B0,AD        CALL PREPN             Prepare return variable
[2509] AF60 A9,00,00        DMUL @PAD,@PAD         X=X*X
[2510] AF63 A9,04,04        DMUL @PAD4,@PAD4       Y=Y*Y
[2511] AF66 A1,02,06        DADD @PAD6,@PAD2       @PAD2=X*X+Y*Y
[2512] AF69 0D              OVF                    Checking overflow bit
[2513] AF6A 6F,75           BS   OVER              If overflow-indicate maximum
[2514] AF6C BD,4A,02        DST  @PAD2,@FAC        Put distance squared in FAC
[2515] AF6F C7,02,7F        DCH  >7FFF,@PAD2       If bigger then 128
       AF72 FF
[2516] AF73 4F,79           BR   GAFE5
[2517] AF75 BF,4A,7F OVER   DST  >7FFF,@FAC        Put maximum value
       AF78 FF

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0044 
RXB 2024
[2518] AF79 0F,80    GAFE5  XML  CIF               Convert to floating format
[2519]               * RXB PATCH CODE
[2520]               *      BR   ASSRTN            Assign value and return
[2521] AF7B 50,AA           BR   AR
[2522]               ***********************************************************
[2523]               * CODIST routine gets locations of two sprites or one
[2524]               *  sprite and Y and X position specified by a user and
[2525]               *  calculates absolute value of Y and X distance.
[2526]               ***********************************************************
[2527] AF7D 86,00    CODIST CLR  @PAD
[2528] AF7F 35,00,07        MOVE 7,@PAD,@PAD+1     Clear up first 8 bytes
       AF82 01,00
[2529] AF84 D6,42,FD        CEQ  NUMBEZ,@CHAT      Check for #
[2530] AF87 4C,AF           BR   ERRSYN
[2531] AF89 06,B0,0D        CALL SPNUM3            Get the first sprite
[2532] AF8C BD,01,B0        DST  V*PAD8,@PAD+1     Location of first sprite
       AF8F 08
[2533] AF90 90,01           INC  @PAD+1            Increment to make range 1-256
[2534] AF92 BC,03,02        ST   @PAD2,@PAD2+1     Put X in PAD2+1
[2535] AF95 86,02           CLR  @PAD2             Y in PAD+1
[2536] AF97 D6,42,FD        CEQ  NUMBEZ,@CHAT      Get 2nd sprite
[2537] AF9A 4F,A5           BR   CODIS1
[2538] AF9C 06,B0,0D        CALL SPNUM3            Get the next sprite
[2539] AF9F BD,05,B0        DST  V*PAD8,@PAD4+1    Location of second sprite
       AFA2 08
[2540] AFA3 4F,AB           BR   CODIS2
[2541] AFA5 06,B0,1F CODIS1 CALL SPLOC             Get Y and X location
[2542] AFA8 06,B0,97        CALL COMMA2            Check for comma and skip
[2543] AFAB 90,05    CODIS2 INC  @PAD4+1           Increment to make range 1-256
[2544] AFAD A5,00,04        DSUB @PAD4,@PAD        Difference in Y at PAD
[2545] AFB0 81,00           DABS @PAD              Get absolute value
[2546] AFB2 86,05           CLR  @PAD4+1           Clear byte before X
[2547] AFB4 A5,05,02        DSUB @PAD2,@PAD4+1     Difference in Y at PAD4
[2548] AFB7 81,05           DABS @PAD4+1           get the absolute value
[2549] AFB9 BC,05,06        ST   @PAD6,@PAD4+1     Put in the right place
[2550] AFBC 00              RTN
[2551]               ***********************************************************
[2552]               * CHRSET restores the standard character set and the
[2553]               *  standard colors for the standard character set
[2554]               *  (black on transparent)
[2555]               ***********************************************************
[2556]               * CALL CHARSET                                            *
[2557]               * CALL CHARSET(ALL) * RXB ADDITION *                      *
[2558]               ***********************************************************
[2559]               * RXB PATCH CODE ADDTION OF CALL CHARSET(ALL) *************
[2560] AFBD D6,42,B7 CHRSET CEQ  LPARZ,@CHAT   * (?
[2561] AFC0 6F,D9           BS   CHRALL        * Yes, CHARSET(ALL)
[2562] AFC2 86,8F,DD        CLR  @>6004       * SET ROM 3 ON
       AFC5 04
[2563] AFC6 0F,7F           XML  CHRLDR       * LOAD ROM 3 Definitions
[2564] AFC8 BE,A8,0F        ST   >10,V@>080F  * Set 1st black on transparent
       AFCB 10
[2565] AFCC 35,00,10        MOVE 16,V@>080F,V@>0810 * Ripple for rest
       AFCF A8,10,A8
       AFD2 0F
[2566] AFD3 06,6A,78        CALL CHKEND        * Must be at EOS now
[2567] AFD6 06,00,12        CALL RETURN        * Return to the caller
[2568]               *******************************************************   
[2569] AFD9 0F,79    CHRALL XML  PGMCHR        * Skip (
[2570] AFDB D6,42,EC        CEQ  ALLZ,@CHAT    * ALL?
[2571] AFDE 4C,AF           BR   ERRSYN        * No Syntax error
[2572] AFE0 0F,79           XML  PGMCHR        * Skip ALL token up to )
[2573] AFE2 86,8F,DD        CLR  @>6004        * SET ROM 3 ON
       AFE5 04

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0045 
RXB 2024
[2574] AFE6 0F,7F           XML  CHRLDR        * LOAD ROM 3 Definitions 
[2575] AFE8 86,A7,00        CLR  V@>0700       * Clear byte
[2576] AFEB 35,00,FF        MOVE 255,V@>0700,V@>0701 * Ripple the rest
       AFEE A7,01,A7
       AFF1 00
[2577] AFF2 BE,A8,0F        ST   >10,V@>080F * Set 1st Black on Transparent
       AFF5 10
[2578] AFF6 35,00,10        MOVE 16,V@>080F,V@>0810 * Ripple the rest
       AFF9 A8,10,A8
       AFFC 0F
[2579] AFFD 31,00,08        MOVE 8,G@>635C,V@>03F0 Cursor character
       B000 A3,F0,63
       B003 5C
[2580] B004 48,82           BR   LNKRTN        * RETURN
[2581]               *******************************************************
[2582]               * OLD SPNUM1 REPLACED WITH COMB NOW *
[2583]               *************************************
[2584]               * SPNUM2 ROUTINE             *
[2585]               ******************************
[2586] B006 0F,79    SPNUM2 XML  PGMCHR            Get the next character
[2587] B008 D6,42,FD SPNUM6 CEQ  NUMBEZ,@CHAT      Must be "#"
[2588] B00B 4C,AF           BR   ERRSYN
[2589] B00D 0F,79    SPNUM3 XML  PGMCHR            Skip character # or ( or ,
[2590] B00F 06,B0,94        CALL COMMA             Parse up to comma and skip it
[2591] B012 0F,7E    SPNUM4 XML  SPEED
[2592] B014 02              BYTE RANGE           * Verify the value is in range
[2593] B015 01              BYTE 1               * Sprite number 1 - 28
[2594] B016 00,1C           DATA 28
[2595]               *----------------------------------------------------------
[2596]               * Sprite handling code for speeeding up XB   2/4/2024
[2597] B018 86,8F,DD SPNUM5 CLR  @>6004          * SET ROM 3 ON
       B01B 04
[2598] B01C 0F,83           XML  SPSPD5          * ASSEMBLY REPLACEMENT
[2599] B01E 00              RTN
[2600]               ******************************
[2601]               * SPLOC ROUTINE              *
[2602]               ******************************
[2603] B01F 06,B0,94 SPLOC  CALL COMMA             Parse up to comma and skip it
[2604] B022 0F,7E    SPLOC2 XML  SPEED
[2605] B024 02              BYTE RANGE           * Range of Y: 1 - 256
[2606] B025 01              BYTE 1
[2607] B026 01,00           DATA 256
[2608] B028 96,4B           DECT @FAC1             Adjust for internal use: FF -
[2609] B02A BD,04,4A        DST  @FAC,@PAD4        Store in PAD4 area
[2610] B02D 0F,74           XML  PARSE
[2611] B02F B6              BYTE RPARZ           * Parse to ")" or less
[2612] B030 0F,7E           XML  SPEED
[2613] B032 02              BYTE RANGE           * Get X value. Range: 1 - 256
[2614] B033 01              BYTE 1
[2615] B034 01,00           DATA 256
[2616] B036 92,4B           DEC  @FAC1             Adjust for internal use: 0 -
[2617] B038 BC,06,4B        ST   @FAC1,@PAD6       PAD4+1=Y-loc and PAD6=X-loc
[2618] B03B 00              RTN
[2619]               ******************************
[2620]               * SPCHR ROUTINE              *
[2621]               ******************************
[2622] B03C 0F,74    SPCHR  XML  PARSE
[2623] B03E B6              BYTE RPARZ
[2624] B03F 0F,7E           XML  SPEED
[2625] B041 02              BYTE RANGE           * Check upper range
[2626] B042 1E              BYTE 30
[2627] B043 00,9F           DATA 159
[2628] B045 A2,4B,60        ADD  >60,@FAC1         Add offset to character numbe
[2629] B048 BC,E0,02        ST   @FAC1,V@2(@PAD8)  Store the character value

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0046 
RXB 2024
       B04B 08,4B
[2630] B04D 00              RTN
[2631]               ******************************
[2632]               * SPMOVE ROUTINE             *
[2633]               ******************************
[2634] B04E 06,B0,94 SPMOVE CALL COMMA             Parse up to comma and skip
[2635] B051 06,B0,70        CALL RANGEV            Check if numeric and convert
[2636]               *                              to integer
[2637] B054 BC,0A,4B        ST   @FAC1,@PADA       Store Y velocity
[2638] B057 0F,74           XML  PARSE             Get X velocity
[2639] B059 B6              BYTE RPARZ           * Check for ")" or less
[2640] B05A 06,B0,70        CALL RANGEV            Numeric check and convert
[2641]               *                              to integer
[2642] B05D BC,4A,0A        ST   @PADA,@FAC      * @FAC=Y velocity, @FAC1=X velo
[2643] B060 BD,E4,80        DST  @FAC,V@>0480(@PAD8) Store velocities in SAL
       B063 08,4A
[2644]               *----------------------------------------------------------
[2645]               * Add the following 3 lines for speeding up XB
[2646] B065 C4,A3,AA        CH   @NOMSPR,V@SPNUM   Check current sprite
       B068 7A
[2647] B069 50,6F           BR   SPMOVF             against sprite motion
[2648]               *                               counter
[2649] B06B BC,7A,A3        ST   V@SPNUM,@NOMSPR   higher? Yes, replace it
       B06E AA
[2650]               *----------------------------------------------------------
[2651] B06F 00       SPMOVF RTN
[2652]               *****************************
[2653]               * RANGEV ROUTINE            *
[2654]               *****************************
[2655] B070 C6,4C,63 RANGEV CH   >63,@FAC2         The same as INTARG
[2656] B073 6C,B3           BS   ERRSNM      ERROR STRING NUMBER MISMATCH
[2657] B075 86,54           CLR  @FAC10            For FLTINT
[2658] B077 87,6C           DCLR @FPERAD
[2659] B079 0F,12           XML  FLTINT            FP TO INTEGER
[2660] B07B 8E,54           CZ   @FAC10
[2661] B07D 4C,E3           BR   ERRBV       ERROR BAD VALUE      
[2662] B07F D3,4A,00        DCGE 0,@FAC            If positive number,
       B082 00
[2663] B083 50,8D           BR   GB0DB
[2664] B085 C7,4A,00        DCH  >007F,@FAC         should be 0 - 127
       B088 7F
[2665] B089 6C,E3           BS   ERRBV       ERROR BAD VALUE
[2666] B08B 50,93           BR   GB0E1             If negative number,
[2667] B08D CB,4A,FF GB0DB  DCHE >FF80,@FAC         Should be -1 to -128
       B090 80
[2668] B091 4C,E3           BR   ERRBV       ERROR BAD VALUE
[2669] B093 00       GB0E1  RTN                    Otherwise its ok.
[2670]               ******************************
[2671]               * COMMA ROUTINE              *
[2672]               ******************************
[2673] B094 0F,74    COMMA  XML  PARSE
[2674] B096 B3              BYTE COMMAZ
[2675] B097 D6,42,B3 COMMA2 CEQ  COMMAZ,@CHAT
[2676] B09A 4C,AF           BR   ERRSYN            ERROR SYNTAX 
[2677] B09C 0F,79           XML  PGMCHR            Skip COMMA
[2678] B09E 00              RTN
[2679]               ******************************
[2680]               * LINK BACK TO XB            *
[2681]               ******************************
[2682] B09F 06,B0,AD NULRTN CALL PREPN
[2683] B0A2 0F,7C    ASSRTN XML  ASSGNV
[2684] B0A4 05,A8,82        B    LNKRTN
[2685]               *******************************
[2686]               * LINK RETURN TO GPL          *

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0047 
RXB 2024
[2687]               *******************************
[2688] B0A7 06,B0,AD NR     CALL PREPN
[2689] B0AA 0F,7C    AR     XML  ASSGNV
[2690] B0AC 00              RTN
[2691]               *******************************
[2692]               * PREPARE FOR PASSING ARGUMENT*
[2693]               *******************************
[2694] B0AD 0F,7A    PREPN  XML  SYM               Pick up name & search table
[2695] B0AF 0F,7B           XML  SMB               Evaluate any subscripts
[2696] B0B1 C6,4C,63        CH   >63,@FAC2         If not numeric, error
[2697] B0B4 6C,E7           BS   ERRIAL
[2698] B0B6 0F,77           XML  VPUSH             Save entry on stack
[2699] B0B8 86,4A           CLR  @FAC              Clear FAC for new value
[2700] B0BA 35,00,07        MOVE 7,@FAC,@FAC1
       B0BD 4B,4A
[2701] B0BF 00              RTN
[2702]               ***********************************************************
[2703]               * CALL SAY(....................)                          *
[2704]               *  Decode given parameter(s). Store all data first, then  *
[2705]               *   go speak it all at once.                              *
[2706]               ***********************************************************
[2707] B0C0 06,A9,67 SAY    CALL COMB              Must start with "("
[2708] B0C3 BD,4C,6E        DST  @VSPTR,@FAC2      Save current top of stack on
[2709] B0C6 0F,77           XML  VPUSH              the stack
[2710] B0C8 BF,0C,00        DST  255,@BYTES        255 bytes = 85 3 byte entires
       B0CB FF
[2711] B0CC 0F,71           XML  GETSTR            Get temp speech list string
[2712] B0CE BF,4A,00        DST  >001C,@FAC        Indicate it is temp string (S
       B0D1 1C
[2713] B0D2 BF,4C,65        DST  >6500,@FAC2       Indicate it is string entry
       B0D5 00
[2714] B0D6 BD,4E,1C        DST  @SREF,@FAC4       Save pointer to temp string
[2715] B0D9 BD,50,0C        DST  @BYTES,@FAC6      Length is 255
[2716] B0DC 0F,77           XML  VPUSH             Make it semi-permenant
[2717]               * Set up pointers into the speak list
[2718] B0DE BD,00,4E        DST  @FAC4,@PTFBSL     Front points to begining
[2719] B0E1 BD,02,4E        DST  @FAC4,@PTLBSL     Last now points to beginning
[2720] B0E4 BD,04,00        DST  @PTFBSL,@PTEBSL
[2721] B0E7 A1,04,50        DADD @FAC6,@PTEBSL     End points to the end+1
[2722] B0EA 06,B5,06        CALL SETRW             Set PHROM read/write address
[2723] B0ED 06,B4,FB        CALL WAIT              Wait till no one is speaking
[2724] B0F0 06,B2,D3 DIRSPK CALL GETPRM            Get next parameter
[2725] B0F3 71,67           BS   NEXT1             If non-null ASCII string
[2726] B0F5 BD,06,4E        DST  @FAC4,@PTFCIS     Set up pointer to first char
[2727] B0F8 BD,0A,50        DST  @FAC6,@PTLCIS     Set ptr-to-last-char-in-strin
[2728] B0FB A1,0A,06        DADD @PTFCIS,@PTLCIS    by adding length-of-string
[2729] B0FE 93,0A           DDEC @PTLCIS            and subtracting 1
[2730]               * Make a speech list
[2731] B100 06,B5,06        CALL SETRW             Set speech read/write addrs
[2732] B103 BD,08,06        DST  @PTFCIS,@PTCCIS   Start at beginning of string
[2733] B106 86,4C           CLR  @TOTTIM           Clear total time delay
[2734] B108 06,B3,50        CALL GETTIM            Get first timing mark
[2735] B10B 06,B3,40        CALL TIMING            Get any subsequent marks
[2736]               * The total first time delay is in TOTTIM now
[2737] B10E C5,08,0A GB158  DCH  @PTLCIS,@PTCCIS   While more string
[2738] B111 71,5D           BS   GB1A7
[2739] B113 06,B2,E9        CALL PHRASE            Get next phrase
[2740]               * If spell flag is 0, try to look the phrase up. If it
[2741]               * can not be found, then set the spell flag, and it will be
[2742]               * spelled out. If found, save on speak list.
[2743] B116 8E,4B           CZ   @SPLFLG           There is a phrase
[2744] B118 51,29           BR   GB173
[2745] B11A 06,B3,E5        CALL LOOKUP            Try to look it up in the PHRO
[2746] B11D 8F,4D           DCZ  @DATAAD           If not found then

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0048 
RXB 2024
[2747] B11F 51,26           BR   GB170
[2748] B121 BE,4B,01        ST   1,@SPLFLG         Set the spell flag
[2749] B124 51,29           BR   GB173
[2750] B126 06,B4,EB GB170  CALL STDATA            Store data in list
[2751]               * If spell flag is 1, set time delay to >3C, and take the
[2752]               * phrase one character at a time (spell it). Look up each
[2753]               * character: if not found, use 'UHOH' data instead.
[2754]               * Regardless, store data on speak list.
[2755] B129 D6,4B,01 GB173  CEQ  1,@SPLFLG         Need to spell it out?
[2756] B12C 51,56           BR   GB1A0
[2757] B12E BD,4F,10        DST  @PTLCIP,@PTLCIL   Est last char to spell out
[2758] B131 BE,4C,3C        ST   >3C,@TOTTIM       >3C used because sounds good
[2759]               *                      Take each single character
[2760]               * Skip over any embedded spaces encountered in a phrase
[2761] B134 D6,B0,0C GB17E  CEQ  SPACE,V*PTFCIP
       B137 20
[2762] B138 51,3E           BR   GB188
[2763] B13A 91,0C           DINC @PTFCIP
[2764] B13C 51,34           BR   GB17E
[2765]               * Set first and last pointers to same one character
[2766] B13E BD,10,0C GB188  DST  @PTFCIP,@PTLCIP
[2767] B141 06,B3,E5        CALL LOOKUP            Try to look it up
[2768]               * If not found, use data to 'UHOH'
[2769] B144 8F,4D           DCZ  @DATAAD
[2770] B146 51,4C           BR   GB196
[2771] B148 BF,4D,71        DST  >71F4,@DATAAD     Put addr of 'UHOH' in
       B14B F4
[2772] B14C 06,B4,EB GB196  CALL STDATA            Store data on speak list
[2773] B14F 91,0C           DINC @PTFCIP           Go on to next character
[2774] B151 C5,0C,4F        DCH  @PTLCIL,@PTFCIP   Until done all
[2775] B154 51,34           BR   GB17E
[2776]               * At this point, get next timing group. The first timing
[2777]               * character has already been found, and it's value is still
[2778]               * in TIMLEN. Therefore, initiatory call to GETTIM not
[2779]               * needed. Simply clear TOTTIM and call TIMING.
[2780] B156 86,4C    GB1A0  CLR  @TOTTIM
[2781] B158 06,B3,40        CALL TIMING
[2782] B15B 51,0E           BR   GB158
[2783]               * At this point, finished all the phrases in this string.
[2784]               * TOTTIM should equal >FE, it indicate end of sting If it
[2785]               * doesn't equal >FE, it indicates that a timing group was
[2786]               * put on the end of the string. Therefore, save the timing
[2787]               * group with a null data address to show it is only timing.
[2788] B15D D6,4C,FE GB1A7  CEQ  >FE,@TOTTIM
[2789] B160 71,67           BS   NEXT1
[2790] B162 87,4D           DCLR @DATAAD
[2791] B164 06,B4,EB        CALL STDATA
[2792]               * Next item could be direct string.
[2793] B167 D6,42,B3 NEXT1  CEQ  COMMAZ,@CHAT      If direct string present
[2794] B16A 51,81           BR   SPEAK
[2795] B16C 06,B2,D3        CALL GETPRM            Get the next parameter
[2796] B16F 71,7C           BS   NEXT2             If non-null direct string
[2797] B171 BE,4C,FF        ST   >FF,@TOTTIM       Mark TOTTIM as direct string
[2798] B174 0F,77           XML  VPUSH             Save direct string on stack
[2799] B176 BD,4D,6E        DST  @VSPTR,@DATAAD    Store stack addr on string
[2800] B179 06,B4,EB        CALL STDATA            And add to the speak list
[2801]               * If the next character is a comma, loop thru it again
[2802] B17C D6,42,B3 NEXT2  CEQ  COMMAZ,@CHAT
[2803] B17F 70,F0           BS   DIRSPK
[2804]               * If end fall into SPEAK
[2805]               ***********************************************************
[2806]               * SPEAK will actually speak the speech list. It tests the
[2807]               * timing byte to see if it is an >FF. If it is, then the
[2808]               * data following it points to a direct speech data string

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0049 
RXB 2024
[2809]               * in VDP. If it is not, then the data following it points
[2810]               * to a PHROM speech data list. In the first case, this
[2811]               * routine will issue a speak external command to the PHROM
[2812]               * and then feed bytes out to the PHROM as it requests them.
[2813]               * In the second case, the address will be loaded out to the
[2814]               * PHROM, and then a speak command will be issued.
[2815]               ***********************************************************
[2816] B181 06,B5,06 SPEAK  CALL SETRW             Set read/write address
[2817] B184 C9,00,02 GB1CE  DCHE @PTLBSL,@PTFBSL   More speech list to go
[2818] B187 72,0E           BS   GB258
[2819] B189 06,B4,FB        CALL WAIT              Yes, wait until previous
[2820]               *                              speech is though
[2821] B18C D6,B0,00        CEQ  >FF,V*PTFBSL      External speech data
       B18F FF
[2822] B190 71,B4           BS   GB1FE
[2823] B192 BC,79,B0        ST   V*PTFBSL,@TIMER   No, load timer
       B195 00
[2824] B196 82,79           NEG  @TIMER             and neg it to correct
[2825] B198 BD,12,E0        DST  V@1(@PTFBSL),@PTFBPH   Put addr into PTFBPH
       B19B 01,00
[2826] B19D A3,00,00        DADD 3,@PTFBSL               and skip to next node
       B1A0 03
[2827] B1A1 D2,79,00 LOOP1  CGE  0,@TIMER          Wait for time delay
[2828] B1A4 51,A1           BR   LOOP1
[2829] B1A6 8E,12           CZ   @PTFBPH           If there is data
[2830] B1A8 71,B2           BS   GB1FC
[2831] B1AA 06,B4,A1        CALL LOADAD            Load the addr to PHROM
[2832] B1AD BE,C0,00        ST   >50,@PAD(@WRITE)   and issue speak command
       B1B0 5A,50
[2833] B1B2 52,0B    GB1FC  BR   CONTIN
[2834] B1B4 91,00    GB1FE  DINC @PTFBSL           Speak external, skip over >FF
[2835] B1B6 BD,5E,B0        DST  V*PTFBSL,@PTCBED  Set up pointer to 1st byte
       B1B9 00
[2836] B1BA BD,5E,E0        DST  V@4(@PTCBED),@PTCBED    in external speech data
       B1BD 04,5E
[2837] B1BF 95,00           DINCT @PTFBSL          Skip addr bytes
[2838] B1C1 BC,62,EF        ST   V@-1(@PTCBED),@LENWST  Get Len of whole string
       B1C4 FF,FF,5E
[2839] B1C7 A6,62,03 DIRSPH SUB  3,@LENWST         Minus 3 bytes overhead
[2840]               * All external speech strings start with a >60
[2841] B1CA D6,B0,5E        CEQ  >60,V*PTCBED      Bad speech string
       B1CD 60
[2842] B1CE 4C,E3           BR   ERRBV
[2843] B1D0 06,B4,FB        CALL WAIT              Wait for go ahead
[2844] B1D3 95,5E           DINCT @PTCBED          Skip spk ext & 1st byte len
[2845] B1D5 BC,60,B0        ST   V*PTCBED,@LENCST  Get len of current string
       B1D8 5E
[2846] B1D9 91,5E           DINC @PTCBED           Skip len byte to 1st real byt
[2847] B1DB BE,56,10        ST   16,@TEMP2         Do 1st 16 bytes (fill buff)
[2848] B1DE BE,C0,00        ST   >60,@PAD(@WRITE)  Start Speak External
       B1E1 5A,60
[2849] B1E3 BC,C0,00 LOOPR  ST   V*PTCBED,@PAD(@WRITE) Write byte to PHROM
       B1E6 5A,B0,5E
[2850] B1E9 91,5E           DINC @PTCBED           Go to next byte
[2851] B1EB 92,62           DEC  @LENWST           1 less char in whole string
[2852] B1ED 72,0B           BS   CONTIN            Finished whole string?
[2853] B1EF 92,60           DEC  @LENCST           1 less char in curr string
[2854] B1F1 71,C7           BS   DIRSPH            Finished current string?
[2855] B1F3 92,56           DEC  @TEMP2            1 less char in this loop
[2856] B1F5 51,E3           BR   LOOPR             Not finished curr loop yet?
[2857] B1F7 BC,69,C0 GB241  ST   @PAD(@READ),@SPKSTS Read status from PHROM
       B1FA 00,58
[2858]                
[2859]               * If the next statement is true, it means that speak was

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0050 
RXB 2024
[2860]               * probably interupted and that it is shot at this point.
[2861]               * Therefore, we are going to quit now.
[2862] B1FC DA,69,80        CLOG >80,@SPKSTS
[2863] B1FF 72,0B           BS   CONTIN
[2864] B201 DA,69,40        CLOG >40,@SPKSTS       Loop till buff below half
[2865] B204 71,F7           BS   GB241
[2866] B206 BE,56,08        ST   8,@TEMP2          Put 8 more bytes to PHROM
[2867] B209 51,E3           BR   LOOPR              and go do these
[2868] B20B 05,B1,84 CONTIN B    GB1CE             We've said it all!!
[2869]               * Now pop all entries off stack that we put on!
[2870] B20E 0F,78    GB258  XML  VPOP              Free up a temporary string
[2871] B210 D5,6E,4C        DCEQ @FAC2,@VSPTR
[2872] B213 52,0E           BR   GB258
[2873] B215 48,82           BR   LNKRTN       
[2874]               ***********************************************************
[2875]               * SPGET subprogram. Load speech data from external device.
[2876]               *       Use standard file I/O
[2877]               ***********************************************************
[2878]               * CALL SAY(word-string,return-string)                     *
[2879]               ***********************************************************
[2880] B217 06,A9,67 SPGET  CALL COMB             Must have left parenthesis
[2881] B21A 06,B5,06        CALL SETRW             Set PHROM read/write address
[2882] B21D 06,B4,FB        CALL WAIT              Wait till no one is speaking
[2883] B220 06,B2,D3 NXTPAR CALL GETPRM            Get the next parameter
[2884] B223 8F,50           DCZ  @FAC6             If non-null ASCII string
[2885] B225 72,CC           BS   GB318
[2886] B227 BD,06,4E        DST  @FAC4,@PTFCIS     Pointer to 1st char in string
[2887] B22A BD,0A,50        DST  @FAC6,@PTLCIS     Pointer to last-char-in-strin
[2888] B22D A1,0A,06        DADD @PTFCIS,@PTLCIS    by adding length-of-string
[2889] B230 93,0A           DDEC @PTLCIS             and subtracting 1
[2890] B232 06,B5,06        CALL SETRW             Set the speech read/write add
[2891] B235 BD,08,06        DST  @PTFCIS,@PTCCIS   Set curr char to first char
[2892] B238 86,4C           CLR  @TOTTIM           Clear total time delay
[2893] B23A 06,B3,50        CALL GETTIM            Get first timing mark
[2894] B23D 06,B3,40        CALL TIMING            Get any subsquent marks
[2895]               * Get one phrase, and look it up. If the phrase is not foun
[2896]               * substitute in 'UHOH'.
[2897] B240 C5,08,0A        DCH  @PTLCIS,@PTCCIS   Possible phrase
[2898] B243 72,CC           BS   GB318
[2899] B245 06,B2,E9        CALL PHRASE            Yes, go get it
[2900] B248 D6,4B,01        CEQ  1,@SPLFLG         Spell flag set then set
[2901] B24B 52,50           BR   GB29C
[2902] B24D BD,10,0C        DST  @PTFCIP,@PTLCIP    last ptr to first (1 char)
[2903] B250 06,B3,E5 GB29C  CALL LOOKUP            Look up the phrase
[2904] B253 8F,4D           DCZ  @DATAAD           If not there,
[2905] B255 52,5E           BR   GB2AA
[2906] B257 BF,4D,71        DST  >71F4,@DATAAD      use 'UHOH' data addr
       B25A F4
[2907] B25B BE,64,51        ST   >51,@STRLEN        'UHOH' data length
[2908]               * Data must be in PHRADD and PHLEN, so move it
[2909] B25E BD,01,4D GB2AA  DST  @DATAAD,@PHRADD
[2910] B261 BC,00,64        ST   @STRLEN,@PHLEN
[2911] B264 A2,00,03        ADD  3,@PHLEN          For overhead info
[2912]               * There must be a variable to put this data in. If not, err
[2913] B267 0F,7E           XML  SPEED
[2914] B269 00              BYTE SYNCHK
[2915] B26A B3              BYTE COMMAZ
[2916] B26B 0F,7A           XML  SYM               Find symbol in table
[2917] B26D 0F,7B           XML  SMB               Evaluate andy subscripts
[2918] B26F 0F,77           XML  VPUSH             Save for assignment
[2919] B271 86,0C           CLR  @BYTES            Two byte value
[2920] B273 BC,0D,00        ST   @PHLEN,@BYTES+1   Length of string needed
[2921] B276 0F,71           XML  GETSTR            Get a string for the data
[2922] B278 06,B5,06        CALL SETRW             Set up speech read/write addr

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0051 
RXB 2024
[2923] B27B BF,4A,00        DST  >001C,@FAC        Now build string FAC entry
       B27E 1C
[2924] B27F BF,4C,65        DST  >6500,@FAC2       String ID
       B282 00
[2925] B283 BD,4E,1C        DST  @SREF,@FAC4       Pointer to string
[2926] B286 BD,50,0C        DST  @BYTES,@FAC6      Length of string
[2927] B289 BF,B0,1C        DST  >6000,V*SREF      Mark string as speech data
       B28C 60,00
[2928] B28E BC,E0,02        ST   @PHLEN,V@2(@SREF) Put in string length
       B291 1C,00
[2929] B293 A7,E0,01        DSUB 3,V@1(@SREF)       minus thei info
       B296 1C,00,03
[2930]               * LOADAD expects addr to be in PTFBPH, so move it.
[2931] B299 BD,12,01        DST  @PHRADD,@PTFBPH
[2932] B29C 06,B4,A1        CALL LOADAD
[2933]               * Going to copy string from PHROM to VDP. The actual data
[2934]               * from PHROM is in bit-reversed order, so must reverse the
[2935]               * order after reading in the order. Remember that 3 bytes
[2936]               * PHLEN are our own overhead, so don't copy all
[2937] B29F C6,00,03 GB2EB  CH   3,@PHLEN
[2938] B2A2 52,CA           BR   GB316
[2939] B2A4 BE,C0,00        ST   >10,@PAD(@WRITE)   Issue read byte command
       B2A7 5A,10
[2940] B2A9 BC,68,C0        ST   @PAD(@READ),@BYTE3 Read the byte
       B2AC 00,58
[2941]               * the following code is somewhat tricky. It will bit
[2942]               * reverse the contents of BYTE3 into BYTE1 through
[2943]               * BYTE2 by means of word shifts. Note the definition of
[2944]               * BYTE1 , BYTE2, and BYTE3 in EQU's. You might try an
[2945]               * example if it isn't clear what is going on.
[2946] B2AE 86,67           CLR  @BYTE2
[2947] B2B0 BE,54,08        ST   >08,@TEMP1
[2948] B2B3 EB,67,00 RNDAG  DSRC 1,@BYTE2
       B2B6 01
[2949] B2B7 E3,66,00        DSLL 1,@BYTE1
       B2BA 01
[2950] B2BB 92,54           DEC  @TEMP1
[2951] B2BD 52,B3           BR   RNDAG
[2952]               * Store the bit-corrected byte into the string & inc str pt
[2953] B2BF BC,E0,03        ST   @BYTE1,V@3(@SREF)
       B2C2 1C,66
[2954] B2C4 91,1C           DINC @SREF
[2955] B2C6 92,00           DEC  @PHLEN            Dec the string length
[2956] B2C8 52,9F           BR   GB2EB             Go do next char if there is o
[2957] B2CA 0F,7C    GB316  XML  ASSGNV            Assign the string to variable
[2958] B2CC D6,42,B3 GB318  CEQ  COMMAZ,@CHAT      If more go do
[2959] B2CF 72,20           BS   NXTPAR
[2960] B2D1 48,82           BR   LNKRTN
[2961]               ***********************************************************
[2962]               * GETPAM gets the next string paameter passed to the
[2963]               * routine. If that parameter is non-exist or null, then
[2964]               * condition bit is set. If the parameter is there then
[2965]               * condition bit is reset and the FAC entry describes the
[2966]               * string. In either case, return with condition is done.
[2967]               ***********************************************************
[2968] B2D3 0F,79    GETPRM XML  PGMCHR            Get next token
[2969] B2D5 D6,42,B3        CEQ  COMMAZ,@CHAT      Go set condition no parm
[2970] B2D8 72,E5           BS   SETCB
[2971] B2DA 0F,74           XML  PARSE
[2972] B2DC B6              BYTE RPARZ
[2973] B2DD D6,4C,65        CEQ  >65,@FAC2         If not string, error
[2974] B2E0 4C,B3           BR   ERRSNM
[2975] B2E2 8F,50           DCZ  @FAC6             Set cond if null string
[2976] B2E4 01              RTNC                   Else return

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0052 
RXB 2024
[2977] B2E5 D4,00,00 SETCB  CEQ  @PAD,@PAD         Set condition bit
[2978] B2E8 01              RTNC
[2979]               ***********************************************************
[2980]               * Get the next phrase out of the current string. The phrase
[2981]               * may begin with a #, which means it will continue to the
[2982]               * next #, or it many begin with an ordinary character, in
[2983]               * which case it will end with the character just before the
[2984]               * first timing character encountered. In either case, the
[2985]               * end of the string will indicate a legal end of phrase if
[2986]               * it occurs before the usual indicator!
[2987]               ***********************************************************
[2988] B2E9 D6,4A,23 PHRASE CEQ  NUMBER,@CCHAR     Phrase start with #?
[2989] B2EC 53,24           BR   GB370
[2990] B2EE 91,08           DINC @PTCCIS           Yes, inc CC ptr past #
[2991] B2F0 D6,B0,08 GB33C  CEQ  SPACE,V*PTCCIS    Skip spaces
       B2F3 20
[2992] B2F4 52,FA           BR   GB346
[2993] B2F6 91,08           DINC @PTCCIS
[2994] B2F8 52,F0           BR   GB33C
[2995] B2FA D6,B0,08 GB346  CEQ  NUMBER,V*PTCCIS   All spaces?
       B2FD 23
[2996] B2FE 53,03           BR   GB34F
[2997] B300 91,08           DINC @PTCCIS           Yes, skip this # too
[2998] B302 00              RTN                    And ignore this phrase
[2999] B303 BD,0C,08 GB34F  DST  @PTCCIS,@PTFCIP   Save 1st char in phrase
[3000] B306 91,08    GB352  DINC @PTCCIS           Go on to next char
[3001]               * Got to watch for end of string. If encountered before a
[3002]               * #, act like char after string is #. Then last char will
[3003]               * be char before, or the last char in the string!!
[3004] B308 C5,08,0A        DCH  @PTLCIS,@PTCCIS
[3005] B30B 73,16           BS   FNDNUM
[3006] B30D BC,4A,B0        ST   V*PTCCIS,@CCHAR   No, get char in CCHAR
       B310 08
[3007] B311 D6,4A,23        CEQ  NUMBER,@CCHAR     If not # continue looking
[3008] B314 53,06           BR   GB352
[3009] B316 BD,10,08 FNDNUM DST  @PTCCIS,@PTLCIP   Last char in phrase is one
[3010] B319 93,10           DDEC @PTLCIP            before the #
[3011] B31B 91,08           DINC @PTCCIS           Point to char after #
[3012] B31D 06,B3,50        CALL GETTIM            Get 1st timing char after phr
[3013] B320 86,4B           CLR  @SPLFLG           Indicate don't spell
[3014] B322 53,3F           BR   GB38B             No # as 1st char in phrase
[3015] B324 BD,0C,08 GB370  DST  @PTCCIS,@PTFCIP   Curr char is 1st char phrase
[3016] B327 86,4B           CLR  @SPLFLG           Assume don't spell
[3017] B329 CA,4A,41        CHE  >41,@CCHAR        If not alphabetic   (>41="A")
[3018] B32C 73,30           BS   GB37C
[3019] B32E 90,4B           INC  @SPLFLG            set spell flag
[3020]               * Need to find end of phrase, which is char before next
[3021]               * timing char we find. Therefore, look for a timing char!
[3022] B330 91,08    GB37C  DINC @PTCCIS
[3023] B332 06,B3,50        CALL GETTIM
[3024] B335 D6,51,FF        CEQ  >FF,@TIMLEN       If not timing, loop
[3025] B338 73,30           BS   GB37C
[3026] B33A BD,10,08        DST  @PTCCIS,@PTLCIP   Char before curr char is
[3027] B33D 93,10           DDEC @PTLCIP            the last char in phrase
[3028] B33F 00       GB38B  RTN
[3029]               ***********************************************************
[3030]               * TIMING will loop through chars in string until it finds
[3031]               * non-timing char. Non-timing chars have TIMLEN values of
[3032]               * >FE or >FF. GETTIM must be called before this routine to
[3033]               * establish a correct value of TIMLEN. Also, most likely
[3034]               * TOTTIM should have been cleared.
[3035]               ***********************************************************
[3036] B340 CA,51,FE TIMING CHE  >FE,@TIMLEN
[3037] B343 73,4F           BS   GB39B

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0053 
RXB 2024
[3038] B345 A1,4C,51        DADD @TIMLEN,@TOTTIM
[3039] B348 91,08           DINC @PTCCIS
[3040] B34A 06,B3,50        CALL GETTIM
[3041] B34D 53,40           BR   TIMING
[3042] B34F 00       GB39B  RTN
[3043]               ***********************************************************
[3044]               * GETTIM will examine the current char in the string and
[3045]               * set TIMLEN to the appropriate time delay value. TIMLEN
[3046]               * can take on the following values:
[3047]               *           >00 if char is timing '+'
[3048]               *           >06 if char is timing ' '
[3049]               *           >0C if char is timing '-'
[3050]               *           >12 if char is timing ','
[3051]               *           >1E if char is timing ';'
[3052]               *           >30 if char is timing ':'
[3053]               *           >3C if char is timing '.'
[3054]               *           >FE if char is out of stirng bounds
[3055]               *           >FF if char is not timing
[3056]               * Note that to test timing, some manipulation of PTCCIS
[3057]               * would be neccesary, so it is stored and used in TEMP1
[3058]               ***********************************************************
[3059] B350 BC,4A,B0 GETTIM ST   V*PTCCIS,@CCHAR   Get the char
       B353 08
[3060] B354 BD,54,08        DST  @PTCCIS,@TEMP1     store curr ptr in TEMP1
[3061] B357 C5,54,0A        DCH  @PTLCIS,@TEMP1     out of string bounds?
[3062] B35A 53,60           BR   GB3AC
[3063] B35C BE,51,FE        ST   >FE,@TIMLEN       Yes, load value and return
[3064] B35F 00              RTN
[3065] B360 C6,4A,3B GB3AC  CH   SEMICO,@CCHAR     Can not be timing
[3066] B363 73,CA           BS   NOTIME
[3067] B365 D6,4A,20        CEQ  SPACE,@CCHAR
[3068] B368 53,79           BR   GB3C5
[3069] B36A BE,51,06        ST   6,@TIMLEN
[3070] B36D D6,E0,01 GB3B9  CEQ  SPACE,V@1(@PTCCIS) While spaces
       B370 08,20
[3071] B372 53,78           BR   GB3C4
[3072] B374 91,08           DINC @PTCCIS           Skip them
[3073] B376 53,6D           BR   GB3B9
[3074] B378 00       GB3C4  RTN
[3075] B379 D6,4A,2B GB3C5  CEQ  PLUS,@CCHAR
[3076] B37C 53,88           BR   GB3D4
[3077] B37E 91,54           DINC @TEMP1            Need to test the next char
[3078] B380 06,B3,CE        CALL NUMERC            Is it numeric
[3079] B383 73,CA           BS   NOTIME            Was numeric => not timing cha
[3080] B385 86,51           CLR  @TIMLEN           Not numeric => set as no timi
[3081] B387 00              RTN
[3082] B388 D6,4A,2C GB3D4  CEQ  COMMAT,@CCHAR
[3083] B38B 53,91           BR   GB3DD
[3084] B38D BE,51,12        ST   >12,@TIMLEN
[3085] B390 00              RTN
[3086] B391 D6,4A,2E GB3DD  CEQ  PERIOD,@CCHAR
[3087] B394 53,A8           BR   GB3F4
[3088] B396 93,54           DDEC @TEMP1            Go back to preceding char
[3089] B398 06,B3,CE        CALL NUMERC            Is it numeric?
[3090] B39B 53,A4           BR   PTIME             No, so it is timing
[3091] B39D 95,54           DINCT @TEMP1           Yes, on to following char
[3092] B39F 06,B3,CE        CALL NUMERC            Is it numeric too?
[3093] B3A2 73,CA           BS   NOTIME            Yes, both numeric => not timi
[3094] B3A4 BE,51,3C PTIME  ST   >3C,@TIMLEN       Both not numeric  => timing
[3095] B3A7 00              RTN
[3096] B3A8 D6,4A,2D GB3F4  CEQ  HYPEN,@CCHAR
[3097] B3AB 53,B8           BR   GB404
[3098] B3AD 91,54           DINC @TEMP1            Check next char
[3099] B3AF 06,B3,CE        CALL NUMERC            Is it numeric?

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0054 
RXB 2024
[3100] B3B2 73,CA           BS   NOTIME            Was numeric => not a timing c
[3101] B3B4 BE,51,0C        ST   >0C,@TIMLEN       Was not numeric => set as tim
[3102] B3B7 00              RTN
[3103] B3B8 D6,4A,3A GB404  CEQ  COLON,@CCHAR
[3104] B3BB 53,C1           BR   GB40D
[3105] B3BD BE,51,30        ST   >30,@TIMLEN
[3106] B3C0 00              RTN
[3107] B3C1 D6,4A,3B GB40D  CEQ  SEMICO,@CCHAR
[3108] B3C4 53,CA           BR   NOTIME
[3109] B3C6 BE,51,1E        ST   >1E,@TIMLEN
[3110] B3C9 00              RTN
[3111] B3CA BE,51,FF NOTIME ST   >FF,@TIMLEN       Set as no timing char present
[3112] B3CD 00              RTN
[3113]               ***********************************************************
[3114]               * NUMERC tests the char pointed to by PTCCIS and verifies
[3115]               * the following:
[3116]               *  1 - it is within the current string boundaries
[3117]               *  2 - it is numeric (i.e. between '0' and '9')
[3118]               * If both of the above conditions are true, COND is set
[3119]               * upon return, otherwise COND is reset
[3120]               ***********************************************************
[3121] B3CE C5,54,0A NUMERC DCH  @PTLCIS,@TEMP1
[3122] B3D1 73,E4           BS   GB430
[3123] B3D3 C5,06,54        DCH  @TEMP1,@PTFCIS
[3124] B3D6 73,E4           BS   GB430
[3125] B3D8 CA,B0,54        CHE  >30,V*TEMP1
       B3DB 30
[3126] B3DC 53,E4           BR   GB430
[3127] B3DE C6,B0,54        CH   >39,V*TEMP1
       B3E1 39
[3128] B3E2 52,E5           BR   SETCB
[3129] B3E4 01       GB430  RTNC
[3130]               ***********************************************************
[3131]               * LOOKUP is a prolong routine to SEARCH. In each PHROM,
[3132]               * there may be 2 trees, one starting at >0000 and the other
[3133]               * at >8000. Either may or may not be present. Presences is
[3134]               * determined if a >AA byte is at the starting location.
[3135]               * LOOKUP determines if the tree at >0000 is in, and if so,
[3136]               * calls SEARCH with that addr. If that tree is not present
[3137]               * or the phrase couldn't be found in it, LOOKUP then checks
[3138]               * if the tree at >8000 is present, and again, if so, calls
[3139]               * SEARCH with that tree address. If the word was found in
[3140]               * the first tree, or after searching the second tree, the
[3141]               * routine will return.
[3142]               ***********************************************************
[3143] B3E5 87,66    LOOKUP DCLR @BYTE1            BYTE1 contains addr of curr t
[3144] B3E7 BD,12,66 TRYAGN DST  @BYTE1,@PTFBPH    Look for >AA tree header
[3145] B3EA 06,B4,A1        CALL LOADAD            LOADAD expects addr in PTFBPH
[3146] B3ED BE,C0,00        ST   >10,@PAD(@WRITE)  Put out read byte command
       B3F0 5A,10
[3147] B3F2 D6,C0,00        CEQ  >AA,@PAD(@READ)   Tree out there?
       B3F5 58,AA
[3148] B3F7 54,02           BR   GB44E
[3149] B3F9 91,12           DINC @PTFBPH           Skip the tree header
[3150] B3FB 06,B4,0D        CALL SEARCH            Go search this PHROM tree
[3151] B3FE 8F,4D           DCZ  @DATAAD           Phrase found => exit
[3152] B400 54,0C           BR   FOUND
[3153] B402 A3,66,80 GB44E  DADD >8000,@BYTE1      Go to start of next PHROM tre
       B405 00
[3154]               * Note >8000 + >8000 = >0000 => tried both trees
[3155] B406 8F,66           DCZ  @BYTE1
[3156] B408 53,E7           BR   TRYAGN
[3157] B40A 87,4D           DCLR @DATAAD           Didnt find phrase in either t
[3158] B40C 00       FOUND  RTN

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0055 
RXB 2024
[3159]               ***********************************************************
[3160]               * SEARCH actually searches the PHROM tree for the phrase.
[3161]               * The PHROM tree organization is as follows:
[3162]               *        (i.e. this is one phrase node)
[3163]               *              phrase ASCII length      1 byte
[3164]               *              actual ASCII characters  n bytes
[3165]               *              less then pointer        2 bytes
[3166]               *              greater then pointer     2 bytes
[3167]               *              speech data pointer      3 bytes
[3168]               *              speech data length       1 byte
[3169]               * The comparison of two words proceeds on a char by char
[3170]               * basis, where length is secondary to char values, i.e.
[3171]               * move > answer; number < we; eight < eighty; etc...
[3172]               ***********************************************************
[3173] B40D 06,B4,A1 SEARCH CALL LOADAD            Set PHROM to start phrase nod
[3174] B410 BE,C0,00        ST   >10,@PAD(@WRITE)  Issue read byte command
       B413 5A,10
[3175] B415 86,16           CLR  @PTLCPH           Length of phrase => PTLCPH
[3176] B417 BC,17,C0        ST   @PAD(@READ),@PTLCPH+1 (stored as 2 byte value
       B41A 00,58
[3177] B41C A1,16,12        DADD @PTFBPH,@PTLCPH   Add front ptr giving end ptr
[3178] B41F BD,14,12        DST  @PTFBPH,@PTCCPH   Set up curr char as 1 beyond
[3179] B422 91,14           DINC @PTCCPH            length byte
[3180] B424 BD,0E,0C        DST  @PTFCIP,@PTCCIP   Reset current ptr into phrase
[3181]               * Compare two characters
[3182] B427 BE,C0,00 NEXT   ST   >10,@PAD(@WRITE)  Issue read byte command
       B42A 5A,10
[3183] B42C BC,5D,C0        ST   @PAD(@READ),@PHDATA Get char in from PHROM
       B42F 00,58
[3184] B431 D4,5D,B0        CEQ  V*PTCCIP,@PHDATA  Compare the char
       B434 0E
[3185] B435 54,85           BR   GB4D1
[3186] B437 91,14           DINC @PTCCPH           Equal, advance both pointers
[3187] B439 91,0E           DINC @PTCCIP
[3188] B43B D6,B0,0E        CEQ  SPACE,V*PTCCIP    Skip extra spaces
       B43E 20
[3189] B43F 54,55           BR   GB4A1
[3190] B441 D6,E0,01 GB48D  CEQ  SPACE,V@1(@PTCCIP) While spaces
       B444 0E,20
[3191] B446 54,4C           BR   GB498
[3192] B448 91,0E           DINC @PTCCIP           Skip them
[3193] B44A 54,41           BR   GB48D
[3194]               * By skipping extra spaces, might have reached end of phras
[3195]               * If this is true, next char in phrase = #. If so, advance
[3196]               * the pointer to be beyond end of phrase.
[3197] B44C D6,E0,01 GB498  CEQ  NUMBER,V@1(@PTCCIP)
       B44F 0E,23
[3198] B451 54,55           BR   GB4A1
[3199] B453 91,0E           DINC @PTCCIP
[3200] B455 C5,14,16 GB4A1  DCH  @PTLCPH,@PTCCPH   End of PHROM word?
[3201] B458 54,7A           BR   GB4C6
[3202] B45A C5,0E,10        DCH  @PTLCIP,@PTCCIP   Yes, end of phrase
[3203] B45D 54,74           BR   GB4C0
[3204] B45F BD,12,16        DST  @PTLCPH,@PTFBPH   Yes, word found
[3205]               * Skip 5 bytes down from last char to data pointer
[3206] B462 A3,12,00        DADD 6,@PTFBPH
       B465 06
[3207] B466 06,B4,D3        CALL READAD            Set data addr => DATAAD
[3208] B469 BE,C0,00        ST   >10,@PAD(@WRITE)  Issue read byte command
       B46C 5A,10
[3209] B46E BC,64,C0        ST   @PAD(@READ),@STRLEN Get length of speech data
       B471 00,58
[3210] B473 00              RTN
[3211] B474 BF,12,00 GB4C0  DST  3,@PTFBPH         Move 3 bytes past PTLCPH

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0056 
RXB 2024
       B477 03
[3212] B478 54,91           BR   NXTPHR
[3213] B47A C5,0E,10 GB4C6  DCH  @PTLCIP,@PTCCIP   2 characters
[3214] B47D 54,27           BR   NEXT
[3215] B47F BF,12,00        DST  1,@PTFBPH         Phrase linger: use LT ptr
       B482 01
[3216] B483 54,91           BR   NXTPHR
[3217]               * Two characters compared were not equal
[3218] B485 BF,12,00 GB4D1  DST  3,@PTFBPH         3 bytes past last to GT
       B488 03
[3219] B489 C4,5D,B0        CH   V*PTCCIP,@PHDATA  After phrase
       B48C 0E
[3220] B48D 54,91           BR   NXTPHR
[3221] B48F 97,12           DDECT @PTFBPH          Back up 2 bytes to LT link
[3222]               * Go get next phrase out of the PHROM to compare
[3223] B491 A1,12,16 NXTPHR DADD @PTLCPH,@PTFBPH   Add displacement to last char
[3224] B494 06,B4,D3        CALL READAD             and get the new address
[3225] B497 8F,4D           DCZ  @DATAAD           More leaves on this tree
[3226] B499 54,9C           BR   GB4E8
[3227] B49B 00              RTN                    No, return empty handed
[3228] B49C BD,12,4D GB4E8  DST  @DATAAD,@PTFBPH   Store new addr in PTFBPH
[3229] B49F 54,0D           BR   SEARCH            Go compare this new word!
[3230]               * The program should never reach this point!! It should
[3231]               * return somewhere up above.
[3232]               ***********************************************************
[3233]               * LOADAD will set the addr out in the PHROM to the addr
[3234]               * found in PTFBPH. Note that the PHROM is expecting five
[3235]               * nybbles to be written out as the address.
[3236]               ***********************************************************
[3237] B4A1 BD,54,12 LOADAD DST  @PTFBPH,@TEMP1    This is destructive, so copy
[3238] B4A4 BD,56,12        DST  @PTFBPH,@TEMP2     address into temporary areas
[3239] B4A7 E6,54,04        SRL  4,@TEMP1          Isolate the MSN of the MSB
[3240] B4AA E6,55,04        SRL  4,@TEMP1+1        Isolate the MSN of the LSB
[3241] B4AD B3,56,0F        DAND >0F0F,@TEMP2      Isolate the LSN of the MSB, L
       B4B0 0F
[3242] B4B1 B7,54,40        DOR  >4040,@TEMP1      Include a 4 as MSN of all 4 n
       B4B4 40
[3243] B4B5 B7,56,40        DOR  >4040,@TEMP2       to indicate a Load Address C
       B4B8 40
[3244] B4B9 BC,C0,00        ST   @TEMP2+1,@PAD(@WRITE) Write out the LSN of th
       B4BC 5A,57
[3245] B4BE BC,C0,00        ST   @TEMP1+1,@PAD(@WRITE) Write out the LSN of th
       B4C1 5A,55
[3246] B4C3 BC,C0,00        ST   @TEMP2,@PAD(@WRITE)   Write out the MSN of th
       B4C6 5A,56
[3247] B4C8 BC,C0,00        ST   @TEMP1,@PAD(@WRITE)   Write out the MSN of th
       B4CB 5A,54
[3248] B4CD BE,C0,00        ST   >40,@PAD(@WRITE)      Write out 0 as fifth ny
       B4D0 5A,40
[3249] B4D2 00              RTN
[3250]               ***********************************************************
[3251]               * READAD will read an address from the PHROM and store it
[3252]               * in DATAAD. Note that PTFBPH should contain the addr of
[3253]               * the PHROM location to be read so LOADAD will work.
[3254]               ***********************************************************
[3255] B4D3 06,B4,A1 READAD CALL LOADAD            Set the addr of the PHROM
[3256] B4D6 BE,C0,00        ST   >10,@PAD(@WRITE)  Get high byte of addr
       B4D9 5A,10
[3257] B4DB BC,4D,C0        ST   @PAD(@READ),@DATAAD Store it in DATAAD
       B4DE 00,58
[3258] B4E0 BE,C0,00        ST   >10,@PAD(@WRITE)  Get low byte of addr
       B4E3 5A,10
[3259] B4E5 BC,4E,C0        ST   @PAD(@READ),@DATAAD+1 Store it in DATAAD+1
       B4E8 00,58

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0057 
RXB 2024
[3260] B4EA 00              RTN
[3261]               ***********************************************************
[3262]               * STDATA will store the data in DATAAD and TOTTIM onto the
[3263]               * speech list. It will also check that there is room on the
[3264]               * speech list for this entry, and abort with error if not.
[3265]               ***********************************************************
[3266] B4EB D5,02,04 STDATA DCEQ @PTEBSL,@PTLBSL   Is there room?
[3267] B4EE 75,0D           BS   ERRSSL
[3268] B4F0 35,00,03        MOVE 3,@TOTTIM,V*PTLBSL   Put data in list
       B4F3 B0,02,4C
[3269] B4F6 A3,02,00        DADD 3,@PTLBSL              and inc top of list
       B4F9 03
[3270] B4FA 00              RTN
[3271]               ***********************************************************
[3272]               * WAIT loops until the speech peripheral goes idle.
[3273]               ***********************************************************
[3274]               *    ( Loop until nobody is talking)
[3275] B4FB BC,69,C0 WAIT   ST   @PAD(@READ),@SPKSTS  Read status from PHROM
       B4FE 00,58
[3276] B500 DA,69,80        CLOG >80,@SPKSTS
[3277] B503 54,FB           BR   WAIT
[3278] B505 00              RTN
[3279]               ***********************************************************
[3280]               * SETRW moves addrs of speech read/write from GROM to VDP
[3281]               ***********************************************************
[3282] B506 31,00,04 SETRW  MOVE 4,G@>0046,@READ
       B509 58,00,46
[3283] B50C 00              RTN
[3284]               ***********************************************************
[3285]               *                    ERROR MESSAGES
[3286]               ***********************************************************
[3287]               *      The following calls are in EXECS file.
[3288]               * ERRSYN CALL ERRZZ           * SYNTAX ERROR
[3289]               *        BYTE 3
[3290]               * ERRSNM CALL ERRZZ           * STRING-NUMBER MISMATCH
[3291]               *        BYTE 7
[3292]               * ERRBV  CALL ERRZZ           * BAD VALUE
[3293]               *        BYTE 30
[3294]               * ERRIAL CALL ERRZZ           * INCORRECT ARGUMENT LIST
[3295]               *        BYTE 31
[3296]               ***********************************************************
[3297] B50D 06,6A,84 ERRSSL  CALL ERRZZ          * SPEECH STRING TOO LONG
[3298] B510 15               BYTE 21
[3299]               ***********************************************************
[3300]               * CALL MOVES("$$",bytes,$variable,$variable,...)          *
[3301]               * CALL MOVES(type$,bytes,from-address,to-address,...)     *
[3302]               * CALL MOVES(type$,bytes,from-address,$variable,...)      *
[3303]               * CALL MOVES(type$,bytes,$variable,to-address,...)        *
[3304]               * type$:R=RAM, V=VDP, G=GRAM/GROM, $=string variable      *
[3305]               ***********************************************************
[3306] B511 06,A9,67 MOVES   CALL COMB           MOVES(TYPE$,BYTES,$,TO)
[3307]               *                            or MOVES(TYPE$,BYTES,FROM,$)
[3308] B514 06,A2,B4 MOVESA CALL STRGET          * ( or ,
[3309] B517 BD,10,B0        DST  V*FAC4,@VAR5    * TYPE "VRG$"
       B51A 4E
[3310] B51B 06,A2,CE        CALL GETNUM          * ,BYTES
[3311] B51E 8F,4A           DCZ  @FAC            0?
[3312] B520 6C,E3           BS   ERRBV           BAD VALUE
[3313] B522 BD,0C,4A        DST  @FAC,@BYTES     SAVE NUMBER OF BYTES
[3314] B525 06,A2,AE        CALL STRFCH          * ,FROM
[3315] B528 D6,10,24        CEQ  36,@VAR5        * $? VDP STRING VARIABLE?      
[3316] B52B 55,39           BR   MOVESX
[3317] B52D C8,0D,50        CHE  @FAC6,@BYTES+1
[3318] B530 75,3F           BS   MOVESB

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0058 
RXB 2024
[3319] B532 86,0C           CLR  @BYTES
[3320] B534 BC,0D,50        ST   @FAC6,@BYTES+1
[3321] B537 55,3F           BR   MOVESB
[3322] B539 06,A2,C6 MOVESX CALL CFIFCH
[3323] B53C BD,4E,4A        DST  @FAC,@FAC4
[3324] B53F BD,04,4E MOVESB DST  @FAC4,@VARY
[3325] B542 D6,11,24        CEQ  36,@VAR6        * $? VDP STRING VARIABLE?   
[3326] B545 55,57           BR   MOVESN
[3327] B547 CB,0C,01        DCHE 256,@BYTES
       B54A 00
[3328] B54B 6C,E3           BS   ERRBV
[3329] B54D 0F,71           XML  GETSTR
[3330] B54F 06,A2,E6        CALL NGOOD
[3331] B552 BD,4A,1C        DST  @SREF,@FAC
[3332] B555 55,5A           BR   MOVESC
[3333] B557 06,A2,D7 MOVESN CALL SUBLP3          * ,TO
[3334] B55A BD,06,4A MOVESC DST  @FAC,@VARY2
[3335] B55D D6,10,24        CEQ  36,@VAR5        * $? VDP STRING VARIABLE? 
[3336] B560 55,65           BR   MTYPES
[3337] B562 BE,10,56        ST   86,@VAR5        * V? VDP ADDRESS?
[3338] B565 D6,11,24 MTYPES CEQ  36,@VAR6        * $? VDP STRING VARIABLE? 
[3339] B568 55,6D           BR   MTYPE
[3340] B56A BE,11,56        ST   86,@VAR6        * VDP 
[3341] B56D D6,10,56 MTYPE  CEQ  86,@VAR5        * V? VDP FROM
[3342] B570 55,9A           BR   MTYPE3
[3343] B572 D6,11,56        CEQ  86,@VAR6        * V? VDP TO
[3344] B575 55,7F           BR   MTYPE1
[3345] B577 34,0C,E0 MTYPE0 MOVE @BYTES,V@0(@VARY),V@0(@VARY2)
       B57A 00,06,E0
       B57D 00,04
[3346] B57F D6,11,52 MTYPE1 CEQ  82,@VAR6        * R? RAM TO
[3347] B582 55,8D           BR   MTYPE2
[3348] B584 34,0C,CF        MOVE @BYTES,V@0(@VARY),@0(@VARY2)
       B587 7D,00,06
       B58A E0,00,04
[3349] B58D D6,11,47 MTYPE2 CEQ  71,@VAR6        * G? GRAM TO
[3350] B590 55,9A           BR   MTYPE3
[3351] B592 2C,0C,00        MOVE @BYTES,V@0(@VARY),G@0(@VARY2)
       B595 00,06,E0
       B598 00,04
[3352] B59A D6,10,52 MTYPE3 CEQ  82,@VAR5        * R? RAM FROM
[3353] B59D 55,CA           BR   MTYPE7
[3354] B59F D6,11,56        CEQ  86,@VAR6        * V? VDP TO
[3355] B5A2 55,AD           BR   MTYPE5
[3356] B5A4 34,0C,E0 MTYPE4 MOVE @BYTES,@0(@VARY),V@0(@VARY2)
       B5A7 00,06,CF
       B5AA 7D,00,04
[3357] B5AD D6,11,52 MTYPE5 CEQ  82,@VAR6        * R? RAM TO
[3358] B5B0 55,BC           BR   MTYPE6
[3359] B5B2 34,0C,CF        MOVE @BYTES,@0(@VARY),@0(@VARY2)
       B5B5 7D,00,06
       B5B8 CF,7D,00
       B5BB 04
[3360] B5BC D6,11,47 MTYPE6 CEQ  71,@VAR6        * G? GRAM TO
[3361] B5BF 55,CA           BR   MTYPE7
[3362] B5C1 2C,0C,00        MOVE @BYTES,@0(@VARY),G@0(@VARY2)
       B5C4 00,06,CF
       B5C7 7D,00,04
[3363] B5CA D6,10,47 MTYPE7 CEQ  71,@VAR5        * G? GRAM FROM
[3364] B5CD 55,F7           BR   MOVESD
[3365] B5CF D6,11,56        CEQ  86,@VAR6        * V? VDP TO
[3366] B5D2 55,DC           BR   MTYPE9
[3367] B5D4 32,0C,E0 MTYPE8 MOVE @BYTES,G@0(@VARY),V@0(@VARY2)
       B5D7 00,06,00

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0059 
RXB 2024
       B5DA 00,04
[3368] B5DC D6,11,52 MTYPE9 CEQ  82,@VAR6        * R? RAM TO
[3369] B5DF 55,EA           BR   MTYPEA
[3370] B5E1 32,0C,CF        MOVE @BYTES,G@0(@VARY),@0(@VARY2)
       B5E4 7D,00,06
       B5E7 00,00,04
[3371] B5EA D6,11,47 MTYPEA CEQ  71,@VAR6        * G? GRAM TO
[3372] B5ED 55,F7           BR   MOVESD
[3373] B5EF 2A,0C,00        MOVE @BYTES,G@0(@VARY),G@0(@VARY2)
       B5F2 00,06,00
       B5F5 00,04
[3374] B5F7 D6,42,B3 MOVESD CEQ  >B3,@CHAT       * COMMA?  
[3375] B5FA 75,14           BS   MOVESA
[3376] B5FC 48,82           BR   LNKRTN
[3377]               **********************************************************
[3378]               * CALL HEX($variable,variable,...)                       *
[3379]               * CALL HEX(variable,$variable,...)                       *
[3380]               **********************************************************
[3381] B5FE 06,A9,67 HEX    CALL COMB             * HEX(variable,variable)
[3382] B601 06,A2,AE HEXAGN CALL STRFCH            Get STRING or NUMBER
[3383] B604 D6,4C,65        CEQ  >65,@FAC2         STRING?
[3384] B607 76,5E           BS   HEX00             Yes
[3385]               ****************************** Number to HEX String
[3386] B609 06,A2,C6        CALL CFIFCH            Turn from DEC to HEX
[3387] B60C BD,56,4A        DST  @FAC,@TEMP2       Save it
[3388] B60F BF,0C,00        DST  >0004,@BYTES      Number of byte for string
       B612 04
[3389] B613 0F,71           XML  GETSTR            Get String 
[3390] B615 BD,12,1C        DST  @SREF,@STRPTR     Save string location 
[3391] B618 BC,00,56        ST   @TEMP2,@PAD       Get one byte in PAD
[3392] B61B E6,00,04        SRL  4,@PAD            Strip off low bits
[3393] B61E 06,B6,4C        CALL HEXNS             Convert to ASCII
[3394] B621 BC,00,56        ST   @TEMP2,@PAD       Get one byte in PAD
[3395] B624 E2,00,04        SLL  4,@PAD            Strip off high bits
[3396] B627 E6,00,04        SRL  4,@PAD            Put back now high bits gone
[3397] B62A 06,B6,4C        CALL HEXNS             Convert to ASCII
[3398] B62D BC,00,57        ST   @TEMP2+1,@PAD     Get one byte in PAD 
[3399] B630 E6,00,04        SRL  4,@PAD            Strip off low bits
[3400] B633 06,B6,4C        CALL HEXNS             Convert to ASCII
[3401] B636 BC,00,57        ST   @TEMP2+1,@PAD     Get one byte in PAD 
[3402] B639 E2,00,04        SLL  4,@PAD            Strip off high bits
[3403] B63C E6,00,04        SRL  4,@PAD            Put back now high bits gone
[3404] B63F 06,B6,4C        CALL HEXNS             Convert to ASCII
[3405] B642 D6,42,B3        CEQ  COMMAZ,@CHAT      , COMMA?
[3406] B645 4C,AF           BR   ERRSYN            ERROR SYNTAX
[3407] B647 06,A2,E6        CALL NGOOD             Assign to Variable
[3408] B64A 56,78           BR   HEXDON            Go check for COMMA
[3409] B64C CA,00,0A HEXNS  CHE  >0A,@PAD          10 or higher?
[3410] B64F 56,54           BR   HEXNS2            No
[3411] B651 A2,00,07        ADD  >07,@PAD          Add 7
[3412] B654 A2,00,30 HEXNS2 ADD  >30,@PAD          Add 48
[3413] B657 BC,B0,12        ST   @PAD,V*STRPTR     Save new byte
       B65A 00
[3414] B65B 91,12           DINC @STRPTR           Next Character
[3415] B65D 00              RTN
[3416]               ***************************** HEX String to NUMBER
[3417] B65E 06,B6,7F HEX00  CALL HEXSTR            ASC to HEX
[3418] B661 0F,79           XML  PGMCHR            Next value?
[3419] B663 06,A3,01        CALL SNDER             Send value
[3420] B666 06,A3,0D        CALL CLRFAC            Clear FAC
[3421] B669 86,8F,DD        CLR  @>6004            Set ROM 3 page
       B66C 04
[3422] B66D 0F,76           XML  ASCHEX            Convert ASC to HEX
[3423] B66F D7,5C,99        DCEQ >994A,@ARG        ERROR FLAG?

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0060 
RXB 2024
       B672 4A
[3424] B673 6C,DF           BS   ERRBA             ERROR BAD ARGUMENT
[3425] B675 06,A3,08        CALL CIFSND            Convert Integer to FP send
[3426] B678 D6,42,B3 HEXDON CEQ  COMMAZ,@CHAT      , COMMA?  
[3427] B67B 76,01           BS   HEXAGN            Next set to run
[3428] B67D 48,82           BR   LNKRTN            Return to XB
[3429]               ******************************
[3430] B67F 8F,50    HEXSTR DCZ  @FAC6         Zero length string?
[3431] B681 6C,DF           BS   ERRBA         ERROR BAD ARGUMENT
[3432] B683 D6,B0,4E        CEQ  62,V*FAC4     > ?
       B686 3E
[3433] B687 56,91           BR   HEX01         No
[3434] B689 91,4E           DINC @FAC4         Add 1 to ignore >
[3435] B68B 92,51           DEC  @FAC7         Length -1 ignore >
[3436] B68D 8E,51           CZ   @FAC7
[3437] B68F 6C,DF           BS   ERRBA         ERROR BAD ARGUMENT
[3438] B691 BF,00,30 HEX01  DST  >3030,@PAD    ZERO BUFFER
       B694 30
[3439] B695 BF,02,30        DST  >3030,@PAD2   ZERO BUFFER
       B698 30
[3440] B699 D6,51,01        CEQ 1,@FAC7        1 to move
[3441] B69C 56,A7           BR   HEX02         No
[3442] B69E 35,00,01        MOVE 1,V@0(@FAC4),@PAD3 Get 1 chr
       B6A1 03,E0,00
       B6A4 4E
[3443] B6A5 56,CA           BR   HEX05         Check valid
[3444] B6A7 D6,51,02 HEX02  CEQ  2,@FAC7       2 to move 
[3445] B6AA 56,B5           BR   HEX03         No
[3446] B6AC 35,00,02        MOVE 2,V@0(@FAC4),@PAD2 Get 2 chr
       B6AF 02,E0,00
       B6B2 4E
[3447] B6B3 56,CA           BR   HEX05         Check valid
[3448] B6B5 D6,51,03 HEX03  CEQ  3,@FAC7       3 to move
[3449] B6B8 56,C3           BR   HEX04         No
[3450] B6BA 35,00,03        MOVE 3,V@0(@FAC4),@PAD1 Get 3 chr
       B6BD 01,E0,00
       B6C0 4E
[3451] B6C1 56,CA           BR   HEX05         Check valid
[3452] B6C3 35,00,04 HEX04  MOVE 4,V@0(@FAC4),@PAD Get 4 chr
       B6C6 00,E0,00
       B6C9 4E
[3453] B6CA 00       HEX05  RTN                Return to caller
[3454]               *********************************************************
[3455]               * CALL IO(type,address,...)                             *
[3456]               * CALL IO(type,bits,cru-base,variable,variable,...)     *
[3457]               * CALL IO(type,length,VDP-address,...)                  *
[3458]               *********************************************************
[3459] B6CB 06,A9,67 RXBIO  CALL COMB         * IO
[3460] B6CE 06,A2,CE IOAGN  CALL GETNUM       * TYPE 0-6
[3461] B6D1 CA,4B,07        CHE  >07,@FAC1
[3462] B6D4 6C,E3           BS   ERRBV
[3463] B6D6 BC,04,4B        ST   @FAC1,@VARY
[3464] B6D9 06,A2,D7        CALL SUBLP3       * ADDRESS/
[3465] B6DC 8A,04           CASE @VARY        * BITS/BYTES
[3466] B6DE 56,EC           BR   SOG
[3467] B6E0 56,F1           BR   SOV
[3468] B6E2 56,F6           BR   CRUI
[3469] B6E4 57,21           BR   CRUO
[3470] B6E6 57,4B           BR   CSW
[3471] B6E8 57,53           BR   CSR
[3472] B6EA 57,5B           BR   CSV
[3473] B6EC F6,4A,00 SOG    I/O  0,@FAC
[3474] B6EF 57,61           BR   IODONE
[3475] B6F1 F6,4A,01 SOV    I/O  1,@FAC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0061 
RXB 2024
[3476] B6F4 57,61           BR   IODONE
[3477] B6F6 06,B7,70 CRUI   CALL CRUSET
[3478] B6F9 F6,0E,02        I/O  2,@VAR4
[3479] B6FC 0F,79           XML  PGMCHR
[3480] B6FE 06,A3,01        CALL SNDER
[3481] B701 06,A3,0D        CALL CLRFAC
[3482] B704 BC,4B,00        ST   @PAD,@FAC1
[3483] B707 06,A3,08        CALL CIFSND       * VARIABLE1
[3484] B70A CA,04,09        CHE  >09,@VARY
[3485] B70D 77,11           BS   CRUI16
[3486] B70F 57,61           BR   IODONE
[3487] B711 0F,79    CRUI16 XML  PGMCHR
[3488] B713 06,A3,01        CALL SNDER
[3489] B716 06,A3,0D        CALL CLRFAC
[3490] B719 BC,4B,01        ST   @PAD1,@FAC1
[3491] B71C 06,A3,08        CALL CIFSND       * VARIABLE2
[3492] B71F 57,61           BR   IODONE
[3493] B721 06,B7,70 CRUO   CALL CRUSET
[3494] B724 06,A2,D7        CALL SUBLP3       * VARIABLE1
[3495] B727 CB,4A,01        DCHE >0100,@FAC
       B72A 00
[3496] B72B 6C,E3           BS   ERRBV
[3497] B72D CA,04,09        CHE  >09,@VARY
[3498] B730 77,37           BS   CRUO16
[3499] B732 BC,00,4B        ST   @FAC1,@PAD
[3500] B735 57,46           BR   CRUO8
[3501] B737 BD,00,4A CRUO16 DST  @FAC,@PAD
[3502] B73A 06,A2,D7        CALL SUBLP3       * VARIABLE2
[3503] B73D CB,4A,01        DCHE >0100,@FAC
       B740 00
[3504] B741 6C,E3           BS   ERRBV
[3505] B743 BC,01,4B        ST   @FAC1,@PAD1
[3506] B746 F6,0E,03 CRUO8  I/O  3,@VAR4
[3507] B749 57,61           BR   IODONE
[3508] B74B 06,B7,86 CSW    CALL CSLOAD
[3509] B74E F6,0E,04        I/O  4,@VAR4
[3510] B751 57,61           BR   IODONE
[3511] B753 06,B7,86 CSR    CALL CSLOAD
[3512] B756 F6,0E,05        I/O  5,@VAR4
[3513] B759 57,61           BR   IODONE
[3514] B75B 06,B7,86 CSV    CALL CSLOAD
[3515] B75E F6,0E,06        I/O  6,@VAR4
[3516] B761 D6,42,B3 IODONE CEQ  >B3,@CHAT
[3517] B764 76,CE           BS   IOAGN
[3518] B766 48,82           BR   LNKRTN
[3519] B768 BD,0E,4A CRUTMP DST  @FAC,@VAR4
[3520] B76B 87,10           DCLR @VAR5
[3521] B76D 87,00           DCLR @PAD
[3522] B76F 00              RTN
[3523] B770 8E,4B    CRUSET CZ   @FAC1
[3524] B772 6C,E3           BS   ERRBV
[3525] B774 CA,4A,11        CHE  >11,@FAC
[3526] B777 6C,E3           BS   ERRBV
[3527] B779 BC,04,4B        ST   @FAC1,@VARY
[3528] B77C 06,A2,D7        CALL SUBLP3       * CRU-ADDRESS
[3529] B77F 06,B7,68        CALL CRUTMP
[3530] B782 BC,10,04        ST   @VARY,@VAR5
[3531] B785 00              RTN
[3532] B786 06,B7,68 CSLOAD CALL CRUTMP
[3533] B789 06,A2,D7        CALL SUBLP3       * ADDRESS
[3534] B78C BD,10,4A        DST  @FAC,@VAR5
[3535] B78F 00              RTN
[3536]               *********************************************************
[3537]               * CALL HPUT(row,column,$variable,...)                    *

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0062 
RXB 2024
[3538]               * CALL HPUT(row,column,number-variable,...)              *
[3539]               **********************************************************
[3540] B790 06,B7,B0 HPUTZ  CALL PUTZ    
[3541] B793 86,8F,DD HPUTS  CLR  @>6004        Set ROM 3 page
       B796 04
[3542] B797 0F,77           XML  HPUT
[3543] B799 D6,42,B3 HPOUT  CEQ  COMMAZ,@CHAT
[3544] B79C 77,90           BS   HPUTZ
[3545] B79E 48,82           BR   LNKRTN
[3546]               **********************************************************
[3547]               * CALL VPUT(row,column,$variable,...)                    *
[3548]               * CALL VPUT(row,column,number-variable,...)              *
[3549]               **********************************************************
[3550] B7A0 06,B7,B0 VPUTZ  CALL PUTZ              Get ( and ROW         No, CNS
[3551] B7A3 86,8F,DD VPUTS  CLR  @>6004        Set ROM 3 page
       B7A6 04
[3552] B7A7 0F,78           XML  VPUT
[3553] B7A9 D6,42,B3 VPOUT  CEQ  COMMAZ,@CHAT
[3554] B7AC 77,A0           BS   VPUTZ
[3555] B7AE 48,82           BR   LNKRTN
[3556]               *******************************
[3557] B7B0 06,AA,D9 PUTZ   CALL RGPHV
[3558] B7B3 06,A2,B0        CALL STRPAR
[3559] B7B6 D6,4C,65        CEQ  >65,@FAC2
[3560] B7B9 77,DC           BS   PUTZ1
[3561] B7BB 86,55           CLR  @FAC11            Select XB FLP
[3562] B7BD 0F,73           XML  XBCNS             Convert Number to String
[3563] B7BF D6,90,55        CEQ  SPACE,*FAC11      Leading space?
       B7C2 20
[3564] B7C3 57,C9           BR   HVPUTN
[3565] B7C5 90,55           INC  @FAC11            Supress space out
[3566] B7C7 92,56           DEC  @FAC12            Shorten length
[3567] B7C9 86,0C    HVPUTN CLR  @BYTES
[3568] B7CB BC,0D,56        ST   @FAC12,@BYTES+1        Length
[3569] B7CE 0F,71           XML  GETSTR                 Get string
[3570] B7D0 34,0C,B0        MOVE @BYTES,*FAC11,V*SREF   Store in VDP rollout
       B7D3 1C,90,55
[3571] B7D6 BD,4E,1C        DST  @SREF,@FAC4            VDP rollout address
[3572] B7D9 BD,50,0C        DST  @BYTES,@FAC6           Store length
[3573] B7DC 00       PUTZ1  RTN
[3574]               **********************************************************
[3575]               * CALL HGET(row,column,length,$variable,...)             *
[3576]               **********************************************************
[3577] B7DD 06,A9,67 HGETZ  CALL COMB              (?
[3578] B7E0 06,B8,03 HGETS  CALL HVGETS            Get Row:Column,Length,String
[3579] B7E3 86,8F,DD        CLR  @>6004            Set ROM 3 page 
       B7E6 04
[3580] B7E7 0F,7A           XML  HGET              Assembly
[3581] B7E9 D6,42,B3        CEQ  >B3,@CHAT         ,? 
[3582] B7EC 77,E0           BS   HGETS             Yes        
[3583] B7EE 48,82           BR   LNKRTN            Return to XB
[3584]               **********************************************************
[3585]               * CALL VGET(row,column,length,$variable,...)             *
[3586]               **********************************************************
[3587] B7F0 06,A9,67 VGETZ  CALL COMB              (? 
[3588] B7F3 06,B8,03 VAGAIN CALL HVGETS            Get Row & Column & Length
[3589] B7F6 86,8F,DD        CLR  @>6004            Set ROM 3 page
       B7F9 04
[3590] B7FA 0F,7B           XML  VGET              Assembly
[3591] B7FC D6,42,B3        CEQ  >B3,@CHAT         ,? 
[3592] B7FF 77,F3           BS   VAGAIN            Yes
[3593] B801 48,82           BR   LNKRTN            Return to XB
[3594]               ******************************
[3595] B803 06,AA,A2 HVGETS CALL HVRC         Get Row & Column (PAD2)

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0063 
RXB 2024
[3596] B806 06,A2,D7        CALL SUBLP3       Skip comma get Length 
[3597] B809 8F,4A           DCZ  @FAC         0?
[3598] B80B 6C,E3           BS   ERRBV        ERROR BAD VALUE
[3599] B80D CF,4A,00        DCGT >00FF,@FAC   Larger then 255?
       B810 FF
[3600] B811 6C,E3           BS   ERRBV        ERROR BAD VALUE
[3601] B813 BD,0C,4A        DST  @FAC,@BYTES
[3602] B816 0F,71           XML  GETSTR       Get string location
[3603] B818 BD,06,0C        DST  @BYTES,@PAD6 Set string Length (PAD6)
[3604] B81B BD,04,1C        DST  @SREF,@PAD4  Save String location (PAD4)
[3605] B81E 06,A2,E6        CALL NGOOD        Skip comma & assign string
[3606] B821 00              RTN
[3607]               **********************************************************
[3608]               * CALL GMOTION(#sprite,row-varable,col-variable,...)     *
[3609]               **********************************************************
[3610] B822 06,A9,67 GMOT   CALL COMB              * 
[3611] B825 06,B0,06 GMAGN  CALL SPNUM2
[3612] B828 BE,54,02        ST   >02,@TEMP1
[3613] B82B BD,56,E4        DST  V@>0480(@PAD8),@TEMP2
       B82E 80,08
[3614] B830 06,B0,AD GMO1   CALL PREPN
[3615] B833 BC,4B,56        ST   @TEMP2,@FAC+1
[3616] B836 C6,4B,7F        CH   >7F,@FAC+1
[3617] B839 58,3F           BR   GMO2
[3618] B83B 82,4B           NEG  @FAC+1
[3619] B83D 83,4A           DNEG @FAC
[3620] B83F 06,A3,08 GMO2   CALL CIFSND
[3621] B842 D6,54,01        CEQ  >01,@TEMP1
[3622] B845 78,4B           BS   GMO3
[3623] B847 0F,7E           XML  SPEED
[3624] B849 00,B3           DATA >00B3
[3625] B84B C0,57,56 GMO3   EX   @TEMP2,@TEMP2+1
[3626] B84E 92,54           DEC  @TEMP1
[3627] B850 58,30           BR   GMO1
[3628] B852 D6,42,B3        CEQ  >B3,@CHAT
[3629] B855 78,25           BS   GMAGN
[3630] B857 48,82           BR   LNKRTN
[3631]               **********************************************************
[3632]               * CALL RMOTION(#sprite,ALL)                              *
[3633]               * CALL RMOTION(#sprite,#sprite,...)                      *
[3634]               **********************************************************
[3635] B859 06,A9,67 RMOT   CALL COMB               *  
[3636] B85C 0F,79    RMAGN  XML  PGMCHR
[3637] B85E D6,42,EC        CEQ  >EC,@CHAT
[3638] B861 58,73           BR   NOALL
[3639] B863 0F,7E           XML  SPEED
[3640] B865 00,EC           DATA >00EC
[3641] B867 BF,00,00        DST  >001C,@PAD
       B86A 1C
[3642] B86B BD,4A,00 NXALL  DST  @PAD,@FAC
[3643] B86E 06,B0,18        CALL SPNUM5
[3644] B871 58,82           BR   RMALL
[3645] B873 BF,00,00 NOALL  DST  >0001,@PAD
       B876 01
[3646] B877 D6,42,FD        CEQ  NUMBEZ,@CHAT
[3647] B87A 4C,AF           BR   ERRSYN
[3648] B87C 06,A2,BD        CALL NUMFCH
[3649] B87F 06,B0,12        CALL SPNUM4
[3650] B882 BD,54,E4 RMALL  DST  V@>0480(@PAD8),@TEMP1
       B885 80,08
[3651] B887 BE,56,02        ST   >02,@TEMP2
[3652] B88A 8E,54    RMOTLP CZ   @TEMP1
[3653] B88C 78,9E           BS   J2
[3654] B88E D6,54,80        CEQ  >80,@TEMP1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0064 
RXB 2024
[3655] B891 78,AA           BS   J3
[3656] B893 C6,54,7F        CH   >7F,@TEMP1
[3657] B896 78,9C           BS   J1
[3658] B898 82,54           NEG  @TEMP1
[3659] B89A 58,9E           BR   J2
[3660] B89C 80,54    J1     ABS  @TEMP1
[3661] B89E C0,55,54 J2     EX   @TEMP1,@TEMP1+1
[3662] B8A1 92,56           DEC  @TEMP2
[3663] B8A3 58,8A           BR   RMOTLP
[3664] B8A5 BD,E4,80        DST  @TEMP1,V@>0480(@PAD8)
       B8A8 08,54
[3665] B8AA 93,00    J3     DDEC @PAD
[3666] B8AC 58,6B           BR   NXALL
[3667] B8AE D6,42,B3        CEQ  >B3,@CHAT
[3668] B8B1 78,5C           BS   RMAGN
[3669] B8B3 48,82           BR   LNKRTN
[3670]               ***********************************************************
[3671]               * CALL COINC(#sprite,#sprite,tolerance,variable,...)       
[3672]               * CALL COINC(#sprite,dotrow,dotcol,tolerance,variable,...) 
[3673]               ***********************************************************
[3674] B8B5 06,AE,CF ZSCOI  CALL SPRCOI       *    
[3675] B8B8 D6,42,B3 COINLP CEQ  >B3,@CHAT    *
[3676] B8BB 48,82           BR   LNKRTN       *
[3677] B8BD 0F,79           XML  PGMCHR       *
[3678] B8BF 06,AE,E5        CALL GAF56        *
[3679] B8C2 58,B8           BR   COINLP       *
[3680]               ***********************************************************
[3681]               * CALL DISTANCE(#sprite,#sprite,variable,...)              
[3682]               * CALL DISTANCE(#sprite,dot-row,dot-col,variable,...)      
[3683]               ***********************************************************
[3684] B8C4 06,AF,55 ZDIST CALL DIST          *    
[3685] B8C7 D6,42,B3 DISLP  CEQ  >B3,@CHAT    *
[3686] B8CA 48,82           BR   LNKRTN       *
[3687] B8CC 06,AF,58        CALL GAFC4        *
[3688] B8CF 58,C7           BR   DISLP        *
[3689]              
[3690]               ***********************************************************
[3691]               * CALL KEY(string,keyunit,Nvarible,Nvariable...)          *
[3692]               * CALL KEY(keyunit,Nvariable,Nvarible...)                 *
[3693]               ***********************************************************
[3694] B8D1 06,AB,4E ZKEY   CALL KEY               Get key
[3695] B8D4 D6,42,B3        CEQ  COMMAZ,@CHAT
[3696] B8D7 78,D1           BS   ZKEY
[3697] B8D9 48,82           BR   LNKRTN
[3698]               ***********************************************************
[3699] B8DB BC,00,4B KEYJOY ST   @FAC1,@PAD        Keyboard selection
[3700] B8DE 06,A9,4E        CALL NUMVAR            Get variable for key-code
[3701] B8E1 D6,42,B3        CEQ  COMMAZ,@CHAT      If not comma - error
[3702] B8E4 4C,AF           BR   ERRSYN            SYNTAX error
[3703] B8E6 0F,79           XML  PGMCHR            Get next character
[3704] B8E8 06,A9,4E        CALL NUMVAR            Get variable for key-status
[3705] B8EB BC,74,00        ST   @PAD,@KEYBD       Keyboard selection
[3706] B8EE 31,00,08        MOVE 8,G@FLT1,@FAC     Set up float
       B8F1 4A,A3,32
[3707] B8F4 06,B8,FB        CALL KEYSTR            * RXB KEY STRING COMPARISON *
[3708] B8F7 BC,04,7C        ST   @STATUS,@VARY     Save stutus
[3709] B8FA 01              RTNC                   Return scan condition co
[3710]               ***********************************************************
[3711] B8FB D7,10,99 KEYSTR DCEQ >994A,@TOPSTK     Flag set?
       B8FE 4A
[3712] B8FF 59,2F           BR   RSCAN3            No.
[3713] B901 BD,08,04        DST  @VARY,@PAD8       String address.
[3714] B904 BD,02,06        DST  @CCPPTR,@ACCUM    Copy length.
[3715] B907 86,68           CLR  @BYTE3            Zero out counter

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0065 
RXB 2024
[3716] B909 D6,66,9B RSCAN  CEQ  ONZ,@BYTE1        ON flag?
[3717] B90C 59,12           BR   RSCAN0            No
[3718] B90E 03              SCAN                   Get a key
[3719] B90F 05,B9,15        B    RSCAN1            Jump past normal KEY
[3720] B912 03       RSCAN0 SCAN                   Any key?
[3721] B913 59,12           BR   RSCAN0            No.
[3722] B915 8F,06    RSCAN1 DCZ  @CCPPTR           Length 0?
[3723] B917 79,30           BS   RSCAN4            Yes.
[3724] B919 90,68    RSCAN2 INC  @BYTE3            Counter +1
[3725] B91B D4,75,B0        CEQ  V*PAD8,@RKEY      Same?
       B91E 08
[3726] B91F 79,35           BS   RSCAN5            Yes.
[3727] B921 91,08           DINC @PAD8             Address +1
[3728] B923 93,02           DDEC @ACCUM            Length -1
[3729] B925 59,19           BR   RSCAN2            No matcth.
[3730] B927 D6,66,9B        CEQ  ONZ,@BYTE1        ON flag?
[3731] B92A 79,30           BS   RSCAN4            Yes
[3732] B92C 05,B8,FB        B    KEYSTR            Restart.
[3733] B92F 03       RSCAN3 SCAN                   Normal key scan.
[3734] B930 86,74    RSCAN4 CLR  @KEYBD            Clear key unit
[3735] B932 87,10           DCLR @TOPSTK           Clear flag.
[3736] B934 01              RTNC                   Return save condition
[3737] B935 06,B9,30 RSCAN5 CALL RSCAN4
[3738] B938 D4,00,00        CEQ  @PAD,@PAD         Force condition bit on
[3739] B93B 01              RTNC                   Return save condition
[3740]               ***********************************************************
[3741]               * CALL ONKEY(string,keyunit,variable,variable)            *
[3742]               * GOTO line#,line#,line#...                               *
[3743]               ***********************************************************
[3744] B93C BE,66,9B ZONKEY ST   ONZ,@BYTE1
[3745] B93F 8E,44           CZ   @PRGFLG           Program mode?
[3746] B941 6C,DB           BS   ERRLNF            ERROR LINE NOT FOUND
[3747] B943 06,AB,4E        CALL KEY               Get normal key,status
[3748] B946 8E,04           CZ   @VARY             Was a key pressed?
[3749] B948 59,4C           BR   GOTON0            No ONZ flag stays set
[3750] B94A 86,66           CLR  @BYTE1            Clear ONZ flag
[3751] B94C D6,42,B6 GOTON0 CEQ  RPARZ,@CHAT       )
[3752] B94F 4C,AF           BR   ERRSYN            SYNTAX ERROR
[3753] B951 0F,79           XML  PGMCHR            Skip )
[3754] B953 D6,42,86        CEQ  GOTOZ,@CHAT       GOTO flag?
[3755] B956 4C,AF           BR   ERRSYN            SYNTAX ERROR
[3756] B958 86,67           CLR  @BYTE2            Zero out Counter
[3757] B95A 90,67    ONLP   INC  @BYTE2            Counter +1
[3758] B95C 0F,79           XML  PGMCHR            Skip GO
[3759] B95E D6,42,C9        CEQ  LNZ,@CHAT         Line# token?
[3760] B961 4C,AF           BR   ERRSYN            SYNTAX ERROR
[3761] B963 0F,79           XML  PGMCHR            Skip line# token
[3762] B965 BC,4A,42        ST   @CHAT,@FAC        Store high byte line#
[3763] B968 0F,79           XML  PGMCHR            Skip high byte line#
[3764] B96A BC,4B,42        ST   @CHAT,@FAC1       Store low byte line#
[3765] B96D 0F,79           XML  PGMCHR            Skip low byte line#
[3766] B96F D4,67,68        CEQ  @BYTE3,@BYTE2     $ counter = line# counter
[3767] B972 59,77           BR   ONKEY1            No
[3768] B974 BD,04,4A        DST  @FAC,@VARY        Save line#
[3769] B977 D6,42,B3 ONKEY1 CEQ  COMMAZ,@CHAT      ,?
[3770] B97A 79,5A           BS   ONLP              Yes, keep going
[3771] B97C BD,4A,04        DST  @VARY,@FAC        Get saved line#
[3772] B97F D6,66,9B        CEQ  ONZ,@BYTE1        ONZ flag?
[3773] B982 79,87           BS   GKEY1             Yes, load line#
[3774] B984 06,00,12        CALL RETURN            Return to XB
[3775]               **********************************************************
[3776] B987 BD,4C,32 GKEY1  DST  @ENLN,@FAC2        Get last address
[3777] B98A A7,4C,00        DSUB 3,@FAC2            Point to first LINE#
       B98D 03

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0066 
RXB 2024
[3778] B98E 06,80,2E GKEY2  CALL GRSUB3             Read from VDP/RAM
[3779] B991 4C              BYTE FAC2
[3780] B992 D5,4A,58        DCEQ @EEE1,@FAC         Same?
[3781] B995 79,A2           BS   GKEY3              Yes, found line#
[3782] B997 C5,4C,30        DCH  @STLN,@FAC2        No line# left
[3783] B99A 4C,DB           BR   ERRLNF             ERROR LINE NOT FOUND
[3784] B99C A7,4C,00        DSUB 4,@FAC2            Next LINE#
       B99F 04
[3785] B9A0 59,8E           BR   GKEY2              Loop
[3786] B9A2 BD,2E,4C GKEY3  DST  @FAC2,@EXTRAM      Got LINE#
[3787] B9A5 A3,2E,00        DADD 4,@EXTRAM          Point to begining of line
       B9A8 04
[3788] B9A9 95,2E           DINCT @EXTRAM           Point to ADDRESS
[3789] B9AB BD,2C,2E        DST  @EXTRAM,@PGMPTR    Set pointer to line to run
[3790] B9AE 95,2C           DINCT @PGMPTR           Point to tokens
[3791] B9B0 06,00,12        CALL RETURN             Return to XB
[3792]               **********************************************************
[3793]               * CALL JOYST(key-unit,x-return,y-return,...)             *
[3794]               **********************************************************
[3795] B9B3 06,BA,51 GJOYST CALL SPAR              KEY UNIT
[3796] B9B6 0F,7E    JOYRPT XML  SPEED             Insure in range
[3797] B9B8 02              BYTE RANGE          *   of 1 - 4
[3798] B9B9 01              BYTE 1
[3799] B9BA 00,04           DATA 4
[3800]               *                             GET VARIABLES FOR X, Y
[3801]               *                              AND SCAN KEYBOARD
[3802] B9BC BC,00,4B        ST   @FAC1,@PAD        Keyboard selection
[3803] B9BF 06,A9,4E        CALL NUMVAR            Get variable for key-code
[3804] B9C2 D6,42,B3        CEQ  COMMAZ,@CHAT      If not comma - error
[3805] B9C5 4C,AF           BR   ERRSYN
[3806] B9C7 0F,79           XML  PGMCHR            Get next character
[3807] B9C9 06,A9,4E        CALL NUMVAR            Get variable for key-status
[3808] B9CC BC,74,00        ST   @PAD,@KEYBD       Keyboard selection
[3809] B9CF 31,00,08        MOVE 8,G@FLT1,@FAC     Set up float
       B9D2 4A,A3,32
[3810] B9D5 03              SCAN                   SCAN the keyboard
[3811]               * RXB PATCH CODE SAVE KEY & JOYST
[3812] B9D6 BC,17,75 JOYSTS ST   @RKEY,@FNUM       SAVE KEY VALUE 
[3813] B9D9 BD,14,76        DST  @JOYY,@VAR9       JOYY & JOYX
[3814] B9DC 86,74           CLR  @KEYBD            Clear the code(No affect on s
[3815] B9DE BC,00,76        ST   @JOYY,@PAD        JOYSTICK Y POSITION
[3816] B9E1 06,A9,1B        CALL JOYXY             -4 to +4
[3817] B9E4 BF,4A,40        DST  >4001,@FAC        Re-store F.P. 1 in FAC
       B9E7 01
[3818] B9E8 BC,00,77        ST   @JOYX,@PAD        JOYSTICK X POSITION
[3819] B9EB 06,A9,1B        CALL JOYXY             -4 to +4
[3820] B9EE 00              RTN                    Return 
[3821]               ***********************************************************
[3822] B9EF 06,B9,B3 ZJOYST CALL GJOYST
[3823] B9F2 D6,42,B3 JOYAGN CEQ  COMMAZ,@CHAT
[3824] B9F5 48,82           BR   LNKRTN
[3825] B9F7 06,AB,A9        CALL CPAR3
[3826] B9FA 06,B9,B6        CALL JOYRPT
[3827] B9FD 59,F2           BR   JOYAGN
[3828]               ***********************************************************
[3829]               * MOTION PATCH for GO and STOP
[3830] B9FF 0F,79    SPGS   XML  PGMCHR            ( or ,
[3831] BA01 D6,42,EC        CEQ  ALLZ,@CHAT        ALL?
[3832] BA04 5A,2C           BR   SPGS1             No.
[3833] BA06 0F,79           XML  PGMCHR            Skip ALL
[3834] BA08 0F,79           XML  PGMCHR            Skip ,
[3835] BA0A BF,4A,00        DST  1,@FAC            First sprite
       BA0D 01
[3836] BA0E 06,B0,18        CALL SPNUM5            Get sprite table

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0067 
RXB 2024
[3837] BA11 06,B0,4E        CALL SPMOVE            Store velocity
[3838] BA14 BE,4A,1C        ST   28,@FAC           Last sprite
[3839] BA17 87,00           DCLR @PAD              Index
[3840] BA19 35,00,02 SPGSA  MOVE 2,V@>0780,V@>0780(@PAD)
       BA1C E7,80,00
       BA1F A7,80
[3841] BA21 A3,00,00        DADD 4,@PAD            Index +4
       BA24 04
[3842] BA25 92,4A           DEC  @FAC              Sprite -1
[3843] BA27 5A,19           BR   SPGSA             Done?
[3844] BA29 05,AF,2A        B    SPRMV4            Done?
[3845]               *
[3846] BA2C D6,42,FD SPGS1  CEQ  NUMBEZ,@CHAT      #?
[3847] BA2F 5A,37           BR   SPGS2             No.
[3848] BA31 06,B0,08        CALL SPNUM6            Standard routine.
[3849] BA34 05,AF,27        B    SPRMV3            No.
[3850]               *
[3851] BA37 D6,42,85 SPGS2  CEQ  GOZ,@CHAT         GO?
[3852] BA3A 5A,43           BR   SPGS3             No.
[3853] BA3C B2,80,C2        AND  >BF,@GKFLG        GO!!!
       BA3F BF
[3854] BA40 05,BA,4C        B    SPGS4             Done.
[3855]               *
[3856] BA43 D6,42,98 SPGS3  CEQ  STOPZ,@CHAT       STOP?
[3857] BA46 4C,AF           BR   ERRSYN            No
[3858] BA48 B6,80,C2        OR   >40,@GKFLG        STOP!!!
       BA4B 40
[3859] BA4C 0F,79    SPGS4  XML  PGMCHR            Skip GO or STOP
[3860] BA4E 05,AF,2A SPGSE  B    SPRMV4            Done?
[3861]               *********************************************************
[3862]               * RXB KEY & JOYSTICK LEFT PARENTHESES AND CHECK FOR STRING?
[3863] BA51 D6,42,B7 SPAR   CEQ  LPARZ,@CHAT       (?
[3864] BA54 7A,5B           BS   SPAR1             Yes.
[3865] BA56 D6,42,B3        CEQ  COMMAZ,@CHAT      ,?
[3866] BA59 4C,AF           BR   ERRSYN            No.
[3867] BA5B 0F,79    SPAR1  XML  PGMCHR            Skip ( or ,
[3868] BA5D 0F,74           XML  PARSE             Get string or value.
[3869] BA5F B6              BYTE RPARZ
[3870] BA60 D6,4C,65        CEQ  >65,@FAC2         RXB version String?
[3871] BA63 5A,73           BR   SPAR2             No normal xb version         
[3872] BA65 BD,04,4E        DST  @FAC4,@VARY       Save string address.
[3873] BA68 BD,06,50        DST  @FAC6,@VARY2      Save string length.
[3874] BA6B BF,10,99        DST  >994A,@TOPSTK     Set RXB flag.
       BA6E 4A
[3875] BA6F 06,AB,92        CALL LPARR           * Left PARENTHESES or COMMA 
[3876]               * RXB Version               * Get String or key value
[3877] BA72 00              RTN
[3878]               *
[3879] BA73 0F,7E    SPAR2  XML  SPEED
[3880] BA75 00              BYTE SYNCHK          * SYNTAX CHECKER
[3881] BA76 B3              BYTE COMMAZ          * ONLY COMMA IS VALID
[3882] BA77 00              RTN
[3883]               ***********************************************************
[3884]               * CALL JOYMOTION(keyunit,X,Y,#sprite,Rindex,Cindex)        
[3885]               * CALL JOYMOTION(keyunit,X,Y,#sprite,Rindex,Cindex,KEY)    
[3886]               * CALL JOYMOTION(keyunit,X,Y,#sprite,Rindex,Cindex,KEY)    
[3887]               * GOTO line-number                                         
[3888]               ***********************************************************
[3889] BA78 06,B9,B3 ZJOMO  CALL GJOYST         * Get Key unit, X & Y 
[3890] BA7B D6,42,B3        CEQ  COMMAZ,@CHAT   * COMMA?
[3891] BA7E 4C,AF           BR   ERRSYN         * SYNTAX ERROR
[3892] BA80 06,B0,06        CALL SPNUM2         * PAD8=SPRITE ADDRESS 
[3893] BA83 06,B0,94        CALL COMMA             Parse up to comma and skip
[3894] BA86 06,B0,70        CALL RANGEV            Check if numeric and convert

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0068 
RXB 2024
[3895]               *                              to integer
[3896] BA89 BC,0A,4B        ST   @FAC1,@PADA      Store Y velocity
[3897] BA8C 0F,74           XML  PARSE            Get X velocity
[3898] BA8E B6              BYTE RPARZ          * Check for ")" or less
[3899] BA8F 06,B0,70        CALL RANGEV           Numeric check and convert
[3900]               *                             to integer
[3901] BA92 BC,4A,0A       ST   @PADA,@FAC     * @FAC=Y velocity, @FAC1=X veloci
[3902]               * CHECK DIRECTION OF JOYST AND SET UP FAC FOR LOADING VALUE
[3903] BA95 D7,14,00        DCEQ >0000,@VAR9   * >0000 JOYST
       BA98 00
[3904] BA99 5A,9D           BR   ZJOMO1        * Go UP 
[3905] BA9B 87,4A           DCLR @FAC          * Zero both
[3906] BA9D D7,14,04 ZJOMO1 DCEQ >0400,@VAR9   * UP
       BAA0 00
[3907] BAA1 5A,A7           BR   ZJOMO2        * Go DOWN
[3908] BAA3 82,4A           NEG  @FAC          * Negative
[3909] BAA5 86,4B           CLR  @FAC1         * Zero
[3910] BAA7 D7,14,FC ZJOMO2 DCEQ >FC00,@VAR9   * DOWN
       BAAA 00
[3911] BAAB 5A,B1           BR   ZJOMO3        * Go LEFT
[3912] BAAD 80,4A           ABS  @FAC          * Postive
[3913] BAAF 86,4B           CLR  @FAC1         * Zero
[3914] BAB1 D7,14,00 ZJOMO3 DCEQ >00FC,@VAR9   * LEFT
       BAB4 FC
[3915] BAB5 5A,BB           BR   ZJOMO4        * Go RIGHT
[3916] BAB7 86,4A           CLR  @FAC          * Zero
[3917] BAB9 82,4B           NEG  @FAC1         * Negative
[3918] BABB D7,14,00 ZJOMO4 DCEQ >0004,@VAR9   * RIGHT
       BABE 04
[3919] BABF 5A,C5           BR   ZJOMO5        * Go DOWNLEFT
[3920] BAC1 86,4A           CLR @FAC           * Zero
[3921] BAC3 80,4B           ABS @FAC1          * Postive
[3922] BAC5 D7,14,FC ZJOMO5 DCEQ >FCFC,@VAR9   * DOWNLEFT
       BAC8 FC
[3923] BAC9 5A,CF           BR   ZJOMO6        * Go DOWNRIGHT
[3924] BACB 80,4A           ABS  @FAC          * Postitive
[3925] BACD 82,4B           NEG  @FAC1         * Negative
[3926] BACF D7,14,FC ZJOMO6 DCEQ >FC04,@VAR9   * DOWNRIGHT     
       BAD2 04
[3927] BAD3 5A,D9           BR   ZJOMO7        * Go UPLEFT
[3928] BAD5 80,4A           ABS  @FAC          * Positive
[3929] BAD7 80,4B           ABS  @FAC1         * Postive
[3930] BAD9 D7,14,04 ZJOMO7 DCEQ >04FC,@VAR9   * UPLEFT
       BADC FC
[3931] BADD 5A,E3           BR   ZJOMO8        * Go UPRIGHT
[3932] BADF 82,4A           NEG  @FAC          * Negative
[3933] BAE1 82,4B           NEG  @FAC1         * Negative
[3934] BAE3 D7,14,04 ZJOMO8 DCEQ >0404,@VAR9   * UPRIGHT 
       BAE6 04
[3935] BAE7 5A,ED           BR   ZJOMO9        * Done
[3936] BAE9 82,4A           NEG  @FAC          * Negative
[3937] BAEB 80,4B           ABS  @FAC1         * Positive    
[3938] BAED BD,E4,80 ZJOMO9 DST  @FAC,V@>0480(@PAD8) * Store velocities PAD8
       BAF0 08,4A
[3939] BAF2 C4,A3,AA        CH   @NOMSPR,V@SPNUM    * Check current sprite
       BAF5 7A
[3940] BAF6 5A,FC           BR   ZJOKG              *  against sprite motion
[3941]               *                              *   counter
[3942] BAF8 BC,7A,A3        ST   V@SPNUM,@NOMSPR * higher? Yes, replace it
       BAFB AA
[3943]               * KEY SECTION
[3944] BAFC D6,42,B6 ZJOKG  CEQ  RPARZ,@CHAT   * )?
[3945] BAFF 68,82           BS   LNKRTN        * Yes, END RETURN TO XB
[3946] BB01 06,AC,9F        CALL ERRCOM      * Check for comma, push on stack  

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0069 
RXB 2024
[3947] BB04 BC,4B,17        ST   @FNUM,@FAC1   * KEY         
[3948] BB07 0F,80           XML  CIF           * Convert to floating point
[3949] BB09 0F,7C           XML  ASSGNV        * Save KEY to XB      
[3950] BB0B D6,42,B6        CEQ  RPARZ,@CHAT   * )?
[3951] BB0E 4C,AF           BR   ERRSYN        * SYNTAX ERROR
[3952] BB10 0F,79           XML  PGMCHR        * Skip )
[3953]               * GOTO LINE# SECTION
[3954] BB12 D6,42,86        CEQ  GOTOZ,@CHAT   * GOTO flag?
[3955] BB15 5B,2F           BR   ZJOMOR        * No, just RETURN to XB
[3956] BB17 0F,79           XML  PGMCHR        * Skip GOTO or COMMA
[3957] BB19 D6,42,C9        CEQ  LNZ,@CHAT     * Line# token?
[3958] BB1C 4C,AF           BR   ERRSYN        * SYNTAX ERROR
[3959] BB1E 0F,79           XML  PGMCHR        * Skip line# token
[3960] BB20 BC,4A,42        ST   @CHAT,@FAC    * Store high byte line#
[3961] BB23 0F,79           XML  PGMCHR        * Skip high byte line#
[3962] BB25 BC,4B,42        ST   @CHAT,@FAC1   * Store low byte line#
[3963] BB28 0F,79           XML  PGMCHR        * Skip low byte line#
[3964] BB2A D6,17,12        CEQ  18,@FNUM      * FIRE BUTTON 1?
[3965] BB2D 79,87           BS   GKEY1         * Yes, find & run line#
[3966] BB2F 06,00,12 ZJOMOR CALL RETURN        * RETURN TO XB
[3967]               ***********************************************************
[3968]               * CALL JOYLOCATE(keyunit,X,Y,Rindex,Cindex,#sprite,dr,dc)  
[3969]               * CALL JOYLOCATE(keyunit,X,Y,Rindex,Cindex,#sprite,dr,dc,K)
[3970]               * CALL JOYLOCATE(keyunit,X,Y,Rindex,Cindex,#sprite,dr,dc,K)
[3971]               * GOTO line-number                                         
[3972]               ***********************************************************
[3973] BB32 06,B9,B3 ZJOLO  CALL GJOYST       * Get Key unit, X & Y 
[3974] BB35 D6,42,B3        CEQ  COMMAZ,@CHAT * COMMA?
[3975] BB38 4C,AF           BR   ERRSYN       * SYNTAX ERROR
[3976] BB3A 0F,79           XML  PGMCHR       * Skip COMMA
[3977] BB3C 06,B0,1F        CALL SPLOC        * Get index into PAD4 & PAD6
[3978] BB3F BC,00,05        ST   @PAD4+1,@PAD * Get Rindex
[3979] BB42 94,00           INCT @PAD         * RESET VALUE
[3980] BB44 BC,01,06        ST   @PAD6,@PAD1  * Get Cindex
[3981] BB47 90,01           INC  @PAD1        * RESET VALUE
[3982] BB49 D6,42,B3        CEQ  COMMAZ,@CHAT * COMMA?
[3983] BB4C 4C,AF           BR   ERRSYN       * SYNTAX ERROR
[3984] BB4E 06,B0,06        CALL SPNUM2       * PAD8=SPRITE ADDRESS 
[3985] BB51 06,B0,AD        CALL PREPN        * Set up for variable
[3986] BB54 BD,4A,B0        DST  V*PAD8,@FAC  * Get current dr & dc into FAC  
       BB57 08
[3987]               *
[3988]               * CHECK DIRECTION OF JOYST AND SET UP FAC FOR LOADING VALUE
[3989] BB58 D7,14,00        DCEQ >0000,@VAR9   * >0000 JOYST
       BB5B 00
[3990] BB5C 7B,B2           BS   ZJOLO9        * No change 
[3991] BB5E D7,14,04 ZJOLO1 DCEQ >0400,@VAR9   * UP
       BB61 00
[3992] BB62 5B,67           BR   ZJOLO2        * Go DOWN
[3993] BB64 A4,4A,00        SUB  @PAD,@FAC     * Negative
[3994] BB67 D7,14,FC ZJOLO2 DCEQ >FC00,@VAR9   * DOWN
       BB6A 00
[3995] BB6B 5B,70           BR   ZJOLO3        * Go LEFT
[3996] BB6D A0,4A,00        ADD  @PAD,@FAC     * Postive
[3997] BB70 D7,14,00 ZJOLO3 DCEQ >00FC,@VAR9   * LEFT
       BB73 FC
[3998] BB74 5B,79           BR   ZJOLO4        * Go RIGHT
[3999] BB76 A4,4B,00        SUB  @PAD,@FAC1    * Negative
[4000] BB79 D7,14,00 ZJOLO4 DCEQ >0004,@VAR9   * RIGHT
       BB7C 04
[4001] BB7D 5B,82           BR   ZJOLO5        * Go DOWNLEFT
[4002] BB7F A0,4B,00        ADD  @PAD,@FAC1    * Postive
[4003] BB82 D7,14,FC ZJOLO5 DCEQ >FCFC,@VAR9   * DOWNLEFT
       BB85 FC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0070 
RXB 2024
[4004] BB86 5B,8E           BR   ZJOLO6        * Go DOWNRIGHT
[4005] BB88 A0,4A,00        ADD  @PAD,@FAC     * Postitive
[4006] BB8B A4,4B,00        SUB  @PAD,@FAC1    * Negative
[4007] BB8E D7,14,FC ZJOLO6 DCEQ >FC04,@VAR9   * DOWNRIGHT     
       BB91 04
[4008] BB92 5B,9A           BR   ZJOLO7        * Go UPLEFT
[4009] BB94 A0,4A,00        ADD  @PAD,@FAC     * Positive
[4010] BB97 A0,4B,00        ADD  @PAD,@FAC1    * Postive
[4011] BB9A D7,14,04 ZJOLO7 DCEQ >04FC,@VAR9   * UPLEFT
       BB9D FC
[4012] BB9E 5B,A6           BR   ZJOLO8        * Go UPRIGHT
[4013] BBA0 A4,4A,00        SUB  @PAD,@FAC     * Negative
[4014] BBA3 A4,4B,00        SUB  @PAD,@FAC1    * Negative
[4015] BBA6 D7,14,04 ZJOLO8 DCEQ >0404,@VAR9   * UPRIGHT 
       BBA9 04
[4016] BBAA 5B,B2           BR   ZJOLO9        * Done
[4017] BBAC A4,4A,00        SUB  @PAD,@FAC     * Negative
[4018] BBAF A0,4B,00        ADD  @PAD,@FAC1    * Positive  
[4019] BBB2 BD,B0,08 ZJOLO9 DST  @FAC,V*PAD8   * Load ROW:COL into Sprite
       BBB5 4A
[4020] BBB6 BD,0C,4A        DST  @FAC,@BYTES   * Save value
[4021] BBB9 06,A3,0D        CALL CLRFAC
[4022] BBBC BC,4B,0C        ST   @BYTES,@FAC1
[4023] BBBF 06,A3,08        CALL CIFSND     * Put into Row
[4024] BBC2 06,B0,97        CALL COMMA2     * Next value & skip COMMA
[4025] BBC5 06,B0,AD        CALL PREPN      * Prepare X-pos return variable
[4026] BBC8 06,A3,0D        CALL CLRFAC
[4027] BBCB BC,4B,0D        ST   @BYTES+1,@FAC1 * Get X position
[4028] BBCE 06,A3,08        CALL CIFSND     * Assign value
[4029]               * KEY SECTION
[4030] BBD1 05,BA,FC        B    ZJOKG
[4031]               ***********************************************************
[4032]               * CALL INVERSE(char#[,...])                                
[4033]               ***********************************************************
[4034] BBD4 06,A9,67 INVERS CALL COMB             * INVERSE(CHAR#)
[4035] BBD7 0F,79    INVAGN XML  PGMCHR
[4036] BBD9 D6,42,EC        CEQ  ALLZ,@CHAT
[4037] BBDC 5B,F0           BR   INOALL
[4038] BBDE 0F,7E           XML  SPEED
[4039] BBE0 00,EC           DATA >00EC
[4040] BBE2 BF,4A,00        DST  >001E,@FAC
       BBE5 1E
[4041] BBE6 E3,4A,00        DSLL 3,@FAC
       BBE9 03
[4042] BBEA BF,54,01        DST  >01C8,@TEMP1
       BBED C8
[4043] BBEE 5B,FE           BR   INVLP
[4044] BBF0 0F,74    INOALL XML  PARSE
[4045] BBF2 B6              BYTE RPARZ
[4046] BBF3 06,BC,AF        CALL S1ET9F
[4047] BBF6 E3,4A,00        DSLL 3,@FAC
       BBF9 03
[4048] BBFA BF,54,00        DST  >0004,@TEMP1
       BBFD 04
[4049] BBFE 85,E3,00 INVLP  DINV V@>0300(@FAC)
       BC01 4A
[4050] BC02 A3,4A,00        DADD >0002,@FAC
       BC05 02
[4051] BC06 93,54           DDEC @TEMP1
[4052] BC08 5B,FE           BR   INVLP
[4053] BC0A D6,42,B3 INVNOK CEQ  COMMAZ,@CHAT
[4054] BC0D 7B,D7           BS   INVAGN
[4055] BC0F 48,82           BR   LNKRTN
[4056]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0071 
RXB 2024
[4057]               * CALL SWAPCHAR(character-code,character-code[,...])       
[4058]               ***********************************************************
[4059] BC11 06,A9,67 SWCHR  CALL COMB       * SWAPCHAR(CHAR#,CHAR#)
[4060] BC14 06,BC,A4 SWCHAG CALL SSDSLL
[4061] BC17 BD,0E,4A        DST  @FAC,@VAR4
[4062] BC1A D6,42,B3        CEQ  COMMAZ,@CHAT
[4063] BC1D 4C,AF           BR   ERRSYN
[4064] BC1F 06,BC,A4        CALL SSDSLL
[4065] BC22 BD,10,4A        DST  @FAC,@VAR5
[4066] BC25 35,00,08        MOVE 8,V@>0300(@VAR4),@FAC
       BC28 4A,E3,00
       BC2B 0E
[4067] BC2C 35,00,08        MOVE 8,V@>0300(@VAR5),V@>0300(@VAR4)
       BC2F E3,00,0E
       BC32 E3,00,10
[4068] BC35 35,00,08        MOVE 8,@FAC,V@>0300(@VAR5)
       BC38 E3,00,10
       BC3B 4A
[4069] BC3C D6,42,B3        CEQ  COMMAZ,@CHAT
[4070] BC3F 7C,14           BS   SWCHAG
[4071] BC41 48,82           BR   LNKRTN
[4072]               ***********************************************************
[4073]               * CALL SWAPCOLOR(#sprite-number,#sprite-number[,...])      
[4074]               * CALL SWAPCOLOR(character-set,character-set[,...])        
[4075]               ***********************************************************
[4076] BC43 0F,7E    SWCLR  XML  SPEED            * Must be
[4077] BC45 00              BYTE SYNCHK           *  at a
[4078] BC46 B7              BYTE LPARZ            *   left parenthesis
[4079] BC47 D6,42,FD SCOL10 CEQ  NUMBEZ,@CHAT
[4080] BC4A 5C,77           BR   SCOL20
[4081] BC4C 06,B0,0D        CALL SPNUM3
[4082] BC4F BC,0E,E0        ST   V@>0003(@FAC),@VAR4
       BC52 03,4A
[4083] BC54 BD,10,4A        DST  @FAC,@VAR5
[4084] BC57 D6,42,FD        CEQ  NUMBEZ,@CHAT
[4085] BC5A 4C,AF           BR   ERRSYN
[4086] BC5C 06,A2,AE        CALL STRFCH
[4087] BC5F 06,B0,12        CALL SPNUM4
[4088] BC62 BC,E0,03        ST   V@>0003(@FAC),V@>0003(@VAR5)
       BC65 10,E0,03
       BC68 4A
[4089] BC69 BC,E0,03        ST   @VAR4,V@>0003(@FAC)
       BC6C 4A,0E
[4090] BC6E D6,42,B3        CEQ  COMMAZ,@CHAT
[4091] BC71 48,82           BR   LNKRTN
[4092] BC73 0F,79           XML  PGMCHR
[4093] BC75 5C,47           BR   SCOL10
[4094] BC77 0F,7E    SCOL20 XML  SPEED
[4095] BC79 01              BYTE >01
[4096] BC7A 06,BC,B6        CALL S00T10
[4097] BC7D A3,4A,08        DADD >080F,@FAC
       BC80 0F
[4098] BC81 BD,0E,4A        DST  @FAC,@VAR4
[4099] BC84 0F,74           XML  PARSE
[4100] BC86 B6              BYTE RPARZ
[4101] BC87 06,BC,B6        CALL S00T10
[4102] BC8A A3,4A,08        DADD >080F,@FAC
       BC8D 0F
[4103] BC8E BC,00,B0        ST   V*FAC,@PAD
       BC91 4A
[4104] BC92 BC,B0,4A        ST   V*VAR4,V*FAC
       BC95 B0,0E
[4105] BC97 BC,B0,0E        ST   @PAD,V*VAR4
       BC9A 00

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0072 
RXB 2024
[4106] BC9B D6,42,B3        CEQ  COMMAZ,@CHAT
[4107] BC9E 48,82           BR   LNKRTN
[4108] BCA0 0F,79           XML  PGMCHR
[4109] BCA2 5C,77           BR   SCOL20     
[4110]               *****************************************
[4111] BCA4 06,A2,AE SSDSLL CALL STRFCH
[4112] BCA7 06,BC,AF        CALL S1ET9F
[4113] BCAA E3,4A,00        DSLL 3,@FAC
       BCAD 03
[4114] BCAE 00              RTN
[4115]               *****************************************
[4116] BCAF 0F,7E    S1ET9F XML  SPEED  * CHECK FROM
[4117] BCB1 02,1E           DATA >021E  * 30 TO 159
[4118] BCB3 00,9F           DATA >009F  *
[4119] BCB5 00              RTN         *
[4120]               ******************************************
[4121] BCB6 0F,7E    S00T10 XML  SPEED  * CHECK FROM
[4122] BCB8 02,00           DATA >0200  * 0 TO 16
[4123] BCBA 00,10           DATA >0010  *
[4124] BCBC 00              RTN         *
[4125]               ***********************************************************
[4126]               * CALL COLLIDE(#SPR1,#SPR2,TOLERANCE,S1DOTROW,S1DOTCOL)    
[4127]               * CALL COLLIDE(#SPR,DOTROW,DOTCOL,TOLERANCE,DOTROW,DOTCOL) 
[4128]                 
[4129]               ***********************************************************
[4130] BCBD 06,A9,67 COLLZ  CALL COMB              If not '(' - error
[4131] BCC0 06,B0,06 COLL3  CALL SPNUM2            Skip ( or , get SPRITE 1 valu
[4132] BCC3 BD,00,B0        DST  V*FAC,@PAD        Read ROW:COL position SPRITE1
       BCC6 4A
[4133] BCC7 D6,42,C8        CEQ  NUMZ,@CHAT      #?
[4134] BCCA 5C,E0           BR   COLL1             Yes SPRITE not Dot values  
[4135] BCCC 06,A2,DE        CALL SUBLP4            Get DOT ROW
[4136] BCCF 92,4B           DEC  @FAC1             Adjust for Assembly
[4137] BCD1 BC,02,4B        ST   @FAC1,@PAD2       Save DOT ROW
[4138] BCD4 06,A2,CE        CALL GETNUM            Get DOT COL 
[4139] BCD7 92,4B           DEC  @FAC1             Adjust for Assembly
[4140] BCD9 BC,03,4B        ST   @FAC1,@PAD3       Save DOT COL 
[4141] BCDC 0F,79           XML  PGMCHR            Skip COMMA 
[4142] BCDE 5C,E7           BR   COLL2             Go to TOLLERANCE
[4143] BCE0 06,B0,08 COLL1  CALL SPNUM6            Skip # get SPRITE 2 value
[4144] BCE3 BD,02,B0        DST  V*FAC,@PAD2       Read ROW:COL position SPRITE2
       BCE6 4A
[4145] BCE7 06,A2,DE COLL2  CALL SUBLP4            Get TOLERANCE in FAC     
[4146] BCEA 86,8F,DD        CLR  @>6004            Set ROM 3 page
       BCED 04
[4147] BCEE 0F,80           XML  COLLSP            COLLIDE SPRITES
[4148] BCF0 0F,79           XML  PGMCHR            Skip COMMA
[4149] BCF2 06,A3,01        CALL SNDER            Get variable info
[4150] BCF5 06,A3,0D        CALL CLRFAC           Clear for FP
[4151] BCF8 BD,4A,00        DST  @PAD,@FAC        Get QUOTIENT
[4152] BCFB 06,A3,08        CALL CIFSND           Send QUOTIENT
[4153] BCFE 0F,79           XML  PGMCHR           Skip COMMA
[4154] BD00 06,A3,01        CALL SNDER            Get variable info 
[4155] BD03 06,A3,0D        CALL CLRFAC           Clear for FP       
[4156] BD06 BD,4A,02        DST  @PAD2,@FAC       REMAINDER
[4157] BD09 06,A3,08        CALL CIFSND           Send REMAINDER 
[4158] BD0C D6,42,B3        CEQ  COMMAZ,@CHAT     ,?
[4159] BD0F 7C,C0           BS   COLL3            Yes loop
[4160] BD11 48,82           BR   LNKRTN           RETURN TO XB
[4161]               *******************************
[4162] BD13 0F,7A    SETSND XML  SYM               Pick up name & search table
[4163] BD15 0F,7B           XML  SMB               Evaluate any subscripts
[4164] BD17 C6,4C,63        CH   >63,@FAC2         If not numeric, error
[4165] BD1A 6C,E7           BS   ERRIAL            ERROR INCORRECT ARGUMENT LIST

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0073 
RXB 2024
[4166] BD1C 06,A3,0D        CALL CLRFAC            Clear FAC 8 bytes
[4167] BD1F 00              RTN                    Return
[4168]               ***********************************************************
[4169]               * RXB SIZE ADDRESS DISPLAY
[4170] BD20 0F,83    CASCII XML  SCROLL
[4171] BD22 BC,00,5C        ST   @ARG,@PAD         * Bit 1
[4172] BD25 E6,00,04        SRL  4,@PAD            * Strip off Bit 2
[4173] BD28 CA,00,0A        CHE  >0A,@PAD          * Higher >0A?
[4174] BD2B 7D,32           BS   BIT1D             * Yes
[4175] BD2D A2,00,30        ADD  48,@PAD           * 0 - 9 + "0 ASCII"
[4176] BD30 5D,38           BR   BIT2              * Done Bit 1
[4177] BD32 A6,00,0A BIT1D  SUB  10,@PAD
[4178] BD35 A2,00,41        ADD  65,@PAD           * A - F + "@ ASCII"
[4179] BD38 BC,4A,00 BIT2   ST   @PAD,@FAC         * Save Bit 1 as ASCII
[4180] BD3B BC,00,5C        ST   @ARG,@PAD         * Bit 2
[4181] BD3E E2,00,04        SLL  4,@PAD            * Strip off Bit 1
[4182] BD41 E6,00,04        SRL  4,@PAD            * Reset Bit 2
[4183] BD44 CA,00,0A        CHE  >0A,@PAD          * Higher >0A?
[4184] BD47 7D,4E           BS   BIT2D             * Yes
[4185] BD49 A2,00,30        ADD  48,@PAD           * 0 - 9 + "0 ASCII"
[4186] BD4C 5D,54           BR   BIT3              * Done Bit 2
[4187] BD4E A6,00,0A BIT2D  SUB  10,@PAD
[4188] BD51 A2,00,41        ADD  65,@PAD           * A - F + "@ ASCII"          
[4189] BD54 BC,4B,00 BIT3   ST   @PAD,@FAC1        * Save Bit 2 as ASCII      
[4190] BD57 BC,00,5D        ST   @ARG1,@PAD        * Bit 3
[4191] BD5A E6,00,04        SRL  4,@PAD            * Strip off Bit 4        
[4192] BD5D CA,00,0A        CHE  >0A,@PAD          * Higher >0A?
[4193] BD60 7D,67           BS   BIT3D             * Yes
[4194] BD62 A2,00,30        ADD  48,@PAD           * 0 - 9 + "0 ASCII"
[4195] BD65 5D,6D           BR   BIT4              * Done Bit 3
[4196] BD67 A6,00,0A BIT3D  SUB  10,@PAD
[4197] BD6A A2,00,41        ADD  65,@PAD           * A - F + "@ ASCII"
[4198] BD6D BC,4C,00 BIT4   ST   @PAD,@FAC2        * Save Bit 3 as ASCII
[4199] BD70 BC,00,5D        ST   @ARG1,@PAD        * Bit 4
[4200] BD73 E2,00,04        SLL  4,@PAD            * Strip off Bit 3
[4201] BD76 E6,00,04        SRL  4,@PAD            * Reset Bit 4
[4202] BD79 CA,00,0A        CHE  >0A,@PAD          * Higher >0A?
[4203] BD7C 7D,83           BS   BIT4D             * Yes
[4204] BD7E A2,00,30        ADD  48,@PAD           * 0 - 9 + "0 ASCII"
[4205] BD81 5D,89           BR   BITDI             * Done Bit 2
[4206] BD83 A6,00,0A BIT4D  SUB  10,@PAD
[4207] BD86 A2,00,41        ADD  65,@PAD           * A - F + "@ ASCII"          
[4208] BD89 BC,4D,00 BITDI  ST   @PAD,@FAC3        * Save Bit 2 as ASCII      
[4209] BD8C 08              FMT
[4210] BD8D FC,60            SCRO >60
[4211] BD8F FE,17            ROW 23
[4212] BD91 FF,04            COL 4
[4213] BD93 40,3E            HCHA 1,62
[4214] BD95 FE,17            ROW 23
[4215] BD97 FF,05            COL 5
[4216] BD99 E3,4A            HSTR 4,@FAC   
[4217] BD9B FB              FEND
[4218] BD9C 00              RTN
[4219]               ********************************************************
[4220]              
[4221]                      AORG >1FE0
[4222]               * MOSTLY SUBROUTINES FOR GROM 6
[4223] BFE0 49,67           BR   COMB        * >BFE0
[4224] BFE2 42,AE           BR   STRFCH      * >BFE2
[4225] BFE4 42,B0           BR   STRPAR      * >BFE4
[4226] BFE6 42,B4           BR   STRGET      * >BFE6
[4227] BFE8 42,BD           BR   NUMFCH      * >BFE8
[4228] BFEA 42,C6           BR   CFIFCH      * >BFEA
[4229] BFEC 42,D1           BR   GNRTN       * >BFEC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0074 
RXB 2024
[4230] BFEE 42,E6           BR   NGOOD       * >BFEE
[4231] BFF0 43,01           BR   SNDER       * >BFF0
[4232] BFF2 43,08           BR   CIFSND      * >BFF2
[4233] BFF4 43,0A           BR   SNDASS      * >BFF4
[4234] BFF6 42,D7           BR   SUBLP3      * >BFF6
[4235] BFF8 42,DE           BR   SUBLP4      * >BFF8
[4236] BFFA 43,0D           BR   CLRFAC      * >BFFA
[4237] BFFC 42,CE           BR   GETNUM      * >BFFC
[4238]               ********************************************************
[4239]                      END

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0075 
RXB 2024
Symbol Table #1 (New,alpha)  
0041 A          00CB ABSZ       801E ACCEPT     A192 ACCEPX     00A4 ACCEPZ     
8302 ACCUM      00EC ALLZ       00BB ANDZ       00F9 APPENZ     B0AA AR         
835D ARG1       835E ARG2       8360 ARG4       8362 ARG6       8363 ARG7       
8364 ARG8       A7C7 ASC        A459 ASC01      0076 ASCHEX     00DC ASCZ       
007C ASSGNV     B0A2 ASSRTN     00CC ATNZ       A798 ATTNUT     A95B ATTREG     
00F0 ATZ        0008 BACK       00F1 BASEZ      00EE BEEPZ      BD32 BIT1D      
BD38 BIT2       BD4E BIT2D      BD54 BIT3       BD67 BIT3D      BD6D BIT4       
BD83 BIT4D      BD89 BITDI      0020 BKGD       ABBD BORAGN     ABE7 BORCRN     
ABB8 BORDER     ABE0 BORDES     0002 BREAK      008E BREAKZ     8346 BUFLEV     
8366 BYTE1      8367 BYTE2      8368 BYTE3      830C BYTES      009D CALLZ      
BD20 CASCII     837D CB         834E CCC        834A CCHAR      8306 CCPPTR     
0012 CFI        A2C6 CFIFCH     007D CHAR       AB1F CHAR1      AB13 CHAR2      
AAFD CHAR5      AB47 CHARL4     AB22 CHARLD     AAFA CHARLY     8342 CHAT       
6A78 CHKEND     AFD9 CHRALL     AB36 CHRFIL     007F CHRLDR     AFBD CHRSET     
601C CHRTAB     6018 CHRTBL     000D CHRTN      A43E CHRZ01     00D6 CHRZZ      
0080 CIF        A308 CIFSND     00C5 CIRCUZ     A32C CKSTNM     0079 CLEARP     
A989 CLEARZ     800A CLOSE      A18F CLOSEX     00A0 CLOSEZ     A30D CLRFAC     
0007 CLRLN      A990 CLRPZ      A10A CLRRTN     8012 CLSALL     AFA5 CODIS1     
AFAB CODIS2     AF7D CODIST     B8B8 COINLP     A892 COL08      A8A5 COL09      
A8AD COL10      A8BA COL20      A8C3 COL21      A8F1 COL22      BCE0 COLL1      
BCE7 COLL2      BCC0 COLL3      0080 COLLSP     BCBD COLLZ      003A COLON      
00B5 COLONZ     A88E COLORZ     A967 COMB       B094 COMMA      B097 COMMA2     
002C COMMAT     00B3 COMMAZ     A3CD CONC06     A377 CONCAT     00B8 CONCZ      
A244 CONPI      0075 CONT       B20B CONTIN     A822 CONV1      00CD COSZ       
AB9D CPAR       ABA1 CPAR2      ABA9 CPAR3      0820 CRNBUF     B6F6 CRUI       
B711 CRUI16     B721 CRUO       B737 CRUO16     B746 CRUO8      B770 CRUSET     
B768 CRUTMP     B786 CSLOAD     0390 CSNTMP     03BA CSNTP1     0010 CSNUM      
B753 CSR        B75B CSV        B74B CSW        007E CURSOR     8334 DATA       
834D DATAAD     A7AB DATAST     0093 DATAZ      A7C6 DATST1     0081 DCHAR      
8354 DDD1       0089 DEFZ       8002 DELET      A198 DELETX     0099 DELETZ     
A747 DELINK     00E9 DIGITZ     008A DIMZ       B1C7 DIRSPH     B0F0 DIRSPK     
B8C7 DISLP      6A7C DISO       8000 DISPL1     A195 DISPLX     00A2 DISPLZ     
AF55 DIST       00C4 DIVIZ      0003 DLETE      0024 DOLLAR     000A DOWN       
000A DWNARR     007F EDGECH     8350 EEE        8358 EEE1       0081 ELSEZ      
008B ENDZ       8332 ENLN       6A80 ENT09      6A7E ENTER      801C EOF        
A177 EOFX       00BE EQUALZ     00EF ERASEZ     837C ERCODE     A7E8 ERORZ      
AC34 ERR10      ACDF ERRBA      A137 ERRBRK     ACD7 ERRBS      ACE3 ERRBV      
ACA4 ERRC05     8322 ERRCOD     AC9F ERRCOM     ACC7 ERRFNN     ACE7 ERRIAL     
038A ERRLN      ACDB ERRLNF     ACBB ERRMEM     ACB7 ERRMUV     ACC3 ERRNWF     
A5D6 ERROLP     00A5 ERRORZ     A0DD ERRRDY     ACCF ERRRSC     ACD3 ERRRWG     
ACEB ERRSNF     ACB3 ERRSNM     ACCB ERRSNS     ACBF ERRSO      B50D ERRSSL     
ACAF ERRSYN     ABEE ERRWXY     6A84 ERRZZ      A090 EXEC       A09D EXEC1      
A0B0 EXEC20     A11B EXEC6C     A11F EXEC6D     A10E EXECBK     0076 EXECG      
A0D3 EXECND     A0E1 EXECTR     00CE EXPZZ      832E EXTRAM     0046 F          
834B FAC1       8354 FAC10      8355 FAC11      8356 FAC12      8358 FAC14      
8359 FAC15      834C FAC2       834D FAC3       834E FAC4       8350 FAC6       
8351 FAC7       8352 FAC8       8353 FAC9       000A FCOMP      0009 FDIV       
834E FFF        8356 FFF1       00FA FIXEDZ     8345 FLAG       A332 FLT1       
0012 FLTINT     A998 FLTS       0008 FMUL       B316 FNDNUM     8317 FNUM       
0009 FORW       008C FORZ       B40C FOUND      8340 FREPTR     A024 GA024      
A0A2 GA0AE      A0A6 GA0B2      A0F6 GA102      A1AB GA1B7      A1B8 GA1C4      
A202 GA20E      A20A GA216      A219 GA225      A221 GA22D      A257 GA263      
A35F GA420      A36A GA42B      A39A GA45B      A47D GA53E      A4B9 GA57C      
A4E1 GA5A4      A4EB GA5AE      A586 GA649      A596 GA659      A5B6 GA679      
A60E GA6D1      A617 GA6DA      A63C GA6FF      A65D GA720      A678 GA73B      
A6D9 GA79C      A6DC GA79F      A71F GA7E2      A733 GA7F6      A739 GA7FC      
A770 GA833      A783 GA846      A787 GA84A      A789 GA84C      A793 GA856      
A7C4 GA887      A7D4 GA897      A7E2 GA8A5      A836 GA8F9      A9C4 GAA39      
A9D8 GAA4D      AB51 GABD1      AB84 GAC04      AB87 GAC07      ABF1 GAC99      
AC07 GACAF      AC12 GACBA      AC1D GACC5      AC26 GACCE      AC28 GACD0      
AC5B GAD03      AC63 GAD0B      AC96 GAD3E      AC9A GAD42      AE61 GAEBB      
AE85 GAEF6      AE8C GAEFD      AEAB GAF1C      AEAD GAF1E      AECC GAF3D      
AEE5 GAF56      AEFB GAF6C      AF58 GAFC4      AF79 GAFE5      B08D GB0DB      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0076 
RXB 2024
B093 GB0E1      B10E GB158      B126 GB170      B129 GB173      B134 GB17E      
B13E GB188      B14C GB196      B156 GB1A0      B15D GB1A7      B184 GB1CE      
B1B2 GB1FC      B1B4 GB1FE      B1F7 GB241      B20E GB258      B250 GB29C      
B25E GB2AA      B29F GB2EB      B2CA GB316      B2CC GB318      B2F0 GB33C      
B2FA GB346      B303 GB34F      B306 GB352      B324 GB370      B330 GB37C      
B33F GB38B      B34F GB39B      B360 GB3AC      B36D GB3B9      B378 GB3C4      
B379 GB3C5      B388 GB3D4      B391 GB3DD      B3A8 GB3F4      B3B8 GB404      
B3C1 GB40D      B3E4 GB430      B402 GB44E      B441 GB48D      B44C GB498      
B455 GB4A1      B474 GB4C0      B47A GB4C6      B485 GB4D1      B49C GB4E8      
A83A GCHAR1     A859 GCHAR2     A875 GCHAR3     A837 GCHARZ     E025 GE025      
A2CE GETNUM     B2D3 GETPRM     0071 GETSTR     B350 GETTIM     B9B3 GJOYST     
B987 GKEY1      B98E GKEY2      B9A2 GKEY3      83C2 GKFLG      B825 GMAGN      
B830 GMO1       B83F GMO2       B84B GMO3       B822 GMOT       A2D1 GNRTN      
0087 GOSUBZ     B94C GOTON0     0086 GOTOZ      0085 GOZ        AADC GPHVRC     
A223 GPLCAL     008C GREAD1     003E GREAT      00C0 GREATZ     0022 GRINT      
6034 GRSUB1     802C GRSUB2     802E GRSUB3     008B GVWITE     6036 GWSUB      
0074 HCHAR      AA71 HCHAR1     AA81 HCHAR2     AA6E HCHARZ     B5FE HEX        
B65E HEX00      B691 HEX01      B6A7 HEX02      B6B5 HEX03      B6C3 HEX04      
B6CA HEX05      B601 HEXAGN     B678 HEXDON     B64C HEXNS      B654 HEXNS2     
B67F HEXSTR     007A HGET       B7E0 HGETS      B7DD HGETZ      B799 HPOUT      
0077 HPUT       B793 HPUTS      B790 HPUTZ      AAC3 HVCHR      AACC HVCHR1     
AAD8 HVCHS      B803 HVGETS     B7C9 HVPUTN     AAA2 HVRC       002D HYPEN      
0084 IFZ        00A3 IMAGEZ     BBF0 INOALL     8006 INPUT      A189 INPUTX     
0092 INPUTZ     0004 INSRT      A906 INTARG     00F5 INTERZ     A281 INTRND     
00CF INTZ       BBD7 INVAGN     BBD4 INVERS     BBFE INVLP      BC0A INVNOK     
B6CE IOAGN      B761 IODONE     B89C J1         B89E J2         B8AA J3         
B9F2 JOYAGN     A92E JOYAV      A926 JOYNZ      B9B6 JOYRPT     B9D6 JOYSTS     
8377 JOYX       A91B JOYXY      8376 JOYY       AB4E KEY        AB65 KEY1B      
AB89 KEY1C      AB8D KEY2       AB8F KEY2A      8374 KEYBD      B8DB KEYJOY     
B8FB KEYSTR     ABD8 LDSCRN     A432 LEN01      A43A LEN02      8360 LENCST     
8362 LENWST     00D5 LENZ       003C LESS       00BF LESSZ      008D LETZ       
A810 LINE       A5E1 LINEGP     A026 LINK1      A030 LINK2      A03A LINK3      
A044 LINK4      A04E LINK5      A058 LINK6      A062 LINK7      A06B LINK8      
A073 LINK9      A07D LINKA      A088 LINKB      ACEF LINKS1     ACFA LINKS2     
AD08 LINKS3     AD15 LINKS4     AD1F LINKS5     AD2B LINKS6     AD36 LINKS7     
AD41 LINKS8     AD4D LINKS9     AD5A LINKSA     AD62 LINKSB     AD6C LINKSC     
AD78 LINKSD     AD82 LINKSE     AD8C LINKSF     AD95 LINKSG     AD9E LINKSH     
ADA7 LINKSI     ADB0 LINKSJ     ADBC LINKSK     ADC8 LINKSL     ADD0 LINKSM     
ADD7 LINKSN     ADE5 LINKSO     ADF3 LINKSP     ADFF LINKSQ     AE0C LINKSR     
AE1A LINKSS     AE29 LINKST     8030 LINPUT     A19B LINPUX     00AA LINPUZ     
0002 LISTZ      A33A LITS05     A36B LITS06     A343 LITS07     A345 LITS08     
A350 LITS09     8336 LNBUF      A5EB LNGP1      A5FF LNGP2      A623 LNGP2B     
A637 LNGP4      A886 LNKRT2     A882 LNKRTN     00C9 LNZ        B4A1 LOADAD     
0371 LODFLG     00D0 LOGZ       B3E5 LOOKUP     B1A1 LOOP1      B1E3 LOOPR      
AB92 LPARR      00B7 LPARZ      8348 LSUBP      A261 MAXMIN     00DF MAXZ       
0008 MERGEZ     002D MINUS      00C2 MINUSZ     00E0 MINZ       8302 MNUM       
B511 MOVES      B514 MOVESA     B53F MOVESB     B55A MOVESC     B5F7 MOVESD     
B557 MOVESN     B539 MOVESX     B56D MTYPE      B577 MTYPE0     B57F MTYPE1     
B58D MTYPE2     B59A MTYPE3     B5A4 MTYPE4     B5AD MTYPE5     B5BC MTYPE6     
B5CA MTYPE7     B5D4 MTYPE8     B5DC MTYPE9     B5EA MTYPEA     B565 MTYPES     
00C3 MULTZ      A5C8 NBREAK     B427 NEXT       B167 NEXT1      B17C NEXT2      
0096 NEXTZ      A2E6 NGOOD      A2E8 NGOOD1     0039 NINE       02E2 NLNADD     
A24C NMAX       A252 NMAXZ1     A259 NMIN       B873 NOALL      837A NOMSPR     
B3CA NOTIME     00BD NOTZ       A23C NPI        B0A7 NR         800E NREAD      
A180 NREADX     A287 NRND       A28D NRND1      A29B NRND2      A29D NRND3      
A2AA NRND4      A2AC NRND5      A324 NRNDCT     A315 NRNDMZ     A5BE NTRACE     
8328 NUDTAB     A13B NUDTB      B09F NULRTN     0023 NUMBER     00FD NUMBEZ     
0000 NUMBR      00C8 NUMCOZ     B3CE NUMERC     00E8 NUMERZ     A2BD NUMFCH     
A2C0 NUMSNM     A94E NUMVAR     00C8 NUMZ       A5DA NUNBRK     A5C3 NUNTRC     
B86B NXALL      B220 NXTPAR     B491 NXTPHR     0060 OFFSET     0005 OLDZ       
A20C ONBRK      0378 ONECHR     A1CE ONERR      A1E6 ONERR2     A1FA ONERR4     
B977 ONKEY1     B95A ONLP       A19E ONWARN     A1C3 ONWRN5     A1C5 ONWRN7     
009B ONZ        8008 OPEN       A18C OPENX      009F OPENZ      009E OPTIOZ     
00BA ORZ        00F7 OUTPUZ     AF75 OVER       8301 PAD1       8310 PAD10      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0077 
RXB 2024
8312 PAD12      8316 PAD16      8302 PAD2       8303 PAD3       8304 PAD4       
8306 PAD6       8307 PAD7       8308 PAD8       830A PADA       830B PADB       
0001 PARCOM     A4A4 PARFF      0074 PARSE      002E PERIOD     00FB PERMAZ     
0079 PGMCHR     832C PGMPTR     835D PHDATA     8300 PHLEN      8301 PHRADD     
B2E9 PHRASE     00DD PIZ        002B PLUS       00C1 PLUSZ      A4FA POS01      
A535 POS02      A543 POS04      A552 POS06      A554 POS08      A559 POS10      
A561 POS12      00D9 POSZ       B0AD PREPN      8344 PRGFLG     8004 PRINT      
A183 PRINTX     009C PRINTZ     83CE PRTNFN     835E PTCBED     830E PTCCIP     
8308 PTCCIS     8314 PTCCPH     8304 PTEBSL     8312 PTFBPH     8300 PTFBSL     
830C PTFCIP     8306 PTFCIS     B3A4 PTIME      8302 PTLBSL     834F PTLCIL     
8310 PTLCIP     830A PTLCIS     8316 PTLCPH     A36F PUSSTR     B7B0 PUTZ       
B7DC PUTZ1      0022 QUOTE      8389 RAMFLG     8386 RAMFRE     8384 RAMTOP     
ABAF RAN16      8378 RANDOM     0095 RANDOZ     0002 RANGE      B070 RANGEV     
8358 READ       B4D3 READAD     0097 READZ      8022 REC        0006 RECALL     
A17D RECX       00DE RECZ       00F4 RELATZ     009A REMZ       0006 RESEQZ     
800C RESTOR     A186 RESTOX     0094 RESTOZ     0088 RETURZ     AAD9 RGPHV      
8375 RKEY       B85C RMAGN      B882 RMALL      B859 RMOT       B88A RMOTLP     
B2B3 RNDAG      A326 RNDM1      00D7 RNDZ       00B6 RPARZ      A565 RPTZ01     
A5A4 RPTZ02     00E1 RPTZZ      B909 RSCAN      B912 RSCAN0     B915 RSCAN1     
B919 RSCAN2     B92F RSCAN3     B930 RSCAN4     B935 RSCAN5     0082 RTNB       
8326 RTNG       A4F6 RTNSET     00A9 RUNZ       B6CB RXBIO      BCB6 S00T10     
BCAF S1ET9F     0388 SAVEVP     0007 SAVEZ      B0C0 SAY        0384 SBUFLV     
BC47 SCOL10     BC77 SCOL20     0083 SCROLL     ABCD SCRON      B40D SEARCH     
A3CF SEGZ01     A413 SEGZ06     A42E SEGZ08     00D8 SEGZZ      003B SEMICO     
00B4 SEMICZ     00F6 SEQUEZ     B2E5 SETCB      B506 SETRW      BD13 SETSND     
0386 SEXTRM     0398 SFLAG      00D1 SGNZZ      00D2 SINZ       00EB SIZEZ      
0396 SLSUBP     007B SMB        AA4A SND05      A30A SNDASS     A301 SNDER      
A9A0 SNDREG     B6EC SOG        A9E2 SOUND1     AA2A SOUND2     AA11 SOUND3     
AA48 SOUND5     AA59 SOUND6     B6F1 SOV        0020 SPACE      BA51 SPAR       
BA5B SPAR1      BA73 SPAR2      B03C SPCHR      A8FA SPCOL      0084 SPDEL      
AE69 SPDEL1     AE7E SPDEL2     B181 SPEAK      007E SPEED      B217 SPGET      
0382 SPGMPT     B9FF SPGS       BA2C SPGS1      BA37 SPGS2      BA43 SPGS3      
BA4C SPGS4      BA19 SPGSA      BA4E SPGSE      8369 SPKSTS     834B SPLFLG     
B01F SPLOC      B022 SPLOC2     B04E SPMOVE     B06F SPMOVF     03AA SPNUM      
B006 SPNUM2     B00D SPNUM3     B012 SPNUM4     B018 SPNUM5     B008 SPNUM6     
AECF SPRCOI     AE66 SPRDEL     6016 SPRINT     AF34 SPRLC2     AF31 SPRLOC     
AF04 SPRMAG     AF07 SPRMLP     AF21 SPRMOV     AF24 SPRMV2     AF27 SPRMV3     
AF2A SPRMV4     AE91 SPRP02     AEC2 SPRP03     AF45 SPRPAT     AE8E SPRPOS     
AF48 SPRPT2     0300 SPRSAL     AE3B SPRT3      AE50 SPRT4      AE35 SPRTE      
07FF SPRVB      0083 SPSPD5     00D3 SQRZ       A984 SQU05      A96D SQUISH     
8020 SRDATA     831C SREF       BCA4 SSDSLL     0082 SSEPZ      000C SSUB       
830A STADDR     0372 START      B4EB STDATA     00B2 STEPZ      8330 STLN       
0098 STOPZ      A2AE STRFCH     A2B4 STRGET     00C7 STRINZ     8364 STRLEN     
A2B0 STRPAR     8312 STRPTR     0065 STRVAL     A46A STRZ01     00DB STRZZ      
8324 STVSPT     A2D7 SUBLP3     A2DE SUBLP4     00A8 SUBNDZ     00A7 SUBXTZ     
00A1 SUBZ       BC14 SWCHAG     BC11 SWCHR      BC43 SWCLR      007A SYM        
0376 SYMBOL     833E SYMTAB     0000 SYNCHK     63A5 SZNEW      601E SZRUN      
A17A SZRUNX     00FC TABZ       00D4 TANZ       8354 TEMP1      8356 TEMP2      
8364 TEMP4      8366 TEMP5      8368 TEMP6      00B0 THENZ      8379 TIMER      
B340 TIMING     8351 TIMLEN     63DD TOPL15     6372 TOPLEV     8310 TOPSTK     
834C TOTTIM     00B1 TOZ        0090 TRACEZ     0083 TREMZ      B3E7 TRYAGN     
00EA UALPHZ     A639 UBSUB      A649 UBSUB1     A654 UDF        A634 UNBK01     
008F UNBREZ     00C8 UNQSTZ     0091 UNTRAZ     000B UPARR      00F8 UPDATZ     
000B UPMV       00ED USINGZ     B7F3 VAGAIN     00DA VAL        A494 VAL01      
A4AE VALCD      00FE VALIDZ     830E VAR4       8310 VAR5       8311 VAR6       
8312 VAR7       8314 VAR9       00F3 VARIAZ     8320 VARW       8304 VARY       
8306 VARY2      0075 VCHAR      AA8B VCHAR1     AA9B VCHAR2     AA88 VCHARZ     
83D4 VDPR1      837B VDPSTT     007B VGET       B7F0 VGETZ      0078 VPOP       
B7A9 VPOUT      0077 VPUSH      0078 VPUT       B7A3 VPUTS      B7A0 VPUTZ      
0379 VRMSND     03C0 VROAZ      001C VWIDTH     B4FB WAIT       A0C8 WARNGZ     
00A6 WARNZ      6A82 WARNZZ     835A WRITE      A62E WRNLNF     A0CD WRNN01     
A82E WRNNO      A396 WRNST1     A57E WRNST2     0003 X2         0073 XBCNS      
8316 XFLAG      A5C1 XMLCON     00BC XORZ       A9A9 XSOUND     B8C4 ZDIST      
0030 ZERO       BAFC ZJOKG      BB32 ZJOLO      BB5E ZJOLO1     BB67 ZJOLO2     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0078 
RXB 2024
BB70 ZJOLO3     BB79 ZJOLO4     BB82 ZJOLO5     BB8E ZJOLO6     BB9A ZJOLO7     
BBA6 ZJOLO8     BBB2 ZJOLO9     BA78 ZJOMO      BA9D ZJOMO1     BAA7 ZJOMO2     
BAB1 ZJOMO3     BABB ZJOMO4     BAC5 ZJOMO5     BACF ZJOMO6     BAD9 ZJOMO7     
BAE3 ZJOMO8     BAED ZJOMO9     BB2F ZJOMOR     B9EF ZJOYST     B8D1 ZKEY       
B93C ZONKEY     B8B5 ZSCOI      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0079 
RXB 2024
Symbol Table #2 (New,value)  
0000 NUMBR      0000 SYNCHK     0001 PARCOM     0002 BREAK      0002 LISTZ      
0002 RANGE      0003 DLETE      0003 X2         0004 INSRT      0005 OLDZ       
0006 RECALL     0006 RESEQZ     0007 CLRLN      0007 SAVEZ      0008 BACK       
0008 FMUL       0008 MERGEZ     0009 FDIV       0009 FORW       000A DOWN       
000A DWNARR     000A FCOMP      000B UPARR      000B UPMV       000C SSUB       
000D CHRTN      0010 CSNUM      0012 CFI        0012 FLTINT     001C VWIDTH     
0020 BKGD       0020 SPACE      0022 GRINT      0022 QUOTE      0023 NUMBER     
0024 DOLLAR     002B PLUS       002C COMMAT     002D HYPEN      002D MINUS      
002E PERIOD     0030 ZERO       0039 NINE       003A COLON      003B SEMICO     
003C LESS       003E GREAT      0041 A          0046 F          0060 OFFSET     
0065 STRVAL     0071 GETSTR     0073 XBCNS      0074 HCHAR      0074 PARSE      
0075 CONT       0075 VCHAR      0076 ASCHEX     0076 EXECG      0077 HPUT       
0077 VPUSH      0078 VPOP       0078 VPUT       0079 CLEARP     0079 PGMCHR     
007A HGET       007A SYM        007B SMB        007B VGET       007C ASSGNV     
007D CHAR       007E CURSOR     007E SPEED      007F CHRLDR     007F EDGECH     
0080 CIF        0080 COLLSP     0081 DCHAR      0081 ELSEZ      0082 RTNB       
0082 SSEPZ      0083 SCROLL     0083 SPSPD5     0083 TREMZ      0084 IFZ        
0084 SPDEL      0085 GOZ        0086 GOTOZ      0087 GOSUBZ     0088 RETURZ     
0089 DEFZ       008A DIMZ       008B ENDZ       008B GVWITE     008C FORZ       
008C GREAD1     008D LETZ       008E BREAKZ     008F UNBREZ     0090 TRACEZ     
0091 UNTRAZ     0092 INPUTZ     0093 DATAZ      0094 RESTOZ     0095 RANDOZ     
0096 NEXTZ      0097 READZ      0098 STOPZ      0099 DELETZ     009A REMZ       
009B ONZ        009C PRINTZ     009D CALLZ      009E OPTIOZ     009F OPENZ      
00A0 CLOSEZ     00A1 SUBZ       00A2 DISPLZ     00A3 IMAGEZ     00A4 ACCEPZ     
00A5 ERRORZ     00A6 WARNZ      00A7 SUBXTZ     00A8 SUBNDZ     00A9 RUNZ       
00AA LINPUZ     00B0 THENZ      00B1 TOZ        00B2 STEPZ      00B3 COMMAZ     
00B4 SEMICZ     00B5 COLONZ     00B6 RPARZ      00B7 LPARZ      00B8 CONCZ      
00BA ORZ        00BB ANDZ       00BC XORZ       00BD NOTZ       00BE EQUALZ     
00BF LESSZ      00C0 GREATZ     00C1 PLUSZ      00C2 MINUSZ     00C3 MULTZ      
00C4 DIVIZ      00C5 CIRCUZ     00C7 STRINZ     00C8 NUMCOZ     00C8 NUMZ       
00C8 UNQSTZ     00C9 LNZ        00CB ABSZ       00CC ATNZ       00CD COSZ       
00CE EXPZZ      00CF INTZ       00D0 LOGZ       00D1 SGNZZ      00D2 SINZ       
00D3 SQRZ       00D4 TANZ       00D5 LENZ       00D6 CHRZZ      00D7 RNDZ       
00D8 SEGZZ      00D9 POSZ       00DA VAL        00DB STRZZ      00DC ASCZ       
00DD PIZ        00DE RECZ       00DF MAXZ       00E0 MINZ       00E1 RPTZZ      
00E8 NUMERZ     00E9 DIGITZ     00EA UALPHZ     00EB SIZEZ      00EC ALLZ       
00ED USINGZ     00EE BEEPZ      00EF ERASEZ     00F0 ATZ        00F1 BASEZ      
00F3 VARIAZ     00F4 RELATZ     00F5 INTERZ     00F6 SEQUEZ     00F7 OUTPUZ     
00F8 UPDATZ     00F9 APPENZ     00FA FIXEDZ     00FB PERMAZ     00FC TABZ       
00FD NUMBEZ     00FE VALIDZ     02E2 NLNADD     0300 SPRSAL     0371 LODFLG     
0372 START      0376 SYMBOL     0378 ONECHR     0379 VRMSND     0382 SPGMPT     
0384 SBUFLV     0386 SEXTRM     0388 SAVEVP     038A ERRLN      0390 CSNTMP     
0396 SLSUBP     0398 SFLAG      03AA SPNUM      03BA CSNTP1     03C0 VROAZ      
07FF SPRVB      0820 CRNBUF     6016 SPRINT     6018 CHRTBL     601C CHRTAB     
601E SZRUN      6034 GRSUB1     6036 GWSUB      6372 TOPLEV     63A5 SZNEW      
63DD TOPL15     6A78 CHKEND     6A7C DISO       6A7E ENTER      6A80 ENT09      
6A82 WARNZZ     6A84 ERRZZ      8000 DISPL1     8002 DELET      8004 PRINT      
8006 INPUT      8008 OPEN       800A CLOSE      800C RESTOR     800E NREAD      
8012 CLSALL     801C EOF        801E ACCEPT     8020 SRDATA     8022 REC        
802C GRSUB2     802E GRSUB3     8030 LINPUT     8300 PHLEN      8300 PTFBSL     
8301 PAD1       8301 PHRADD     8302 ACCUM      8302 MNUM       8302 PAD2       
8302 PTLBSL     8303 PAD3       8304 PAD4       8304 PTEBSL     8304 VARY       
8306 CCPPTR     8306 PAD6       8306 PTFCIS     8306 VARY2      8307 PAD7       
8308 PAD8       8308 PTCCIS     830A PADA       830A PTLCIS     830A STADDR     
830B PADB       830C BYTES      830C PTFCIP     830E PTCCIP     830E VAR4       
8310 PAD10      8310 PTLCIP     8310 TOPSTK     8310 VAR5       8311 VAR6       
8312 PAD12      8312 PTFBPH     8312 STRPTR     8312 VAR7       8314 PTCCPH     
8314 VAR9       8316 PAD16      8316 PTLCPH     8316 XFLAG      8317 FNUM       
831C SREF       8320 VARW       8322 ERRCOD     8324 STVSPT     8326 RTNG       
8328 NUDTAB     832C PGMPTR     832E EXTRAM     8330 STLN       8332 ENLN       
8334 DATA       8336 LNBUF      833E SYMTAB     8340 FREPTR     8342 CHAT       
8344 PRGFLG     8345 FLAG       8346 BUFLEV     8348 LSUBP      834A CCHAR      
834B FAC1       834B SPLFLG     834C FAC2       834C TOTTIM     834D DATAAD     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0080 
RXB 2024
834D FAC3       834E CCC        834E FAC4       834E FFF        834F PTLCIL     
8350 EEE        8350 FAC6       8351 FAC7       8351 TIMLEN     8352 FAC8       
8353 FAC9       8354 DDD1       8354 FAC10      8354 TEMP1      8355 FAC11      
8356 FAC12      8356 FFF1       8356 TEMP2      8358 EEE1       8358 FAC14      
8358 READ       8359 FAC15      835A WRITE      835D ARG1       835D PHDATA     
835E ARG2       835E PTCBED     8360 ARG4       8360 LENCST     8362 ARG6       
8362 LENWST     8363 ARG7       8364 ARG8       8364 STRLEN     8364 TEMP4      
8366 BYTE1      8366 TEMP5      8367 BYTE2      8368 BYTE3      8368 TEMP6      
8369 SPKSTS     8374 KEYBD      8375 RKEY       8376 JOYY       8377 JOYX       
8378 RANDOM     8379 TIMER      837A NOMSPR     837B VDPSTT     837C ERCODE     
837D CB         8384 RAMTOP     8386 RAMFRE     8389 RAMFLG     83C2 GKFLG      
83CE PRTNFN     83D4 VDPR1      A024 GA024      A026 LINK1      A030 LINK2      
A03A LINK3      A044 LINK4      A04E LINK5      A058 LINK6      A062 LINK7      
A06B LINK8      A073 LINK9      A07D LINKA      A088 LINKB      A090 EXEC       
A09D EXEC1      A0A2 GA0AE      A0A6 GA0B2      A0B0 EXEC20     A0C8 WARNGZ     
A0CD WRNN01     A0D3 EXECND     A0DD ERRRDY     A0E1 EXECTR     A0F6 GA102      
A10A CLRRTN     A10E EXECBK     A11B EXEC6C     A11F EXEC6D     A137 ERRBRK     
A13B NUDTB      A177 EOFX       A17A SZRUNX     A17D RECX       A180 NREADX     
A183 PRINTX     A186 RESTOX     A189 INPUTX     A18C OPENX      A18F CLOSEX     
A192 ACCEPX     A195 DISPLX     A198 DELETX     A19B LINPUX     A19E ONWARN     
A1AB GA1B7      A1B8 GA1C4      A1C3 ONWRN5     A1C5 ONWRN7     A1CE ONERR      
A1E6 ONERR2     A1FA ONERR4     A202 GA20E      A20A GA216      A20C ONBRK      
A219 GA225      A221 GA22D      A223 GPLCAL     A23C NPI        A244 CONPI      
A24C NMAX       A252 NMAXZ1     A257 GA263      A259 NMIN       A261 MAXMIN     
A281 INTRND     A287 NRND       A28D NRND1      A29B NRND2      A29D NRND3      
A2AA NRND4      A2AC NRND5      A2AE STRFCH     A2B0 STRPAR     A2B4 STRGET     
A2BD NUMFCH     A2C0 NUMSNM     A2C6 CFIFCH     A2CE GETNUM     A2D1 GNRTN      
A2D7 SUBLP3     A2DE SUBLP4     A2E6 NGOOD      A2E8 NGOOD1     A301 SNDER      
A308 CIFSND     A30A SNDASS     A30D CLRFAC     A315 NRNDMZ     A324 NRNDCT     
A326 RNDM1      A32C CKSTNM     A332 FLT1       A33A LITS05     A343 LITS07     
A345 LITS08     A350 LITS09     A35F GA420      A36A GA42B      A36B LITS06     
A36F PUSSTR     A377 CONCAT     A396 WRNST1     A39A GA45B      A3CD CONC06     
A3CF SEGZ01     A413 SEGZ06     A42E SEGZ08     A432 LEN01      A43A LEN02      
A43E CHRZ01     A459 ASC01      A46A STRZ01     A47D GA53E      A494 VAL01      
A4A4 PARFF      A4AE VALCD      A4B9 GA57C      A4E1 GA5A4      A4EB GA5AE      
A4F6 RTNSET     A4FA POS01      A535 POS02      A543 POS04      A552 POS06      
A554 POS08      A559 POS10      A561 POS12      A565 RPTZ01     A57E WRNST2     
A586 GA649      A596 GA659      A5A4 RPTZ02     A5B6 GA679      A5BE NTRACE     
A5C1 XMLCON     A5C3 NUNTRC     A5C8 NBREAK     A5D6 ERROLP     A5DA NUNBRK     
A5E1 LINEGP     A5EB LNGP1      A5FF LNGP2      A60E GA6D1      A617 GA6DA      
A623 LNGP2B     A62E WRNLNF     A634 UNBK01     A637 LNGP4      A639 UBSUB      
A63C GA6FF      A649 UBSUB1     A654 UDF        A65D GA720      A678 GA73B      
A6D9 GA79C      A6DC GA79F      A71F GA7E2      A733 GA7F6      A739 GA7FC      
A747 DELINK     A770 GA833      A783 GA846      A787 GA84A      A789 GA84C      
A793 GA856      A798 ATTNUT     A7AB DATAST     A7C4 GA887      A7C6 DATST1     
A7C7 ASC        A7D4 GA897      A7E2 GA8A5      A7E8 ERORZ      A810 LINE       
A822 CONV1      A82E WRNNO      A836 GA8F9      A837 GCHARZ     A83A GCHAR1     
A859 GCHAR2     A875 GCHAR3     A882 LNKRTN     A886 LNKRT2     A88E COLORZ     
A892 COL08      A8A5 COL09      A8AD COL10      A8BA COL20      A8C3 COL21      
A8F1 COL22      A8FA SPCOL      A906 INTARG     A91B JOYXY      A926 JOYNZ      
A92E JOYAV      A94E NUMVAR     A95B ATTREG     A967 COMB       A96D SQUISH     
A984 SQU05      A989 CLEARZ     A990 CLRPZ      A998 FLTS       A9A0 SNDREG     
A9A9 XSOUND     A9C4 GAA39      A9D8 GAA4D      A9E2 SOUND1     AA11 SOUND3     
AA2A SOUND2     AA48 SOUND5     AA4A SND05      AA59 SOUND6     AA6E HCHARZ     
AA71 HCHAR1     AA81 HCHAR2     AA88 VCHARZ     AA8B VCHAR1     AA9B VCHAR2     
AAA2 HVRC       AAC3 HVCHR      AACC HVCHR1     AAD8 HVCHS      AAD9 RGPHV      
AADC GPHVRC     AAFA CHARLY     AAFD CHAR5      AB13 CHAR2      AB1F CHAR1      
AB22 CHARLD     AB36 CHRFIL     AB47 CHARL4     AB4E KEY        AB51 GABD1      
AB65 KEY1B      AB84 GAC04      AB87 GAC07      AB89 KEY1C      AB8D KEY2       
AB8F KEY2A      AB92 LPARR      AB9D CPAR       ABA1 CPAR2      ABA9 CPAR3      
ABAF RAN16      ABB8 BORDER     ABBD BORAGN     ABCD SCRON      ABD8 LDSCRN     
ABE0 BORDES     ABE7 BORCRN     ABEE ERRWXY     ABF1 GAC99      AC07 GACAF      
AC12 GACBA      AC1D GACC5      AC26 GACCE      AC28 GACD0      AC34 ERR10      
AC5B GAD03      AC63 GAD0B      AC96 GAD3E      AC9A GAD42      AC9F ERRCOM     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0081 
RXB 2024
ACA4 ERRC05     ACAF ERRSYN     ACB3 ERRSNM     ACB7 ERRMUV     ACBB ERRMEM     
ACBF ERRSO      ACC3 ERRNWF     ACC7 ERRFNN     ACCB ERRSNS     ACCF ERRRSC     
ACD3 ERRRWG     ACD7 ERRBS      ACDB ERRLNF     ACDF ERRBA      ACE3 ERRBV      
ACE7 ERRIAL     ACEB ERRSNF     ACEF LINKS1     ACFA LINKS2     AD08 LINKS3     
AD15 LINKS4     AD1F LINKS5     AD2B LINKS6     AD36 LINKS7     AD41 LINKS8     
AD4D LINKS9     AD5A LINKSA     AD62 LINKSB     AD6C LINKSC     AD78 LINKSD     
AD82 LINKSE     AD8C LINKSF     AD95 LINKSG     AD9E LINKSH     ADA7 LINKSI     
ADB0 LINKSJ     ADBC LINKSK     ADC8 LINKSL     ADD0 LINKSM     ADD7 LINKSN     
ADE5 LINKSO     ADF3 LINKSP     ADFF LINKSQ     AE0C LINKSR     AE1A LINKSS     
AE29 LINKST     AE35 SPRTE      AE3B SPRT3      AE50 SPRT4      AE61 GAEBB      
AE66 SPRDEL     AE69 SPDEL1     AE7E SPDEL2     AE85 GAEF6      AE8C GAEFD      
AE8E SPRPOS     AE91 SPRP02     AEAB GAF1C      AEAD GAF1E      AEC2 SPRP03     
AECC GAF3D      AECF SPRCOI     AEE5 GAF56      AEFB GAF6C      AF04 SPRMAG     
AF07 SPRMLP     AF21 SPRMOV     AF24 SPRMV2     AF27 SPRMV3     AF2A SPRMV4     
AF31 SPRLOC     AF34 SPRLC2     AF45 SPRPAT     AF48 SPRPT2     AF55 DIST       
AF58 GAFC4      AF75 OVER       AF79 GAFE5      AF7D CODIST     AFA5 CODIS1     
AFAB CODIS2     AFBD CHRSET     AFD9 CHRALL     B006 SPNUM2     B008 SPNUM6     
B00D SPNUM3     B012 SPNUM4     B018 SPNUM5     B01F SPLOC      B022 SPLOC2     
B03C SPCHR      B04E SPMOVE     B06F SPMOVF     B070 RANGEV     B08D GB0DB      
B093 GB0E1      B094 COMMA      B097 COMMA2     B09F NULRTN     B0A2 ASSRTN     
B0A7 NR         B0AA AR         B0AD PREPN      B0C0 SAY        B0F0 DIRSPK     
B10E GB158      B126 GB170      B129 GB173      B134 GB17E      B13E GB188      
B14C GB196      B156 GB1A0      B15D GB1A7      B167 NEXT1      B17C NEXT2      
B181 SPEAK      B184 GB1CE      B1A1 LOOP1      B1B2 GB1FC      B1B4 GB1FE      
B1C7 DIRSPH     B1E3 LOOPR      B1F7 GB241      B20B CONTIN     B20E GB258      
B217 SPGET      B220 NXTPAR     B250 GB29C      B25E GB2AA      B29F GB2EB      
B2B3 RNDAG      B2CA GB316      B2CC GB318      B2D3 GETPRM     B2E5 SETCB      
B2E9 PHRASE     B2F0 GB33C      B2FA GB346      B303 GB34F      B306 GB352      
B316 FNDNUM     B324 GB370      B330 GB37C      B33F GB38B      B340 TIMING     
B34F GB39B      B350 GETTIM     B360 GB3AC      B36D GB3B9      B378 GB3C4      
B379 GB3C5      B388 GB3D4      B391 GB3DD      B3A4 PTIME      B3A8 GB3F4      
B3B8 GB404      B3C1 GB40D      B3CA NOTIME     B3CE NUMERC     B3E4 GB430      
B3E5 LOOKUP     B3E7 TRYAGN     B402 GB44E      B40C FOUND      B40D SEARCH     
B427 NEXT       B441 GB48D      B44C GB498      B455 GB4A1      B474 GB4C0      
B47A GB4C6      B485 GB4D1      B491 NXTPHR     B49C GB4E8      B4A1 LOADAD     
B4D3 READAD     B4EB STDATA     B4FB WAIT       B506 SETRW      B50D ERRSSL     
B511 MOVES      B514 MOVESA     B539 MOVESX     B53F MOVESB     B557 MOVESN     
B55A MOVESC     B565 MTYPES     B56D MTYPE      B577 MTYPE0     B57F MTYPE1     
B58D MTYPE2     B59A MTYPE3     B5A4 MTYPE4     B5AD MTYPE5     B5BC MTYPE6     
B5CA MTYPE7     B5D4 MTYPE8     B5DC MTYPE9     B5EA MTYPEA     B5F7 MOVESD     
B5FE HEX        B601 HEXAGN     B64C HEXNS      B654 HEXNS2     B65E HEX00      
B678 HEXDON     B67F HEXSTR     B691 HEX01      B6A7 HEX02      B6B5 HEX03      
B6C3 HEX04      B6CA HEX05      B6CB RXBIO      B6CE IOAGN      B6EC SOG        
B6F1 SOV        B6F6 CRUI       B711 CRUI16     B721 CRUO       B737 CRUO16     
B746 CRUO8      B74B CSW        B753 CSR        B75B CSV        B761 IODONE     
B768 CRUTMP     B770 CRUSET     B786 CSLOAD     B790 HPUTZ      B793 HPUTS      
B799 HPOUT      B7A0 VPUTZ      B7A3 VPUTS      B7A9 VPOUT      B7B0 PUTZ       
B7C9 HVPUTN     B7DC PUTZ1      B7DD HGETZ      B7E0 HGETS      B7F0 VGETZ      
B7F3 VAGAIN     B803 HVGETS     B822 GMOT       B825 GMAGN      B830 GMO1       
B83F GMO2       B84B GMO3       B859 RMOT       B85C RMAGN      B86B NXALL      
B873 NOALL      B882 RMALL      B88A RMOTLP     B89C J1         B89E J2         
B8AA J3         B8B5 ZSCOI      B8B8 COINLP     B8C4 ZDIST      B8C7 DISLP      
B8D1 ZKEY       B8DB KEYJOY     B8FB KEYSTR     B909 RSCAN      B912 RSCAN0     
B915 RSCAN1     B919 RSCAN2     B92F RSCAN3     B930 RSCAN4     B935 RSCAN5     
B93C ZONKEY     B94C GOTON0     B95A ONLP       B977 ONKEY1     B987 GKEY1      
B98E GKEY2      B9A2 GKEY3      B9B3 GJOYST     B9B6 JOYRPT     B9D6 JOYSTS     
B9EF ZJOYST     B9F2 JOYAGN     B9FF SPGS       BA19 SPGSA      BA2C SPGS1      
BA37 SPGS2      BA43 SPGS3      BA4C SPGS4      BA4E SPGSE      BA51 SPAR       
BA5B SPAR1      BA73 SPAR2      BA78 ZJOMO      BA9D ZJOMO1     BAA7 ZJOMO2     
BAB1 ZJOMO3     BABB ZJOMO4     BAC5 ZJOMO5     BACF ZJOMO6     BAD9 ZJOMO7     
BAE3 ZJOMO8     BAED ZJOMO9     BAFC ZJOKG      BB2F ZJOMOR     BB32 ZJOLO      
BB5E ZJOLO1     BB67 ZJOLO2     BB70 ZJOLO3     BB79 ZJOLO4     BB82 ZJOLO5     
BB8E ZJOLO6     BB9A ZJOLO7     BBA6 ZJOLO8     BBB2 ZJOLO9     BBD4 INVERS     
BBD7 INVAGN     BBF0 INOALL     BBFE INVLP      BC0A INVNOK     BC11 SWCHR      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0082 
RXB 2024
BC14 SWCHAG     BC43 SWCLR      BC47 SCOL10     BC77 SCOL20     BCA4 SSDSLL     
BCAF S1ET9F     BCB6 S00T10     BCBD COLLZ      BCC0 COLL3      BCE0 COLL1      
BCE7 COLL2      BD13 SETSND     BD20 CASCII     BD32 BIT1D      BD38 BIT2       
BD4E BIT2D      BD54 BIT3       BD67 BIT3D      BD6D BIT4       BD83 BIT4D      
BD89 BITDI      E025 GE025      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0083 
RXB 2024
Symbol Table #4 (Def,alpha)  
0034 ACCTON     835C ARG        0032 ATN        0036 BADTON     003B BITREV     
0012 CFI        0014 CNS        002C COS        0010 CSN        8372 DATSTK     
0001 DIVZER     0003 ERRIOV     0006 ERRLOG     0005 ERRNIP     0002 ERRSNN     
0004 ERRSQR     0028 EXP        834A FAC        0006 FADD       000A FCOMP      
0009 FDIV       0008 FMUL       836C FPERAD     0007 FSUB       0038 GETSPACE   
0022 INT        0010 LINK       0018 LOCASE     002A LOG        8370 MEMSIZ     
003D NAMLNK     8300 PAD        0024 PWR        0012 RETURN     000B SADD       
000F SCOMP      000E SDIV       8375 SGN        002E SIN        000D SMUL       
8400 SOUND      0026 SQR        000C SSUB       837C STATUS     0016 STCASE     
8373 SUBSTK     0030 TAN        0007 TRIGER     004A UPCASE     836E VSPTR      
0001 WRNOV      837F XPT        837E YPT        

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0084 
RXB 2024
Symbol Table #8 (Def,value)  
0001 DIVZER     0001 WRNOV      0002 ERRSNN     0003 ERRIOV     0004 ERRSQR     
0005 ERRNIP     0006 ERRLOG     0006 FADD       0007 FSUB       0007 TRIGER     
0008 FMUL       0009 FDIV       000A FCOMP      000B SADD       000C SSUB       
000D SMUL       000E SDIV       000F SCOMP      0010 CSN        0010 LINK       
0012 CFI        0012 RETURN     0014 CNS        0016 STCASE     0018 LOCASE     
0022 INT        0024 PWR        0026 SQR        0028 EXP        002A LOG        
002C COS        002E SIN        0030 TAN        0032 ATN        0034 ACCTON     
0036 BADTON     0038 GETSPACE   003B BITREV     003D NAMLNK     004A UPCASE     
8300 PAD        834A FAC        835C ARG        836C FPERAD     836E VSPTR      
8370 MEMSIZ     8372 DATSTK     8373 SUBSTK     8375 SGN        837C STATUS     
