99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0001 
Version 2.0 (Weiand 1985)     Options : LCSFPF                                  
[0001]               ***********************************************************
[0002]                      TITL 'RXB 2024'
[0003]               ***********************************************************
[0004]                      GROM >A000
[0005]               ***********************************************************
[0006]               *           GROM ADDRESSES
[0007]               ***********************************************************
[0008]               *    EQUATES FOR ROUTINES FROM OTHER GROM SECTIONS
[0009]               * GROM >0000
[0010]               * LINK    EQU  >0010          GPLDSRLNK
[0011]               * RETURN  EQU  >0012          Return to GPL inderpeter
[0012]               * STCASE  EQU  >0016          Standard Case
[0013] 0022          GRINT  EQU  >0022             Greatest integer
[0014]               * ACCTON  EQU  >0034          ACCEPT TONE
[0015]               * BADTON  EQU  >0036          HONK TONE
[0016]               * UPCASE  EQU  >004A          Upper Case  
[0017]               * GROM >6000 EQUATES
[0018] 6016          SPRINT EQU  >6016             Initialize sprites
[0019] 6018          CHRTBL EQU  >6018             RXB CALL CHRTBL load char set
[0020] 601C          CHRTAB EQU  >601C             Load default character set
[0021] 601E          SZRUN  EQU  >601E
[0022] 6034          GRSUB1 EQU  >6034             Read data (2 bytes) from ERAM
[0023] 6036          GWSUB  EQU  >6036             Write a few bytes of data to
[0024] 6372          TOPLEV EQU  >6372             RXB CALL USER branch
[0025] 6A78          CHKEND EQU  >6A78             Check end of statement
[0026] 6A7C          DISO   EQU  >6A7C
[0027] 6A7E          ENTER  EQU  >6A7E
[0028] 6A80          ENT09  EQU  >6A80
[0029] 6A82          WARNZZ EQU  >6A82             WARNING MESSAGE ROUTINE
[0030] 6A84          ERRZZ  EQU  >6A84             ERROR MESSAGE ROUTINE
[0031] 63A5          SZNEW  EQU  >63A5             RXB CALL NEW branch
[0032] 63DD          TOPL15 EQU  >63DD             RXB CALL USER branch
[0033]               * GROM >8000
[0034] 8000          DISPL1 EQU  >8000
[0035] 8002          DELET  EQU  >8002
[0036] 8004          PRINT  EQU  >8004
[0037] 8006          INPUT  EQU  >8006
[0038] 8008          OPEN   EQU  >8008
[0039] 800A          CLOSE  EQU  >800A
[0040] 800C          RESTOR EQU  >800C
[0041] 800E          NREAD  EQU  >800E
[0042] 8012          CLSALL EQU  >8012             RXB branch
[0043] 801C          EOF    EQU  >801C
[0044] 801E          ACCEPT EQU  >801E
[0045] 8020          SRDATA EQU  >8020
[0046] 8022          REC    EQU  >8022
[0047] 802C          GRSUB2 EQU  >802C
[0048] 802E          GRSUB3 EQU  >802E
[0049] 8030          LINPUT EQU  >8030
[0050]               * CHARS  EQU  >9CEA             RXB Character Definitions
[0051]               * GROM >E000
[0052] E025          GE025  EQU  >E025             RXB branch EA module
[0053]               ***********************************************************
[0054]               *    Equates for XMLs
[0055] 0000          SYNCHK EQU  >00               SYNCHK XML selector
[0056] 0001          PARCOM EQU  >01               PARse to a COMma selector
[0057] 0002          RANGE  EQU  >02               RANGE selector
[0058]               * FADD   EQU  >06               Floating ADD *RXB RND*
[0059] 0008          FMUL   EQU  >08               Floating MULtiply
[0060] 0009          FDIV   EQU  >09               Floating DIVide
[0061] 000A          FCOMP  EQU  >0A               Floating COMPare
[0062]               * SADD   EQU  >0B               Stack ADD *RXB RND*
[0063] 000C          SSUB   EQU  >0C               Stack SUBtract
[0064] 0010          CSNUM  EQU  >10               Convert String to Number
[0065] 0012          CFI    EQU  >12               Convert to two byte integer

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0002 
RXB 2024
[0066] 0012          FLTINT EQU  >12               Convert floating to integer
[0067] 0071          GETSTR EQU  >71               SYSTEM GET STRING
[0068] 0073          XBCNS  EQU  >73               Convert number to string
[0069] 0074          PARSE  EQU  >74               Parse a value
[0070] 0075          CONT   EQU  >75               Continue parsing
[0071] 0076          EXECG  EQU  >76               Execute a XB stmt or program
[0072] 0077          VPUSH  EQU  >77               Push on value stack
[0073] 0078          VPOP   EQU  >78               Pop off value stack
[0074] 0079          PGMCHR EQU  >79               GET PROGRAM CHARACTER
[0075] 007A          SYM    EQU  >7A               Find SYMBOL entry
[0076] 007B          SMB    EQU  >7B               Find symbol table entry
[0077] 007C          ASSGNV EQU  >7C               Assign VARIABLE
[0078] 007E          SPEED  EQU  >7E               SPEED UP XML
[0079] 0080          CIF    EQU  >80               Convert INTEGER to FLOATING P
[0080] 0082          RTNB   EQU  >82               Return
[0081] 0083          SCROLL EQU  >83               SCROLL THE SCREEN
[0082] 008B          GVWITE EQU  >8B               WRITE DATA FROM GRAM TO VRAM
[0083] 008C          GREAD1 EQU  >8C               READ DATA FROM ERAM
[0084]               ***********************************************************
[0085]               * RXB XML'S ROM 3
[0086] 0074          HCHAR  EQU  >74               HCHAR ASSEMBLY
[0087] 0075          VCHAR  EQU  >75               VCHAR ASSEMBLY
[0088] 0076          ASCHEX EQU  >76               ASC TO HEX ASSEMBLY
[0089] 0077          HPUT   EQU  >77               HPUT ASSEMBLY
[0090] 0078          VPUT   EQU  >78               VPUT ASSEMBLY 
[0091] 0079          CLEARP EQU  >79               CLEAR PRINT ASSEMBLY
[0092] 007A          HGET   EQU  >7A               HGET ASSEMBLY
[0093] 007B          VGET   EQU  >7B               VGET ASSEMBLY
[0094] 007D          CHAR   EQU  >7D               CHAR ASSEMBLY RESET
[0095] 007F          CHRLDR EQU  >7F               LOAD CHARACTER DEFINITIONS
[0096] 0080          COLLSP EQU  >80               COLLIDE SPRITES
[0097] 0081          DCHAR  EQU  >81               CHARACTER & ALL DEFINITIONS
[0098] 0083          SPSPD5 EQU  >83               SPRITE SPEED UP OF SPNUM5
[0099] 0084          SPDEL  EQU  >84               SPRITE SPEED UP DELSPRITE
[0100]               ***********************************************************
[0101]               *    Temporary workspaces in EDIT
[0102]               * PAD   EQU  >8300            TEMPORARY
[0103] 8300          PTFBSL EQU  >8300            Ptr to 1st byte in SPEAK list
[0104] 8300          PHLEN  EQU  >8300            PHrom data LENgth
[0105] 8301          PAD1   EQU  >8301            TEMPORARY
[0106] 8301          PHRADD EQU  >8301            PHRom ADDress
[0107] 8302          PAD2   EQU  >8302            TEMPORARY
[0108] 8302          ACCUM  EQU  >8302            # OF BYTES ACCUMULATOR (4 BYTE
[0109] 8302          MNUM   EQU  >8302            Ussually a counter
[0110] 8302          PTLBSL EQU  >8302            Ptr to last byte in SPEAK list
[0111] 8303          PAD3   EQU  >8303            TEMPORARY
[0112] 8304          PAD4   EQU  >8304            TEMPORARY
[0113] 8304          VARY   EQU  >8304
[0114] 8304          PTEBSL EQU  >8304            Ptr to end byte in SPEAK list
[0115]               * NOTE: PTEBSL points to the end of the temporary speak lis
[0116]               *       whereas PTLBSL points to the last byte actually use
[0117]               *       i.e.    PTFBSL <= PTLBSL <= PTEBSL
[0118] 8306          VARY2  EQU  >8306            Use in MVDN only
[0119] 8306          CCPPTR EQU  >8306            OFFSET WITHIN RECORED (1)
[0120]               *                             or Pointer to current column
[0121] 8306          PAD6   EQU  >8306            TEMPORARY
[0122] 8306          PTFCIS EQU  >8306            Ptr to 1st character in string
[0123] 8307          PAD7   EQU  >8307
[0124] 8308          PAD8   EQU  >8308
[0125] 8308          PTCCIS EQU  >8308            Ptr to current character in st
[0126] 830A          STADDR EQU  >830A            Start address - usually for co
[0127] 830A          PADA   EQU  >830A            Temporary variable
[0128] 830A          PTLCIS EQU  >830A            Ptr to last character in strin
[0129] 830B          PADB   EQU  >830B

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0003 
RXB 2024
[0130] 830C          BYTES  EQU  >830C            BYTE COUNTER
[0131]               *                             or String length for GETSTR
[0132] 830C          PTFCIP EQU  >830C            Ptr to 1st character in phrase
[0133] 830E          VAR4   EQU  >830E
[0134] 830E          PTCCIP EQU  >830E            Ptr to current character in ph
[0135] 8310          TOPSTK EQU  >8310            Top of data stack pointer
[0136] 8310          PAD10  EQU  >8310
[0137] 8310          VAR5   EQU  >8310            VAR5 through VAR5+3 used in RA
[0138] 8310          PTLCIP EQU  >8310            Ptr to last character in phras
[0139] 8311          VAR6   EQU  >8311
[0140] 8312          PAD12  EQU  >8312
[0141] 8312          PTFBPH EQU  >8312            Ptr to 1st byte in PHrom
[0142] 8312          VAR7   EQU  >8312            Used in CHARLY
[0143] 8312          STRPTR EQU  >8312            RXB PATCH CODE
[0144] 8314          PTCCPH EQU  >8314            Ptr to current byte in PHrom
[0145] 8314          VAR9   EQU  >8314             Used in CHARLY
[0146] 8316          PAD16  EQU  >8316             Used in CHARLY
[0147] 8316          XFLAG  EQU  >8316            SCAN FLAG-BITS USED AS BELOW
[0148] 8316          PTLCPH EQU  >8316            Ptr to last byte in PHrom
[0149] 8317          FNUM   EQU  >8317            Current file number for search
[0150]               ***********************************************************
[0151]               *    Permanent workspace variables
[0152] 831C          SREF   EQU  >831C            Temporary string pointer
[0153] 8320          VARW   EQU  >8320            Screen address (CURSOR)
[0154] 8322          ERRCOD EQU  >8322            Return error code from ALC
[0155] 8324          STVSPT EQU  >8324            Value-stack base
[0156] 8326          RTNG   EQU  >8326            Return vector from 9900 code
[0157] 8328          NUDTAB EQU  >8328            Start of NUD table
[0158] 832C          PGMPTR EQU  >832C            Program text pointer (TOKEN)
[0159] 832E          EXTRAM EQU  >832E            Line number table pointer
[0160] 8330          STLN   EQU  >8330            Start of line number table
[0161] 8332          ENLN   EQU  >8332            End of line number table
[0162] 8334          DATA   EQU  >8334            Data pointer for READ
[0163] 8336          LNBUF  EQU  >8336            Line table pointer for READ
[0164] 833E          SYMTAB EQU  >833E            Symbol table pointer
[0165] 8340          FREPTR EQU  >8340            Free space pointer
[0166] 8342          CHAT   EQU  >8342            Current charater/token
[0167] 8344          PRGFLG EQU  >8344            Program/imperative flag
[0168] 8345          FLAG   EQU  >8345            General 8-bit flag
[0169] 8346          BUFLEV EQU  >8346            Crunch-buffer destruction leve
[0170] 8348          LSUBP  EQU  >8348            Last subprogram block on stack
[0171]               * FAC  EQU  >834A            Floating-point ACcurmulator
[0172] 834A          CCHAR  EQU  >834A            Current character
[0173] 834B          FAC1   EQU  >834B
[0174] 834B          SPLFLG EQU  >834B            SPelL out phrase FLaG
[0175] 834C          FAC2   EQU  >834C
[0176] 834C          TOTTIM EQU  >834C            TOTal wait TIMe
[0177]               * NOTE: DATAD must follow immediately after TOTTIM. The
[0178]               *       routine STDATA is counting on this fact!
[0179] 834D          FAC3   EQU  >834D
[0180] 834D          DATAAD EQU  >834D            Speech DATA ADdress
[0181] 834E          FAC4   EQU  >834E
[0182] 834E          CCC    EQU  >834E
[0183] 834E          FFF    EQU  >834E
[0184] 834F          PTLCIL EQU  >834F            Pointer To Last Character In L
[0185] 8350          FAC6   EQU  >8350
[0186] 8350          EEE    EQU  >8350
[0187] 8351          FAC7   EQU  >8351
[0188] 8351          TIMLEN EQU  >8351             TIMe LENgth of timing charact
[0189] 8352          FAC8   EQU  >8352
[0190] 8353          FAC9   EQU  >8353
[0191] 8354          FAC10  EQU  >8354
[0192] 8354          DDD1   EQU  >8354
[0193] 8354          TEMP1  EQU  >8354            TEMPorary CPU location 1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0004 
RXB 2024
[0194] 8355          FAC11  EQU  >8355
[0195] 8356          FAC12  EQU  >8356
[0196] 8356          FFF1   EQU  >8356
[0197] 8356          TEMP2  EQU  >8356            TEMPorary CPU location 2
[0198] 8358          FAC14  EQU  >8358
[0199] 8358          EEE1   EQU  >8358
[0200] 8358          READ   EQU  >8358            Address of speech peripheral
[0201]               *                             READ byte interface
[0202] 8359          FAC15  EQU  >8359
[0203] 835A          WRITE  EQU  >835A            Address of speech peripheral
[0204]               *                             WRITE byte interface
[0205]               * ARG  EQU  >835C            Floating-point ARGument
[0206] 835D          ARG1   EQU  >835D
[0207] 835D          PHDATA EQU  >835D            PHrom DATA
[0208] 835E          ARG2   EQU  >835E
[0209] 835E          PTCBED EQU  >835E            Ptr To Current Byte Ext Data
[0210] 8360          ARG4   EQU  >8360
[0211] 8360          LENCST EQU  >8360            LEN of Current ext data STring
[0212] 8362          ARG6   EQU  >8362
[0213] 8362          LENWST EQU  >8362            LEN of Whole ext data STring
[0214] 8363          ARG7   EQU  >8363
[0215] 8364          ARG8   EQU  >8364
[0216] 8364          STRLEN EQU  >8364            STRing LENgth
[0217] 8364          TEMP4  EQU  >8364
[0218] 8366          TEMP5  EQU  >8366
[0219]               * NOTE: BYTE1, BYTE2, and BYTE3 must be in consecutive memo
[0220]               *       locations, and in the following order for SPGET to
[0221]               *       work!
[0222] 8366          BYTE1  EQU  >8366            BYTE 1
[0223] 8367          BYTE2  EQU  >8367            BYTE 2
[0224] 8368          BYTE3  EQU  >8368            BYTE 3
[0225] 8368          TEMP6  EQU  >8368
[0226] 8369          SPKSTS EQU  >8369            SPeaK StaTus
[0227]               * FPERAD EQU  >836C          Value stack pointer
[0228]               * VSPTR  EQU  >836E          Value stack pointer
[0229]               ***********************************************************
[0230]               * MEMSIZ EQU  >8370           MEMORY SIZE
[0231]               * DATSTK EQU  >8372           DATA STACK
[0232]               * SUBSTK EQU  >8373           SUBROUTINE STACK
[0233] 8374          KEYBD  EQU  >8374             KEYBOARD SELCTION
[0234] 8375          RKEY   EQU  >8375             KEY CODE
[0235] 8376          JOYY   EQU  >8376             JOYSTICK Y POSITION
[0236] 8377          JOYX   EQU  >8377             JOYSTICK X POSITION
[0237] 8378          RANDOM EQU  >8378             RANDOM NUMBER GENERATOR
[0238] 8379          TIMER  EQU  >8379             TIMING REGISTER
[0239] 837A          NOMSPR EQU  >837A             NUMBER OF MOVING SPRITES
[0240] 837B          VDPSTT EQU  >837B             VDP STATUS REGISTER
[0241]               * STATUS EQU  >837C            GPL STATUS BYTE
[0242] 837C          ERCODE EQU  >837C             STATUS REGISTER
[0243] 837D          CB     EQU  >837D             Character Buffer
[0244]               * YPT    EQU  >837E            Screen Location ROW 
[0245]               * XPT    EQU  >837F            Screen Location COL 
[0246]               ***********************************************************
[0247] 8384          RAMTOP EQU  >8384            Highest address in ERAM
[0248] 8386          RAMFRE EQU  >8386            Free pointer in the ERAM
[0249] 8389          RAMFLG EQU  >8389            ERAM flag
[0250] 83C2          GKFLG  EQU  >83C2  * GKXB flag PEEK/LOAD VDP/GROM/QUIT KEY
[0251] 83CE          PRTNFN EQU  >83CE            Sound - previous tone finished
[0252]               ***********************************************************
[0253]               *    VDP addresses
[0254] 02E2          NLNADD EQU  >02E2             New LiNe ADDress
[0255] 0300          SPRSAL EQU  >0300             Sprite attribute list
[0256] 0371          LODFLG EQU  >0371             Auto-boot flag
[0257] 0372          START  EQU  >0372             Line to start execution at

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0005 
RXB 2024
[0258]               * Temporary
[0259] 0376          SYMBOL EQU  >0376             Saved symbol table pointer
[0260] 0378          ONECHR EQU  >0378             Used for CHRZ
[0261] 0379          VRMSND EQU  >0379             Sound blocks
[0262] 0382          SPGMPT EQU  >0382             Saved PGMPTR for continue
[0263] 0384          SBUFLV EQU  >0384             Saved BUFLEV for contiue
[0264] 0386          SEXTRM EQU  >0386             Saved EXTRAM for continue
[0265] 0388          SAVEVP EQU  >0388             Saved VSPRT for continue
[0266] 038A          ERRLN  EQU  >038A             On-error line pointer
[0267] 0390          CSNTMP EQU  >0390             Use as temporary stored place
[0268]               *                          or CSN TEMPORARY FOR FAC12
[0269] 0396          SLSUBP EQU  >0396             Saved LSUBP for continue
[0270] 0398          SFLAG  EQU  >0398             Saved on-warning/break bits
[0271] 03AA          SPNUM  EQU  >03AA             Sprite number temporary
[0272] 03BA          CSNTP1 EQU  >03BA             CSN TEMPORARY FOR FAC10
[0273] 03C0          VROAZ  EQU  >03C0             Temporary roll-out area
[0274] 07FF          SPRVB  EQU  >07FF             Sprite velocity block.
[0275] 0820          CRNBUF EQU  >0820             CRuNch BUFfer address
[0276]               ***********************************************************
[0277]               *    IMMEDITATE VALUES
[0278] 0000          NUMBR  EQU  >00               NUMERIC validate
[0279] 0002          LISTZ  EQU  >02
[0280] 0003          X2     EQU  >03
[0281] 0005          OLDZ   EQU  >05
[0282] 0006          RESEQZ EQU  >06
[0283] 0007          SAVEZ  EQU  >07
[0284] 0008          MERGEZ EQU  >08
[0285] 000A          DWNARR EQU  >0A
[0286] 000B          UPARR  EQU  >0B
[0287] 000D          CHRTN  EQU  >0D
[0288] 0020          BKGD   EQU  >20               BACKGROUND CHARACTER
[0289] 0060          OFFSET EQU  >60               OFFSET FOR VIDEO TABLES
[0290] 0065          STRVAL EQU  >65               Value in accum. is string val
[0291]               ***********************************************************
[0292]               * Editting command equates & keys or symbols
[0293] 0002          BREAK  EQU  >02               Break key
[0294] 0003          DLETE  EQU  >03               Delete key
[0295] 0004          INSRT  EQU  >04               Insert key
[0296] 0006          RECALL EQU  >06               Edit-buffer recall
[0297] 0007          CLRLN  EQU  >07               Clear-line key
[0298] 0008          BACK   EQU  >08               Back-space key
[0299] 0009          FORW   EQU  >09               Forward-space key
[0300] 000A          DOWN   EQU  >0A               Down-arrow key
[0301] 000B          UPMV   EQU  >0B               Up-arrow key
[0302] 001C          VWIDTH EQU  >1C               Screen width (PRINT)
[0303] 0020          SPACE  EQU  >20               Space key
[0304] 0022          QUOTE  EQU  >22               "
[0305] 0023          NUMBER EQU  >23               #
[0306] 0024          DOLLAR EQU  >24               $
[0307] 007E          CURSOR EQU  >1E+OFFSET        CURSOR
[0308] 007F          EDGECH EQU  >1F+OFFSET        EDGE character
[0309] 002B          PLUS   EQU  >2B               +
[0310] 002C          COMMAT EQU  >2C               ,
[0311] 002D          MINUS  EQU  >2D               -
[0312] 002D          HYPEN  EQU  >2D               +
[0313] 002E          PERIOD EQU  >2E               .
[0314] 0030          ZERO   EQU  >30               0
[0315] 0039          NINE   EQU  >39               9
[0316] 003A          COLON  EQU  >3A               :
[0317] 003B          SEMICO EQU  >3B               ;
[0318] 003C          LESS   EQU  >3C               <
[0319] 003E          GREAT  EQU  >3E               >
[0320] 0041          A      EQU  >41               A
[0321] 0046          F      EQU  >46               F

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0006 
RXB 2024
[0322]               ***********************************************************
[0323]               *    BASIC TOKEN TABLE
[0324]               *      EQU  >80               spare token
[0325] 0081          ELSEZ  EQU  >81               ELSE
[0326] 0082          SSEPZ  EQU  >82               ::
[0327] 0083          TREMZ  EQU  >83               $
[0328] 0084          IFZ    EQU  >84               IF
[0329] 0085          GOZ    EQU  >85               GO
[0330] 0086          GOTOZ  EQU  >86               GOTO
[0331] 0087          GOSUBZ EQU  >87               GOSUB
[0332] 0088          RETURZ EQU  >88               RETURN
[0333] 0089          DEFZ   EQU  >89               DEF
[0334] 008A          DIMZ   EQU  >8A               DIM
[0335] 008B          ENDZ   EQU  >8B               END
[0336] 008C          FORZ   EQU  >8C               FOR
[0337] 008D          LETZ   EQU  >8D               LET   
[0338] 008E          BREAKZ EQU  >8E               BREAK
[0339] 008F          UNBREZ EQU  >8F               UNBREAK
[0340] 0090          TRACEZ EQU  >90               TRACE
[0341] 0091          UNTRAZ EQU  >91               UNTRACE
[0342] 0092          INPUTZ EQU  >92               INPUT
[0343] 0093          DATAZ  EQU  >93               DATA
[0344] 0094          RESTOZ EQU  >94               RESTORE
[0345] 0095          RANDOZ EQU  >95               RANDOMIZE
[0346] 0096          NEXTZ  EQU  >96               NEXT
[0347] 0097          READZ  EQU  >97               READ
[0348] 0098          STOPZ  EQU  >98               STOP
[0349] 0099          DELETZ EQU  >99               DELETE
[0350] 009A          REMZ   EQU  >9A               REM
[0351] 009B          ONZ    EQU  >9B               ON
[0352] 009C          PRINTZ EQU  >9C               PRINT
[0353] 009D          CALLZ  EQU  >9D               CALL
[0354] 009E          OPTIOZ EQU  >9E               OPTION
[0355] 009F          OPENZ  EQU  >9F               OPEN
[0356] 00A0          CLOSEZ EQU  >A0               CLOSE
[0357] 00A1          SUBZ   EQU  >A1               SUB
[0358] 00A2          DISPLZ EQU  >A2               DISPLAY
[0359] 00A3          IMAGEZ EQU  >A3               IMAGE
[0360] 00A4          ACCEPZ EQU  >A4               ACCEPT
[0361] 00A5          ERRORZ EQU  >A5               ERROR
[0362] 00A6          WARNZ  EQU  >A6               WARNING
[0363] 00A7          SUBXTZ EQU  >A7               SUBEXIT
[0364] 00A8          SUBNDZ EQU  >A8               SUBEND
[0365] 00A9          RUNZ   EQU  >A9               RUN
[0366] 00AA          LINPUZ EQU  >AA               LINPUT
[0367]               *      EQU  >AB               spare token (LIBRARY)
[0368]               *      EQU  >AC               spare token (REAL)
[0369]               *      EQU  >AD               spare token (INTEGER)
[0370]               *      EQU  >AE               spare token (SCRATCH)
[0371]               *      EQU  >AF               spare token
[0372] 00B0          THENZ  EQU  >B0               THEN
[0373] 00B1          TOZ    EQU  >B1               TO
[0374] 00B2          STEPZ  EQU  >B2               STEP
[0375] 00B3          COMMAZ EQU  >B3               ,
[0376] 00B4          SEMICZ EQU  >B4               ;
[0377] 00B5          COLONZ EQU  >B5               :
[0378] 00B6          RPARZ  EQU  >B6               )
[0379] 00B7          LPARZ  EQU  >B7               (
[0380] 00B8          CONCZ  EQU  >B8               &          (CONCATENATE)
[0381]               *      EQU  >B9               spare token
[0382] 00BA          ORZ    EQU  >BA               OR
[0383] 00BB          ANDZ   EQU  >BB               AND
[0384] 00BC          XORZ   EQU  >BC               XOR
[0385] 00BD          NOTZ   EQU  >BD               NOT

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0007 
RXB 2024
[0386] 00BE          EQUALZ EQU  >BE               =
[0387] 00BF          LESSZ  EQU  >BF               <
[0388] 00C0          GREATZ EQU  >C0               >
[0389] 00C1          PLUSZ  EQU  >C1               +
[0390] 00C2          MINUSZ EQU  >C2               -
[0391] 00C3          MULTZ  EQU  >C3               *
[0392] 00C4          DIVIZ  EQU  >C4               /
[0393] 00C5          CIRCUZ EQU  >C5               ^
[0394]               *      EQU  >C6               spare token
[0395] 00C7          STRINZ EQU  >C7               QUOTED STRING
[0396] 00C8          UNQSTZ EQU  >C8               UNQUOTED STRING
[0397] 00C8          NUMZ   EQU  >C8               ALSO NUMERICAL STRING
[0398] 00C8          NUMCOZ EQU  >C8               ALSO UNQUOTED STRING
[0399] 00C9          LNZ    EQU  >C9               LINE NUMBER CONSTANT
[0400]               *      EQU  >CA               spare token
[0401] 00CB          ABSZ   EQU  >CB               ABS
[0402] 00CC          ATNZ   EQU  >CC               ATN
[0403] 00CD          COSZ   EQU  >CD               COS
[0404] 00CE          EXPZZ  EQU  >CE               EXP
[0405] 00CF          INTZ   EQU  >CF               INT
[0406] 00D0          LOGZ   EQU  >D0               LOG
[0407] 00D1          SGNZZ  EQU  >D1               SGN
[0408] 00D2          SINZ   EQU  >D2               SIN
[0409] 00D3          SQRZ   EQU  >D3               SQR
[0410] 00D4          TANZ   EQU  >D4               TAN
[0411] 00D5          LENZ   EQU  >D5               LEN
[0412] 00D6          CHRZZ  EQU  >D6               CHR$
[0413] 00D7          RNDZ   EQU  >D7               RND
[0414] 00D8          SEGZZ  EQU  >D8               SEG$
[0415] 00D9          POSZ   EQU  >D9               POS
[0416] 00DA          VAL    EQU  >DA               VAL
[0417] 00DB          STRZZ  EQU  >DB               STR$
[0418] 00DC          ASCZ   EQU  >DC               ASC
[0419] 00DD          PIZ    EQU  >DD               PI
[0420] 00DE          RECZ   EQU  >DE               REC
[0421] 00DF          MAXZ   EQU  >DF               MAX
[0422] 00E0          MINZ   EQU  >E0               MIN
[0423] 00E1          RPTZZ  EQU  >E1               RPT$
[0424]               *      EQU  >E2               unused
[0425]               *      EQU  >E2               unused
[0426]               *      EQU  >E3               unused
[0427]               *      EQU  >E4               unused
[0428]               *      EQU  >E5               unused
[0429]               *      EQU  >E6               unused
[0430]               *      EQU  >E7               unused
[0431] 00E8          NUMERZ EQU  >E8               NUMERIC
[0432] 00E9          DIGITZ EQU  >E9               DIGIT
[0433] 00EA          UALPHZ EQU  >EA               UALPHA
[0434] 00EB          SIZEZ  EQU  >EB               SIZE
[0435] 00EC          ALLZ   EQU  >EC               ALL
[0436] 00ED          USINGZ EQU  >ED               USING
[0437] 00EE          BEEPZ  EQU  >EE               BEEP
[0438] 00EF          ERASEZ EQU  >EF               ERASE
[0439] 00F0          ATZ    EQU  >F0               AT
[0440] 00F1          BASEZ  EQU  >F1               BASE
[0441]               *      EQU  >F2               spare token (TEMPORARY)
[0442] 00F3          VARIAZ EQU  >F3               VARIABLE
[0443] 00F4          RELATZ EQU  >F4               RELATIVE
[0444] 00F5          INTERZ EQU  >F5               INTERNAL
[0445] 00F6          SEQUEZ EQU  >F6               SEQUENTIAL
[0446] 00F7          OUTPUZ EQU  >F7               OUTPUT
[0447] 00F8          UPDATZ EQU  >F8               UPDATE
[0448] 00F9          APPENZ EQU  >F9               APPEND
[0449] 00FA          FIXEDZ EQU  >FA               FIXED

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0008 
RXB 2024
[0450] 00FB          PERMAZ EQU  >FB               PERMANENT
[0451] 00FC          TABZ   EQU  >FC               TAB
[0452] 00FD          NUMBEZ EQU  >FD               #
[0453] 00FE          VALIDZ EQU  >FE               VALIDATE
[0454]               *      EQU  >FF               ILLEGAL VALUE
[0455]               ***********************************************************
[0456]               * NOTE: FILES EXECSD, SUBS AND PART OF PSCANS ARE IN GROM 5
[0457]               *       AS BELOW:
[0458]               *-------NAME------------------ADDRESS---------BYTES LEFT---
[0459]               *      EXECS                  >A000 - >AD92        5
[0460]               *      SUBS                   >AD98 - >B4DC        2
[0461]               *      PSCANS                 >B4E0 - >B7FA        5
[0462]               *
[0463]               * Some of the error calls at the end of EXECS file are
[0464]               * shared and directly addressed by SUBS file. Any change in
[0465]               * EXECS file which affects the address of error calls will
[0466]               * affect error reference in SUBS file. Make sure to edit
[0467]               * SUBS file in that situation.
[0468]               ***********************************************************
[0469] A000 0F,75           XML  CONT              XML CONT used by subprogram
[0470] A002 43,3A           BR   LITS05            Build FAC entry and GETSTR
[0471] A004 40,90           BR   EXEC              Execute a program
[0472] A006 48,10           BR   LINE
[0473] A008 47,AB           BR   DATAST
[0474] A00A 47,C7           BR   ASC
[0475] A00C 40,9D           BR   EXEC1
[0476] A00E 41,1F           BR   EXEC6D            Save information on a break
[0477] A010 47,47           BR   DELINK            Delink symbol table entry
[0478] A012 48,22           BR   CONV1
[0479] A014 49,6D           BR   SQUISH            Called in error routine in PS
[0480] A016 44,AE           BR   VALCD
[0481] A018 42,81           BR   INTRND
[0482] A01A 40,1A           BR   $
[0483] A01C 48,82           BR   LNKRTN            Routine to go back to XB prog
[0484] A01E 48,FA           BR   SPCOL             Clear breakpoint in line # ro
[0485] A020 46,39           BR   UBSUB             Spare
[0486] A022 40,22           BR   $
[0487] A024 5C,F0    GA024  BR   CASCII            RXB SIZE ADDRESS DISPLAY
[0488]               *                  *** Please let me know it you address to
[0489]               *                  *** branches here since it will advance
[0490]               *                  *** the address of link list. Sum
[0491] A026 A0,30    LINK1  DATA LINK2
[0492] A028 05,53,4F        STRI 'SOUND'           SOUND
       A02B 55,4E,44
[0493] A02E A9,A9           DATA XSOUND
[0494] A030 A0,3A    LINK2  DATA LINK3
[0495] A032 05,43,4C        STRI 'CLEAR'           CLEAR
       A035 45,41,52
[0496] A038 A9,89           DATA CLEARZ
[0497] A03A A0,44    LINK3  DATA LINK4
[0498] A03C 05,43,4F        STRI 'COLOR'           COLOR
       A03F 4C,4F,52
[0499] A042 A8,8E           DATA COLORZ
[0500] A044 A0,4E    LINK4  DATA LINK5
[0501] A046 05,47,43        STRI 'GCHAR'           GCHAR   (ASSEMBLY)
       A049 48,41,52
[0502] A04C A8,37           DATA GCHARZ
[0503] A04E A0,58    LINK5  DATA LINK6
[0504] A050 05,48,43        STRI 'HCHAR'           HCHAR   (ASSEMBLY) 
       A053 48,41,52
[0505] A056 AA,6E           DATA HCHARZ
[0506] A058 A0,62    LINK6  DATA LINK7
[0507] A05A 05,56,43        STRI 'VCHAR'           VCHAR   (ASSEMBLY)
       A05D 48,41,52

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0009 
RXB 2024
[0508] A060 AA,88           DATA VCHARZ
[0509] A062 A0,6B    LINK7  DATA LINK8
[0510] A064 04,43,48        STRI 'CHAR'            CHAR    (ASSEMBLY)
       A067 41,52
[0511] A069 AA,FA           DATA CHARLY
[0512] A06B A0,73    LINK8  DATA LINK9
[0513] A06D 03,4B,45        STRI 'KEY'             KEY
       A070 59
[0514] A071 B8,A1           DATA ZKEY
[0515] A073 A0,7D    LINK9  DATA LINKA
[0516] A075 05,4A,4F        STRI 'JOYST'           JOYST
       A078 59,53,54
[0517] A07B B9,BF           DATA ZJOYST
[0518] A07D A0,88    LINKA  DATA LINKB
[0519] A07F 06,53,43        STRI 'SCREEN'          SCREEN
       A082 52,45,45
       A085 4E
[0520] A086 AB,B8           DATA BORDER
[0521] A088 AC,C6    LINKB  DATA LINKS1
[0522] A08A 03,45,52        STRI 'ERR'             ERR
       A08D 52
[0523] A08E AB,C5           DATA ERRWXY
[0524]               ***********************************************************
[0525]               *        START EXECUTION OF A PROGRAM OR STATEMENT
[0526]               * DATA:
[0527]               *      RAM(START) points into line number table at the
[0528]               *      first line to execute
[0529]               *      @PGMFLG contains >FF if executing a program or zero
[0530]               *      if imperative statement
[0531]               ***********************************************************
[0532] A090 8E,44    EXEC   CZ   @PRGFLG           If program
[0533] A092 60,A2           BS   GA0AE
[0534] A094 BD,2E,A3        DST  V@START,@EXTRAM   Line to start execution at
       A097 72
[0535] A098 95,2E           DINCT @EXTRAM          Pointer to text pointer
[0536] A09A 06,A2,81        CALL INTRND            Initialize random number
[0537] A09D BE,7F,03 EXEC1  ST   X2,@XPT           Initialize screen display
[0538] A0A0 40,A6           BR   GA0B2
[0539] A0A2 BF,2C,08 GA0AE  DST  CRNBUF,@PGMPTR    Executing out of crunch buffe
       A0A5 20
[0540] A0A6 BF,26,A0 GA0B2  DST  EXEC20,@RTNG      Address of return from ALC
       A0A9 B0
[0541] A0AA BF,28,A1        DST  NUDTB,@NUDTAB     NUD table address for ALC
       A0AD 3B
[0542] A0AE 0F,76           XML  EXECG             Execute XB
[0543] A0B0 8A,23    EXEC20 CASE @ERRCOD+1         Check type of return
[0544] A0B2 40,D3           BR   EXECND            0 - NORMAL END
[0545] A0B4 41,0E           BR   EXECBK            1 - BREAKPOINT
[0546] A0B6 40,E1           BR   EXECTR            2 - TRACE
[0547] A0B8 47,E8           BR   ERORZ             3 - ERROR
[0548] A0BA 40,C8           BR   WARNGZ            4 - WARNING
[0549] A0BC 41,CE           BR   ONERR             5 - ON ERROR
[0550] A0BE 46,54           BR   UDF               6 - FUNCTION
[0551] A0C0 42,0C           BR   ONBRK             7 - ON BREAK
[0552] A0C2 43,77           BR   CONCAT            8 - CONCATENATE STRINGS "&"
[0553] A0C4 41,9E           BR   ONWARN            9 - ON WARNING
[0554] A0C6 42,23           BR   GPLCAL            A - CALL STATEMENT
[0555] A0C8 C6,73,B0 WARNGZ CH   >B0,@SUBSTK
[0556] A0CB 6C,96           BS   ERRSO
[0557]               * Stack overflow
[0558]               *                    ALLOW ROOM ON STACK FOR WARNING CALLS
[0559] A0CD 06,6A,82 WRNN01 CALL WARNZZ        ONLY WARNING MSG FROM XB SUPPORT
[0560] A0D0 02              BYTE 2       *         NUMERIC OVERFLOW
[0561] A0D1 41,0A           BR   CLRRTN            Clear ERRCOD and return

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0010 
RXB 2024
[0562]               *                    NORMAL END OF EXECUTION
[0563] A0D3 8E,44    EXECND CZ   @PRGFLG           If imperative mode
[0564] A0D5 40,DD           BR   ERRRDY
[0565] A0D7 06,60,1C        CALL CHRTAB            Load the default character se
[0566] A0DA 05,63,DD        B    TOPL15            Return to top-level
[0567] A0DD 06,6A,84 ERRRDY CALL ERRZZ             Display * READY *
[0568] A0E0 00              BYTE 0
[0569]               * TRACE-MODE turned on - display line number
[0570] A0E1 86,20    EXECTR CLR  @VARW             Clear upper address byte
[0571] A0E3 BC,21,7F        ST   @XPT,@VARW+1      Get current x-pointer
[0572] A0E6 A3,20,02        DADD NLNADD-3,@VARW    Make a valid screen address
       A0E9 DF
[0573] A0EA C7,20,02        DCH  NLNADD+22,@VARW   If might go off screen
       A0ED F8
[0574] A0EE 40,F6           BR   GA102
[0575] A0F0 0F,83           XML  SCROLL            SCROLL to next line
[0576] A0F2 BF,20,02        DST  NLNADD,@VARW      Re-initialize screen address
       A0F5 E2
[0577] A0F6 BE,B0,20 GA102  ST   LESS+OFFSET,V*VARW Display open bracket "("
       A0F9 9C
[0578] A0FA 91,20           DINC @VARW             Increment screen address
[0579] A0FC 06,A7,C7        CALL ASC               Convert line # into ASCII
[0580] A0FF BE,B0,20        ST   GREAT+OFFSET,V*VARW Display close bracket ")"
       A102 9E
[0581] A103 A7,20,02        DSUB NLNADD-4,@VARW    Update the x-pointer
       A106 DE
[0582] A107 BC,7F,21        ST   @VARW+1,@XPT
[0583] A10A 87,22    CLRRTN DCLR @ERRCOD           Clear the return vector
[0584] A10C 0F,82           XML  RTNB              Return to ALC
[0585]               * BREAKPOINT OR BREAK-KEY RECIEVED
[0586] A10E 8E,44    EXECBK CZ   @PRGFLG           If break or program
[0587] A110 61,37           BS   ERRBRK
[0588] A112 BD,52,2E        DST  @EXTRAM,@FAC8     @FAC8 : Source addr in ERAM
[0589] A115 97,52           DDECT @FAC8            Point to the line #
[0590] A117 06,A6,49        CALL UBSUB1            Reset the breakpoint
[0591] A11A 03              SCAN                   Get break key out of queue
[0592] A11B BD,A3,82 EXEC6C DST  @PGMPTR,V@SPGMPT  Save text pointer
       A11E 2C
[0593] A11F BD,A3,86 EXEC6D DST  @EXTRAM,V@SEXTRM  Save line number table pointe
       A122 2E
[0594] A123 BD,A3,88        DST  @VSPTR,V@SAVEVP   Save value stack pointer
       A126 6E
[0595] A127 BD,A3,84        DST  @BUFLEV,V@SBUFLV  Save crunch buffer level
       A12A 46
[0596] A12B BD,A3,96        DST  @LSUBP,V@SLSUBP   Save last subprogram on stack
       A12E 48
[0597] A12F BC,A3,98        ST   @FLAG,V@SFLAG     Save FLAG for continue
       A132 45
[0598] A133 B2,A3,98        AND  >63,V@SFLAG       Only warning and break bits
       A136 63
[0599] A137 06,6A,84 ERRBRK CALL ERRZZ             * BREAKPOINT
[0600] A13A 01              BYTE 1
[0601]               ***********************************************************
[0602]               *               NUD / STATEMENT BRANCH TABLE
[0603]               ***********************************************************
[0604] A13B 41,7D    NUDTB  BR   RECX              'RECORD'              0
[0605] A13D 45,C8           BR   NBREAK            'BREAK'               0
[0606] A13F 45,DA           BR   NUNBRK            'UNBREAK'             0
[0607] A141 45,BE           BR   NTRACE            'TRACE'               0
[0608] A143 45,C3           BR   NUNTRC            'UNTRACE'             0
[0609] A145 41,80           BR   NREADX            'READ'                0
[0610] A147 41,83           BR   PRINTX            'PRINT'               0
[0611] A149 41,7A           BR   SZRUNX            'RUN'                 0
[0612] A14B 41,9B           BR   LINPUX            Reserved for LINPUT   1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0011 
RXB 2024
[0613] A14D 41,86           BR   RESTOX            'RESTORE'             1
[0614] A14F 43,15           BR   NRNDMZ            'RANDOMIZE'           1
[0615] A151 41,89           BR   INPUTX            'INPUT'               1
[0616] A153 41,8C           BR   OPENX             'OPEN'                1
[0617] A155 41,8F           BR   CLOSEX            'CLOSE'               1
[0618] A157 42,3C           BR   NPI               'PI'                  1
[0619] A159 42,4C           BR   NMAX              'MAX'                 1
[0620] A15B 42,59           BR   NMIN              'MIN'                 2
[0621] A15D 45,65           BR   RPTZ01            'RPT$'                2
[0622] A15F 41,92           BR   ACCEPX            'ACCEPT'              2
[0623] A161 41,77           BR   EOFX              'EOF'                 2
[0624] A163 44,59           BR   ASC01             'ASC'                 2
[0625] A165 44,FA           BR   POS01             'POS'                 2
[0626] A167 44,94           BR   VAL01             'VAL'                 2
[0627] A169 44,6A           BR   STRZ01            'STR$'                2
[0628] A16B 43,CF           BR   SEGZ01            'SEG$'                3
[0629] A16D 41,98           BR   DELETX            'DELETE'              3
[0630] A16F 41,95           BR   DISPLX            'DISPLAY'             3
[0631] A171 44,32           BR   LEN01             'LEN'                 3
[0632] A173 44,3E           BR   CHRZ01            'CHR$'                3
[0633]               *RXB PATCH CODE FOR BASIC RND REPLACEMENT ***********
[0634] A175 42,87           BR   NRND              'RND'                 3      
[0635]               * The following are long branches to another GROM
[0636] A177 05,80,1C EOFX   B    EOF
[0637] A17A 05,60,1E SZRUNX B    SZRUN
[0638] A17D 05,80,22 RECX   B    REC
[0639] A180 05,80,0E NREADX B    NREAD
[0640] A183 05,80,04 PRINTX B    PRINT
[0641] A186 05,80,0C RESTOX B    RESTOR
[0642] A189 05,80,06 INPUTX B    INPUT
[0643] A18C 05,80,08 OPENX  B    OPEN
[0644] A18F 05,80,0A CLOSEX B    CLOSE
[0645] A192 05,80,1E ACCEPX B    ACCEPT
[0646] A195 05,80,00 DISPLX B    DISPL1
[0647] A198 05,80,02 DELETX B    DELET
[0648] A19B 05,80,30 LINPUX B    LINPUT
[0649]               ***********************************************************
[0650]               * FLAGS USED IN EXECUTION MODE:    this needs to be checked
[0651]               *  @FLAG   BIT   RESET               SET
[0652]               *           0
[0653]               *           1    Warning PRINT       PRINT off
[0654]               *           2    Warning NEXT        STOP
[0655]               *           3    Not in UDF          Executing a UDF
[0656]               *           4    TRACE mode          Normal mode
[0657]               *           5
[0658]               *           6    BREAK allowed       BREAK not allowed
[0659]               *           7    No LST/EDT protect  LIST/EDIT protected
[0660]               ***********************************************************
[0661]               * ON WARNING {NEXT | STOP | PRINT}
[0662]               * ON WARNING NEXT  - Causes warning messages to be ignored
[0663]               *                    and execution to continue as if a
[0664]               *                    warning never occurred
[0665]               * ON WARNING STOP  - Causes a warning to be treated as an
[0666]               *                    error - i.e. the message is displayed
[0667]               *                    and execution is halted
[0668]               * ON WARNING PRINT - Causes the default warning handling to
[0669]               *                    be in effect, i.e. any warning
[0670]               *                    messages are printed and execution
[0671]               *                    continues
[0672]               ***********************************************************
[0673] A19E 0F,79    ONWARN XML  PGMCHR            GET OPTION
[0674] A1A0 D6,42,9C        CEQ  PRINTZ,@CHAT      If print
[0675] A1A3 41,AB           BR   GA1B7
[0676] A1A5 B2,45,F9        AND  >F9,@FLAG         Turn on print and contiue

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0012 
RXB 2024
[0677] A1A8 05,A1,C3        B    ONWRN5
[0678] A1AB D6,42,98 GA1B7  CEQ  STOPZ,@CHAT
[0679] A1AE 41,B8           BR   GA1C4
[0680] A1B0 B2,45,FD        AND  NUMBEZ,@FLAG         Turn on print
[0681] A1B3 B6,45,04        OR   >04,@FLAG         Turn on stop
[0682] A1B6 41,C3           BR   ONWRN5
[0683] A1B8 D6,42,96 GA1C4  CEQ  NEXTZ,@CHAT       * SYNTAX ERROR
[0684] A1BB 4C,86           BR   ERRSYN
[0685] A1BD B6,45,02        OR   >02,@FLAG         Turn off print
[0686] A1C0 B2,45,FB        AND  >FB,@FLAG         Turn off stop
[0687] A1C3 0F,79    ONWRN5 XML  PGMCHR            Check for EOS
[0688] A1C5 06,6A,78 ONWRN7 CALL CHKEND            Error if not EOS
[0689] A1C8 4C,86           BR   ERRSYN            If not EOS
[0690] A1CA 87,22           DCLR @ERRCOD
[0691] A1CC 0F,75           XML  CONT              Continue
[0692]               ***********************************************************
[0693]               * ON ERROR {line number | STOP}
[0694]               * ON ERROR line number - causes the error routine to build
[0695]               *                        an error stack entry and pass
[0696]               *                        control to the line specified in
[0697]               *                        the most-recently executed
[0698]               *                        on-error-statement
[0699]               * ON ERROR STOP - causes the default error handling
[0700]               *                 conditions to be in effect. i.e. any
[0701]               *                 errors that occur cause execution to halt
[0702]               *                 an a message to be displayed
[0703]               ***********************************************************
[0704] A1CE 0F,79    ONERR  XML  PGMCHR            Get option
[0705] A1D0 D6,42,C9        CEQ  LNZ,@CHAT         If line # then find the line
[0706] A1D3 42,02           BR   GA20E
[0707] A1D5 0F,79           XML  PGMCHR            Get upper byte
[0708] A1D7 BC,4A,42        ST   @CHAT,@FAC
[0709] A1DA 0F,79           XML  PGMCHR            Get lower byte
[0710] A1DC BC,4B,42        ST   @CHAT,@FAC1
[0711] A1DF BD,4C,32        DST  @ENLN,@FAC2
[0712] A1E2 A7,4C,00        DSUB 3,@FAC2           Pointing to 1st line #
       A1E5 03
[0713]               * Consider both ERAM and RAM cases to get line # from the
[0714]               * line number table. Also reset the break bit.
[0715] A1E6 06,80,2E ONERR2 CALL GRSUB3            Get 2 bytes from either RAM/E
[0716] A1E9 4C              BYTE FAC2            * FAC2 has the address
[0717] A1EA D5,4A,58        DCEQ @EEE1,@FAC        If found
[0718] A1ED 61,FA           BS   ONERR4
[0719] A1EF C5,4C,30        DCH  @STLN,@FAC2       Not found
[0720] A1F2 4C,B2           BR   ERRLNF
[0721] A1F4 A7,4C,00        DSUB 4,@FAC2           Goto next line
       A1F7 04
[0722] A1F8 41,E6           BR   ONERR2
[0723] A1FA 95,4C    ONERR4 DINCT @FAC2
[0724] A1FC BD,A3,8A        DST  @FAC2,V@ERRLN
       A1FF 4C
[0725] A200 42,0A           BR   GA216
[0726] A202 D6,42,98 GA20E  CEQ  STOPZ,@CHAT       * SYNTAX ERROR
[0727] A205 4C,86           BR   ERRSYN
[0728] A207 87,A3,8A        DCLR V@ERRLN           Back to default error handlin
[0729] A20A 41,C3    GA216  BR   ONWRN5            Finish up same as ON WARNING
[0730]               ***********************************************************
[0731]               * ON BREAK {NEXT | STOP}
[0732]               * ON BREAK NEXT - Causes any breakpoints which have been
[0733]               *                 set on statements to be ignored when the
[0734]               *                 statement is encountered and also masks
[0735]               *                 the shift-C key so that it is ignored
[0736]               * ON BREAK STOP - Causes the default break handling to be
[0737]               *                 in force., i.e. execution is halted and

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0013 
RXB 2024
[0738]               *                 the BREAKPOINT message is displayed on
[0739]               *                 the screen
[0740]               ***********************************************************
[0741] A20C 0F,79    ONBRK  XML  PGMCHR            Get next char to find option
[0742] A20E D6,42,98        CEQ  STOPZ,@CHAT       If stop option specified
[0743] A211 42,19           BR   GA225
[0744] A213 B2,45,BF        AND  >BF,@FLAG         break allowed
[0745] A216 05,A2,21        B    GA22D             Don't change this to BR GA22D
[0746] A219 D6,42,96 GA225  CEQ  NEXTZ,@CHAT       If next option number
[0747] A21C 4C,86           BR   ERRSYN            specified then syntax error
[0748] A21E B6,45,40        OR   >40,@FLAG         If next option specified then
[0749]               *                              break NOT allowed
[0750] A221 41,C3    GA22D  BR   ONWRN5            Finish up same as ON WARNING
[0751]               ***********************************************************
[0752]               * GPLCAL - If a call is made to a subprogram that does not
[0753]               *  not exist either in the BASIC program itself or in the
[0754]               *  internal GPL subprogram list then one final attempt is
[0755]               *  made to find the subprogram at execution time by
[0756]               *  searching for the subprogram in the console or a
[0757]               *  peripheral. If not found there, then a
[0758]               *  *SUBPROGRAM NOT FOUND error occurs
[0759]               *
[0760]               *  Input: the subprogram name is in the FAC and the length
[0761]               *         of the name is in FAC15
[0762]               ***********************************************************
[0763] A223 8E,80,89 GPLCAL CZ   @RAMFLG           Can't try if CPU program
[0764] A226 4C,C2           BR   ERRSNF
[0765] A228 E7,59,00        DSRL 8,@FAC15          Make name length a double
       A22B 08
[0766] A22C A5,2C,59        DSUB @FAC15,@PGMPTR    Point back at name
[0767] A22F 93,2C           DDEC @PGMPTR           Point at name length
[0768] A231 BD,56,2C        DST  @PGMPTR,@FAC12    Set pointer to name
[0769] A234 06,00,10        CALL LINK              Issue 'Call Program Link'
[0770] A237 0A              BYTE 10              * Search subprogram lists
[0771] A238 41,C5           BR   ONWRN7            If all ok, check-end and rtn
[0772] A23A 4C,C2           BR   ERRSNF            If not found, error
[0773]               ***********************************************************
[0774]               *                     NUD FOR PI
[0775]               ***********************************************************
[0776] A23C 31,00,08 NPI    MOVE 8,G@CONPI,@FAC    Load constant PI
       A23F 4A,A2,44
[0777] A242 0F,75           XML  CONT
[0778] A244 40,03,0E CONPI  BYTE >40,3,14,15,92,65,35,90
       A247 0F,5C,41
       A24A 23,5A
[0779]               * 3.1415992653590E+00
[0780]               ***********************************************************
[0781]               *                     NUD FOR MAX
[0782]               ***********************************************************
[0783] A24C 06,A2,61 NMAX   CALL MAXMIN            Combine MAX and MIN
[0784] A24F 0A              GT
[0785] A250 42,57           BR   GA263
[0786] A252 35,00,08 NMAXZ1 MOVE 8,@ARG,@FAC
       A255 4A,5C
[0787] A257 0F,75    GA263  XML  CONT
[0788]               ***********************************************************
[0789]               *                     NUD FOR MIN
[0790]               ***********************************************************
[0791] A259 06,A2,61 NMIN   CALL MAXMIN            Combine MAX and MIN again
[0792] A25C 0A              GT
[0793] A25D 42,52           BR   NMAXZ1
[0794] A25F 0F,75           XML  CONT
[0795]               ***********************************************************
[0796]               *                COMMON MAX / MIN ROUTINE

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0014 
RXB 2024
[0797]               ***********************************************************
[0798] A261 06,AB,92 MAXMIN CALL LPARR             Skip "(" parse, and insure ,
[0799] A264 C6,4C,63        CH   >63,@FAC2         Must be numeric
[0800] A267 6C,8A           BS   ERRSNM
[0801] A269 0F,77           XML  VPUSH             Push l.h. arg on stack
[0802] A26B 0F,74           XML  PARSE             PARSE up to ")"
[0803] A26D B6              BYTE RPARZ
[0804] A26E C6,4C,63        CH   >63,@FAC2         Must be numeric
[0805] A271 6C,8A           BS   ERRSNM
[0806] A273 0F,7E           XML  SPEED             Must be
[0807] A275 00              BYTE SYNCHK        *    at a
[0808] A276 B6              BYTE RPARZ         *      right parenthesis
[0809] A277 35,00,08        MOVE 8,@FAC,@ARG       Save in ARG for compare
       A27A 5C,4A
[0810] A27C 0F,78           XML  VPOP              Get l.h. arg back
[0811] A27E 0F,0A           XML  FCOMP             Compare operands
[0812] A280 00              RTN
[0813]               * RXB PATCH CODE FOR INTRND
[0814] A281 BF,80,C0 INTRND DST  >3567,@>83C0      Random number seed
       A284 35,67
[0815] A286 00              RTN
[0816]               ***********************************************************
[0817]               * RXB BASIC RND REPLACEMENT FROM TI BASIC
[0818] A287 BE,4A,3F NRND   ST   >3F,@FAC       * Exponent    
[0819] A28A BE,10,4B        ST   >4B,@VAR5      * Loop counter
[0820] A28D 02,63    NRND1  RAND >63            * 0?
[0821] A28F 8E,78           CZ   @RANDOM        * No, go on
[0822] A291 42,9D           BR   NRND3     
[0823] A293 92,4A           DEC  @FAC           * 0?
[0824] A295 8E,4A           CZ   @FAC           * End with 0
[0825] A297 62,AA           BS   NRND4          * Go on
[0826] A299 42,8D           BR   NRND1
[0827] A29B 02,63    NRND2  RAND >63            * Till 100
[0828] A29D BC,90,10 NRND3  ST   @RANDOM,*VAR5  * All digits
       A2A0 78
[0829] A2A1 D6,10,51        CEQ  >51,@VAR5      * Till >8351
[0830] A2A4 62,AC           BS   NRND5 
[0831] A2A6 90,10           INC  @VAR5          * Increase loop counter
[0832] A2A8 42,9B           BR   NRND2 
[0833] A2AA 86,4B    NRND4  CLR  @FAC1          * Set 0
[0834] A2AC 0F,75    NRND5  XML  CONT
[0835]               ***********************************************************
[0836] A2AE 0F,79    STRFCH XML  PGMCHR     * SKIP whatever
[0837] A2B0 0F,74    STRPAR XML  PARSE
[0838] A2B2 B6              BYTE RPARZ
[0839] A2B3 00              RTN
[0840] A2B4 06,A2,AE STRGET CALL STRFCH
[0841] A2B7 D6,4C,65        CEQ  >65,@FAC2
[0842] A2BA 4C,8A           BR   ERRSNM      * STRING NUM MISMATCH
[0843] A2BC 00              RTN
[0844] A2BD 06,A2,AE NUMFCH CALL STRFCH
[0845] A2C0 D6,4C,65 NUMSNM CEQ  >65,@FAC2
[0846] A2C3 6C,8A           BS   ERRSNM      * STRING NUM MISMATCH
[0847] A2C5 00              RTN
[0848] A2C6 0F,12    CFIFCH XML  CFI
[0849] A2C8 D6,54,03        CEQ  >03,@FAC+10
[0850] A2CB 6C,BA           BS   ERRBV       * NUMERIC OVERFLOW
[0851] A2CD 00              RTN
[0852] A2CE 06,A2,D7 GETNUM CALL SUBLP3
[0853] A2D1 D6,42,B3 GNRTN  CEQ  >B3,@CHAT
[0854] A2D4 4C,86           BR   ERRSYN
[0855] A2D6 00              RTN
[0856] A2D7 06,A2,BD SUBLP3 CALL NUMFCH
[0857] A2DA 06,A2,C6        CALL CFIFCH

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0015 
RXB 2024
[0858] A2DD 00              RTN
[0859] A2DE 06,A2,B0 SUBLP4 CALL STRPAR
[0860] A2E1 06,A2,C6        CALL CFIFCH
[0861] A2E4 42,D1           BR   GNRTN
[0862] A2E6 0F,79    NGOOD  XML  PGMCHR
[0863] A2E8 CA,42,80 NGOOD1 CHE  >80,@CHAT
[0864] A2EB 6C,86           BS   ERRSYN         * ?
[0865] A2ED 06,A3,01        CALL SNDER
[0866] A2F0 D6,4C,65        CEQ  >65,@FAC2
[0867] A2F3 4C,8A           BR   ERRSNM         * STRING NUMBER MISMATCH
[0868] A2F5 BF,4A,00        DST  >001C,@FAC
       A2F8 1C
[0869] A2F9 BD,4E,1C        DST  @SREF,@FAC4
[0870] A2FC BD,50,0C        DST  @BYTES,@FAC6
[0871] A2FF 43,0A           BR   SNDASS
[0872] A301 0F,7A    SNDER  XML  SYM
[0873] A303 0F,7B           XML  SMB
[0874] A305 0F,77           XML  VPUSH
[0875] A307 00              RTN
[0876] A308 0F,80    CIFSND XML  CIF
[0877] A30A 0F,7C    SNDASS XML  ASSGNV
[0878] A30C 00              RTN
[0879] A30D 86,4A    CLRFAC CLR  @FAC
[0880] A30F 35,00,07        MOVE 7,@FAC,@FAC1
       A312 4B,4A
[0881] A314 00              RTN
[0882]               ***********************************************************
[0883]               *                   RANDOMIZE STATEMENT
[0884]               ***********************************************************
[0885]               * RXB PATCH RAMDOMIZE and RANDOMIZE SEED replaced         *
[0886]               ***********************************************************
[0887] A315 06,6A,78 NRNDMZ CALL CHKEND            Seed provider?
[0888] A318 63,26           BS   RNDM1             No
[0889]               * RANDOMIZE given a see value
[0890]               * (99,000,000,000,001 possible starting positions)
[0891]               * (Place-value is ignored in the input number)
[0892] A31A 0F,74           XML  PARSE             Parse the seed
[0893] A31C 83              BYTE TREMZ           * Up to end of statement
[0894] A31D 06,A3,2C        CALL CKSTNM
[0895]               * TI BASIC RAMDOMIZE SEED ***
[0896] A320 BD,80,C0        DST @FAC,@>83C0 Quotation on random number seed
       A323 4A
[0897] A324 0F,75    NRNDCT XML  CONT
[0898]              
[0899]               * TI BASIC RANDOMIZE no seed ***
[0900] A326 BC,80,C1 RNDM1  ST   @>8379,@>83C1
       A329 79
[0901] A32A 0F,75           XML  CONT
[0902] A32C D6,4C,65 CKSTNM CEQ  >65,@FAC2
[0903] A32F 6C,8A           BS   ERRSNM
[0904] A331 00              RTN
[0905]               ***********************************************************
[0906] A332 40,01,00 FLT1   BYTE >40,>01,>00,>00,>00,>00,>00,>00
       A335 00,00,00
       A338 00,00
[0907]               ***********************************************************
[0908]               *                 EXTENDED STRING PACKAGE
[0909]               * THE ROUTINES ARE:
[0910]               *  LITS05 - Move a string literal from the program to the
[0911]               *            string space
[0912]               *  INTARG - Checks that an argument is a numeric and
[0913]               *            converts it from floating point to an integer
[0914]               *  PUSSTR - Checks that an argument is a string and pushes
[0915]               *            it on the stack

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0016 
RXB 2024
[0916]               *  CONCAT - Concatenates 2 strings together
[0917]               *  SEG$   - Segments a string
[0918]               *  LEN    - Puts the length of a string in the FAC
[0919]               *  CHR$   - Converts an integer into its ASCII character
[0920]               *  STR$   - Converts a number into its string equivalent
[0921]               *  VAL    - Converts a string into its numeric equivalent
[0922]               *  POS    - Gives the position of one string within another
[0923]               *  RPT$   - Generates a single string with multiple copies
[0924]               *            of the original string
[0925]               *
[0926]               *      AN ENTRY IN THE FAC LOOKS LIKE:
[0927]               * +------------+-----+----+-------------+-----------------+
[0928]               * |addr of ptr | >65 | xx | addr of str | length of str   |
[0929]               * +------------+-----+----+-------------+-----------------+
[0930]               *     FAC       FAC2  FAC3   FAC4           FAC6
[0931]               ***********************************************************
[0932]               * Support routine for functions to build FAC entry
[0933] A33A 86,50    LITS05 CLR  @FAC6             Need as a double-byte value
[0934] A33C BD,0C,50        DST  @FAC6,@BYTES      LENGTH FOR GETSTR
[0935] A33F BC,52,80        ST   @RAMTOP,@FAC8     Copy ERAM flag for later
       A342 84
[0936] A343 0F,71    LITS07 XML  GETSTR            ALLOCATE STRING SPACE
[0937] A345 BF,4A,00 LITS08 DST  >001C,@FAC        SAVE ADDR OF STRING  (SREF)
       A348 1C
[0938] A349 BD,4E,1C        DST  @SREF,@FAC4       SAVE ADDR OF STRING
[0939] A34C BF,4C,65        DST  >6500,@FAC2       INDICATES A STRING CONSTANT
       A34F 00
[0940]               *********** COPY STRING INTO STRING SPACE *****************
[0941] A350 8F,0C    LITS09 DCZ  @BYTES            If non-null string
[0942] A352 63,6A           BS   GA42B
[0943] A354 8E,52           CZ   @FAC8
[0944] A356 43,5F           BR   GA420
[0945] A358 34,0C,B0        MOVE @BYTES,V*TEMP5,V*SREF
       A35B 1C,B0,66
[0946] A35E 00              RTN
[0947]               *                             Else source string in ERAM
[0948] A35F BD,56,0C GA420  DST  @BYTES,@FFF1      FFF1 : BYTE COUNT
[0949] A362 BD,58,1C        DST  @SREF,@EEE1       EEE1 : DESTINATION ADDR ON VD
[0950] A365 BD,54,66        DST  @TEMP5,@DDD1      DDD1 : Source addr in ERAM
[0951] A368 0F,8B           XML  GVWITE            Move data from ERAM to VDP
[0952] A36A 00       GA42B  RTN
[0953] A36B 86,52    LITS06 CLR  @FAC8             SET FLAG TO VDP
[0954] A36D 43,43           BR   LITS07            JUMP INTO CODE
[0955]               ***********************************************************
[0956]               * PUSSTR - Insures that the entry in the FAC is a string
[0957]               *           and pushes it onto the stack.
[0958]               ***********************************************************
[0959] A36F D6,4C,65 PUSSTR CEQ  >65,@FAC2
[0960] A372 4C,8A           BR   ERRSNM
[0961] A374 0F,77           XML  VPUSH             PUSH THE ARGUMENT
[0962] A376 00              RTN
[0963]               ***********************************************************
[0964]               * CONCAT - CONCATENATES TWO STRINGS TOGETHER
[0965]               *         INPUT  : FLOATING POINT ACCUMULATOR ENTRIES
[0966]               *         OUTPUT : CONCATENATED STRING AND (POSSIBLE)
[0967]               *                  ZEROED BACK-POINTERS FOR THE OLD STRINGS
[0968]               *         USES   : TEMP2, TEMP4 AND TEMP5 AS TEMPORARIES
[0969]               ***********************************************************
[0970] A377 86,23    CONCAT CLR  @ERRCOD+1         CLEAR THE ERROR CODE
[0971] A379 06,A3,6F        CALL PUSSTR            Push the string & get next to
[0972] A37C 0F,74           XML  PARSE             GET THE R.H. ARGUMENT
[0973] A37E B8              BYTE CONCZ
[0974] A37F D6,4C,65        CEQ  >65,@FAC2         If not string - error
[0975] A382 4C,8A           BR   ERRSNM

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0017 
RXB 2024
[0976] A384 BD,0C,50        DST  @FAC6,@BYTES      GET R.H. LENGTH
[0977] A387 A1,0C,E0        DADD V@6(@VSPTR),@BYTES    ADD IN L.H. LENGTH
       A38A 06,6E
[0978] A38C C7,0C,00        DCH  255,@BYTES
       A38F FF
[0979] A390 43,9A           BR   GA45B
[0980] A392 BF,0C,00        DST  255,@BYTES        TRUNCATE IF TOO LONG
       A395 FF
[0981] A396 06,6A,82 WRNST1 CALL WARNZZ            Display warning
[0982] A399 13              BYTE 19                * STRING TRUNCATED message
[0983] A39A BD,68,0C GA45B  DST  @BYTES,@TEMP6     Keep length for later
[0984] A39D 0F,77           XML  VPUSH
[0985] A39F 0F,71           XML  GETSTR            Alloccate the result string
[0986] A3A1 0F,78           XML  VPOP              Retrieve R.H.
[0987] A3A3 35,00,08        MOVE 8,@FAC,@ARG
       A3A6 5C,4A
[0988] A3A8 0F,78           XML  VPOP              Retrieve L.H.
[0989] A3AA BD,66,4E        DST  @FAC4,@TEMP5      Set ptr to L.H. ARG(for FREST
[0990] A3AD BD,0C,50        DST  @FAC6,@BYTES      Length of L.H. ARG
[0991] A3B0 86,52           CLR  @FAC8             Force VDP mode
[0992] A3B2 06,A3,45        CALL LITS08            Set up FAC & copy L.H. ARG in
[0993] A3B5 8F,62           DCZ  @ARG6             If R.H. =0 don't copy
[0994] A3B7 63,CD           BS   CONC06
[0995] A3B9 BD,64,1C        DST  @SREF,@TEMP4      Get ptr to new string
[0996] A3BC A1,64,50        DADD @FAC6,@TEMP4      Ptr to where 2nd string begin
[0997] A3BF A5,68,50        DSUB @FAC6,@TEMP6      Length of 2nd string
[0998]               *                                      (possibly truncated)
[0999] A3C2 63,CD           BS   CONC06
[1000] A3C4 34,68,B0        MOVE @TEMP6,V*ARG4,V*TEMP4     Copy in 2nd string
       A3C7 64,B0,60
[1001]                
[1002] A3CA A1,50,68        DADD @TEMP6,@FAC6      Add in length of 2nd ARG
[1003]               * NOTE: FAC6 already contained length of 1st ARG from the
[1004]               *       parse that was done on it
[1005] A3CD 0F,75    CONC06 XML  CONT              Done.
[1006]               ***********************************************************
[1007]               * SEG$(A$,X,Y) - Extracts the desiginated string from A$.
[1008]               *     X specifies the character position within A$ at
[1009]               *     which the extraction begins. Y specifies the number
[1010]               *     of characters to extract.
[1011]               *     If X or Y is negative an error occurs. If X=0 an
[1012]               *     error occurs. If Y=0 or X > Y then a null string is
[1013]               *     is returned. If the ramaining length in A$ starting
[1014]               *     at the postion specified by X is less than the length
[1015]               *     specified by Y, then the remainder of A$ starting at
[1016]               *     position X is returned.
[1017]               *   INPUT - Control is turned over to SEG$ from PARSE. The
[1018]               *     only requirement is that a SEG$ was encountered.
[1019]               *   OUTPUT - The Floating Point Accumulator is set up with
[1020]               *     the header for the segmented string.
[1021]               *   USES - TEMP2 (Others in calls to GETSTR and LITS08)
[1022]               ***********************************************************
[1023] A3CF 06,AB,92 SEGZ01 CALL LPARR             Insure "(" parse and check ",
[1024] A3D2 06,A3,6F        CALL PUSSTR            Push string and get next toke
[1025] A3D5 0F,7E           XML  SPEED             Get the position
[1026] A3D7 01              BYTE PARCOM       *     within the source string
[1027] A3D8 06,A9,06        CALL INTARG            CHECK & CONVERT ARG TO INTEGE
[1028] A3DB 8F,4A           DCZ  @FAC               CAN'T HAVE VALUE OF 0
[1029] A3DD 6C,BA           BS   ERRBV
[1030] A3DF 0F,77           XML  VPUSH             PUSH THE ARG
[1031] A3E1 0F,74           XML  PARSE             Get extraction length
[1032] A3E3 B6              BYTE RPARZ
[1033] A3E4 0F,7E           XML  SPEED             Must have
[1034] A3E6 00              BYTE SYNCHK       *     ended on

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0018 
RXB 2024
[1035] A3E7 B6              BYTE RPARZ        *      a right parenthesis
[1036] A3E8 06,A9,06        CALL INTARG            CHECK & CONVERT ARG TO INTEGE
[1037] A3EB BD,5C,4A        DST  @FAC,@ARG         Move extraction length
[1038] A3EE 0F,78           XML  VPOP              Get position back
[1039] A3F0 BD,5E,4A        DST  @FAC,@ARG2        Move position
[1040] A3F3 0F,78           XML  VPOP              Retrieve source string
[1041] A3F5 BD,56,5E        DST  @ARG2,@TEMP2      Get position within string
[1042] A3F8 C5,56,50        DCH  @FAC6,@TEMP2      If position > length =>null
[1043] A3FB 64,2E           BS   SEGZ08
[1044] A3FD A1,56,5C        DADD @ARG,@TEMP2       Compute end of substring
[1045] A400 A5,56,50        DSUB @FAC6,@TEMP2      Compute length beyond end
[1046] A403 93,56           DDEC @TEMP2             string
[1047] A405 D3,56,00        DCGE 0,@TEMP2
       A408 00
[1048] A409 44,13           BR   SEGZ06            Fine if substring is shorter
[1049] A40B BD,5C,50        DST  @FAC6,@ARG        Else, truncate length of
[1050]               *                              substring
[1051] A40E A5,5C,5E        DSUB @ARG2,@ARG        Subtract position from source
[1052]               *                              length
[1053] A411 91,5C           DINC @ARG              Increment to include last cha
[1054] A413 BD,0C,5C SEGZ06 DST  @ARG,@BYTES       # of bytes needed for substri
[1055] A416 0F,77           XML  VPUSH             Save source string entry
[1056] A418 0F,71           XML  GETSTR            ALLOCATE RESULT STRING
[1057] A41A 0F,78           XML  VPOP              Restore source string entry
[1058] A41C BD,66,4E        DST  @FAC4,@TEMP5      Pointer to source for FRESTR
[1059]               *                              LITS08
[1060] A41F A1,66,5E        DADD @ARG2,@TEMP5      Pointer to start of substring
[1061] A422 93,66           DDEC @TEMP5            Decrement since zero-based
[1062] A424 BD,50,0C        DST  @BYTES,@FAC6      Set length of string
[1063] A427 86,52           CLR  @FAC8             FORCE VDP MODE
[1064] A429 06,A3,45        CALL LITS08            Copy in & set up FAC
[1065] A42C 0F,75           XML  CONT
[1066] A42E 87,5C    SEGZ08 DCLR @ARG              Extract a null string
[1067] A430 44,13           BR   SEGZ06            >>>JUMP ALWAYS<<<
[1068]               ***********************************************************
[1069]               * LEN(A$) - Calculate the length of a string and leave the
[1070]               *           result in the FAC.
[1071]               *  CONTROL - Turned over to NLEN from the parser.
[1072]               *  USES    - No temporaries.
[1073]               ***********************************************************
[1074] A432 06,A4,A4 LEN01  CALL PARFF             Insure left parenthesis & par
[1075] A435 4C,8A           BR   ERRSNM             If not string value
[1076] A437 BD,4A,50        DST  @FAC6,@FAC        Length
[1077] A43A 0F,80    LEN02  XML  CIF               Convert integer to floating p
[1078] A43C 0F,75           XML  CONT
[1079]               ***********************************************************
[1080]               * CHR$(X) - Takes integer value X and converts the number
[1081]               *           into the ASCII representation for that number.
[1082]               *  CONTROL - Turned over to NCHR by the parser.
[1083]               *  OUTPUT  - FAC is set up with the string entry
[1084]               *  USES    - Uses temproraries when invoking LITS06(LITSTR)
[1085]               ***********************************************************
[1086] A43E 06,A4,A4 CHRZ01 CALL PARFF             Insure left parenthesis & par
[1087] A441 06,A9,06        CALL INTARG            Convert into integer
[1088] A444 BF,0C,00        DST  1,@BYTES          Create a length 1 string
       A447 01
[1089] A448 BC,A3,78        ST   @FAC1,V@ONECHR    Move the value to VDP(for LIT
       A44B 4B
[1090] A44C BF,66,03        DST  ONECHR,@TEMP5     Address of character
       A44F 78
[1091] A450 06,A3,6B        CALL LITS06            Create string and set up FAC
[1092] A453 BF,50,00        DST  1,@FAC6           Length of string
       A456 01
[1093] A457 0F,75           XML  CONT

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0019 
RXB 2024
[1094]               ***********************************************************
[1095]               * ASC(A$) - Takes the numeric value of the first character
[1096]               *           in A$.
[1097]               ***********************************************************
[1098] A459 06,A4,A4 ASC01  CALL PARFF             Insure left parenthesis & par
[1099] A45C 4C,8A           BR   ERRSNM             If not string
[1100] A45E 8E,51           CZ   @FAC7             Bad Argument?
[1101] A460 6C,B6           BS   ERRBA
[1102] A462 BC,4B,B0        ST   V*FAC4,@FAC1      Get the first character
       A465 4E
[1103] A466 86,4A           CLR  @FAC
[1104] A468 44,3A           BR   LEN02             USE COMMON CODE >>>JUMP ALWAY
[1105]               ***********************************************************
[1106]               * STR$(X) - Takes as its imput an integer X and converts it
[1107]               *           to its string representation.
[1108]               *  CONTROL - Turned over to STR$ by the parser.
[1109]               *  USES    - The usual temporaries used by string function
[1110]               *            when it calls LITS06. Uses the Roll-out area
[1111]               *            for a temporary storage area when allocating
[1112]               *            the result string.
[1113]               *  OUTPUT  - FAC is set up in the usual manner for a string
[1114]               ***********************************************************
[1115] A46A 06,A4,A4 STRZ01 CALL PARFF             Insure left parenthesis & par
[1116] A46D 6C,8A           BS   ERRSNM             If not numeric-error
[1117] A46F 86,55           CLR  @FAC11            Select XB floating type
[1118] A471 0F,73           XML  XBCNS             Convert the number to string
[1119] A473 D6,90,55        CEQ  SPACE,*FAC11      If leading space
       A476 20
[1120] A477 44,7D           BR   GA53E
[1121] A479 90,55           INC  @FAC11            Suppress it out
[1122] A47B 92,56           DEC  @FAC12            Shorten the length
[1123] A47D 86,0C    GA53E  CLR  @BYTES            Prepare for 2-byte value
[1124] A47F BC,0D,56        ST   @FAC12,@BYTES+1   Get length of string
[1125] A482 34,0C,A3        MOVE @BYTES,*FAC11,V@VROAZ    Put the string in VDP
       A485 C0,90,55
[1126] A488 BF,66,03        DST  VROAZ,@TEMP5      Copy-from address(for LITSTR)
       A48B C0
[1127] A48C 06,A3,6B        CALL LITS06            Allocate and set up FAC
[1128] A48F BD,50,0C        DST  @BYTES,@FAC6      Put in the length
[1129] A492 0F,75           XML  CONT
[1130]               ***********************************************************
[1131]               * VAL(A$) - Takes as its input a string, A$, and converts
[1132]               *           the string into a number if the string is a
[1133]               *           valid representation of a number.
[1134]               *  CONTROL - From the parser.
[1135]               *  OUTPUT  - FAC contains the floating point number.
[1136]               ***********************************************************
[1137] A494 06,A4,A4 VAL01  CALL PARFF             Insure left parenthesis & par
[1138] A497 4C,8A           BR   ERRSNM             If not string - error
[1139] A499 8E,51           CZ   @FAC7             Can't have null string
[1140] A49B 6C,B6           BS   ERRBA
[1141] A49D 06,A4,AE        CALL VALCD             So bad argument error
[1142] A4A0 6C,B6           BS   ERRBA
[1143] A4A2 0F,75           XML  CONT
[1144]               * Short routine to parse a single argument enclosed in
[1145]               *  parenthesis for a function or a subprogram and set
[1146]               *  condition based upon whether the value parsed was a
[1147]               *  string or a numeric.
[1148] A4A4 06,A9,67 PARFF  CALL COMB              (?
[1149] A4A7 0F,74           XML  PARSE
[1150] A4A9 FF              BYTE >FF               *
[1151] A4AA D6,4C,65        CEQ  >65,@FAC2
[1152] A4AD 01              RTNC
[1153] A4AE BD,66,4E VALCD  DST  @FAC4,@TEMP5      Pointer to string

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0020 
RXB 2024
[1154] A4B1 A1,66,50        DADD @FAC6,@TEMP5      Pointer to trailing length by
[1155] A4B4 BD,0C,50        DST  @FAC6,@BYTES      For suppressing trailing blan
[1156] A4B7 91,0C           DINC @BYTES            Prepare for undue subtraction
[1157] A4B9 93,66    GA57C  DDEC @TEMP5            Keep track of end of string
[1158] A4BB 93,0C           DDEC @BYTES            Decrease length of string
[1159] A4BD 64,F6           BS   RTNSET            End up with empty string,
[1160] A4BF D6,B0,66        CEQ  SPACE,V*TEMP5     Wild trailing blanks
       A4C2 20
[1161] A4C3 64,B9           BS   GA57C
[1162] A4C5 91,0C           DINC @BYTES            Allow for terminator
[1163] A4C7 0F,77           XML  VPUSH             Save the ptr to the string
[1164] A4C9 0F,71           XML  GETSTR            Get a new string
[1165] A4CB 0F,78           XML  VPOP              Retrieve the ptr to the strin
[1166] A4CD BD,66,4E        DST  @FAC4,@TEMP5      Get the ptr to the string
[1167] A4D0 86,52           CLR  @FAC8             Force VDP mode
[1168] A4D2 06,A3,50        CALL LITS09            Copy the string and set up FA
[1169] A4D5 A1,0C,1C        DADD @SREF,@BYTES      Point to the trailing length
[1170] A4D8 93,0C           DDEC @BYTES            Point at the last character
[1171] A4DA BE,B0,0C        ST   SPACE,V*BYTES     Put in the terminator
       A4DD 20
[1172] A4DE BD,56,1C        DST  @SREF,@FAC12      Address for the conversion
[1173] A4E1 D6,B0,56 GA5A4  CEQ  SPACE,V*FAC12     While leading spaces
       A4E4 20
[1174] A4E5 44,EB           BR   GA5AE
[1175] A4E7 91,56           DINC @FAC12            Skip leading blank
[1176] A4E9 44,E1           BR   GA5A4
[1177] A4EB 86,4C    GA5AE  CLR  @FAC2             Get rid of string (in case=0)
[1178] A4ED 86,54           CLR  @FAC10            Assume no error
[1179] A4EF 0F,10           XML  CSNUM             Convert it
[1180] A4F1 D5,56,0C        DCEQ @BYTES,@FAC12     Convert all of it?
[1181] A4F4 68,2E           BS   WRNNO             Yes, check overflow & return
[1182] A4F6 D4,00,00 RTNSET CEQ  @PAD,@PAD         No, return with condition set
[1183] A4F9 01              RTNC
[1184]               ***********************************************************
[1185]               * POS(A$,B$,X) - Attempts to match the string, B$, in A$
[1186]               *    beginning at character # X in A$. If X is > LEN(A$), a
[1187]               *    match is not found or A$ is the null string then the
[1188]               *    returned value is 0. If B$ is the null string then the
[1189]               *    returned value is 1. Otherwise, the returned value is
[1190]               *    the column # of the 1st character matched in A$
[1191]               *  CONTROL - Fromn the parser. Returned through common code
[1192]               *            IN LEN.
[1193]               *  USES    - Not temporaries - Utilizes FAC and ARG.
[1194]               ***********************************************************
[1195] A4FA 06,AB,92 POS01  CALL LPARR             Insure "(", parse , insure ",
[1196] A4FD 06,A3,6F        CALL PUSSTR            STACK THE STRING AND GET TOKE
[1197] A500 0F,7E           XML  SPEED             Parse the match string and
[1198] A502 01              BYTE PARCOM      *      insure end on comma
[1199] A503 06,A3,6F        CALL PUSSTR            STACK THE STRING AND GET TOKE
[1200] A506 0F,74           XML  PARSE             Get position
[1201] A508 B6              BYTE RPARZ
[1202] A509 0F,7E           XML  SPEED             Must have
[1203] A50B 00              BYTE SYNCHK          *  ended on a
[1204] A50C B6              BYTE RPARZ           *   right parenthesis
[1205] A50D 06,A9,06        CALL INTARG            Check and convert it
[1206] A510 8F,4A           DCZ  @FAC              Value out of range
[1207] A512 6C,BA           BS   ERRBV
[1208] A514 BD,0C,4A        DST  @FAC,@BYTES       Keep the offset
[1209] A517 93,0C           DDEC @BYTES            Correct for position 0
[1210] A519 0F,78           XML  VPOP              Get match string back
[1211] A51B 35,00,08        MOVE 8,@FAC,@ARG       Put match in ARG
       A51E 5C,4A
[1212] A520 0F,78           XML  VPOP              Get source back
[1213] A522 8E,51           CZ   @FAC7             If source null

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0021 
RXB 2024
[1214] A524 65,61           BS   POS12
[1215] A526 C4,51,0D        CH   @BYTES+1,@FAC7    OFFSET > LENGTH?
[1216] A529 45,61           BR   POS12             Yes, no match possible
[1217] A52B 8E,63           CZ   @ARG7             If null string
[1218] A52D 65,52           BS   POS06
[1219] A52F A1,4E,0C        DADD @BYTES,@FAC4      Adjust ptr for offset
[1220] A532 A4,51,0D        SUB  @BYTES+1,@FAC7    Adjust length
[1221] A535 C8,51,63 POS02  CHE  @ARG7,@FAC7       Enough space left for a match
[1222] A538 45,61           BR   POS12             No, no match possible
[1223] A53A BD,4A,4E        DST  @FAC4,@FAC        Get first ARG
[1224] A53D BD,5C,60        DST  @ARG4,@ARG        Get second ARG
[1225] A540 BC,64,63        ST   @ARG7,@ARG8       And length of second
[1226] A543 D4,B0,5C POS04  CEQ  V*FAC,V*ARG       Compare the characters
       A546 B0,4A
[1227] A548 45,59           BR   POS10             Didn't match
[1228] A54A 91,4A           DINC @FAC              Next in source
[1229] A54C 91,5C           DINC @ARG              Next in match
[1230] A54E 92,64           DEC  @ARG8             Reached end of match?
[1231] A550 45,43           BR   POS04             Not yet, so loop
[1232] A552 90,0D    POS06  INC  @BYTES+1          Matched! Correct for 1 index
[1233] A554 BD,4A,0C POS08  DST  @BYTES,@FAC       Character position of match
[1234] A557 44,3A           BR   LEN02             Convert to floating point
[1235]               * NOTE: Utilizes the LEN code to do the conversion and
[1236]               *       finish up.
[1237] A559 90,0D    POS10  INC  @BYTES+1          Step index of match character
[1238] A55B 92,51           DEC  @FAC7             Move 1 position down 1st
[1239] A55D 91,4E           DINC @FAC4              Argument
[1240] A55F 45,35           BR   POS02             Try to match again
[1241]               * JUMP ALWAYS
[1242] A561 86,0D    POS12  CLR  @BYTES+1          NO MATCH POSSIBLE
[1243] A563 45,54           BR   POS08
[1244]               ***********************************************************
[1245]               * RPT$(A$,X) - Creates a string consisting of X copies of
[1246]               *              A$. If X is negative or non-numeric, an
[1247]               *              exception occurs. If A$ is not a string, an
[1248]               *              exception occurs.
[1249]               ***********************************************************
[1250] A565 06,AB,92 RPTZ01 CALL LPARR             Insure "(", parse, insure ","
[1251] A568 06,A3,6F        CALL PUSSTR            Insure a string and push it
[1252] A56B 0F,74           XML  PARSE             Parse second argument
[1253] A56D B6              BYTE RPARZ
[1254] A56E 0F,7E           XML  SPEED             Must have
[1255] A570 00              BYTE SYNCHK       *     ended on a
[1256] A571 B6              BYTE RPARZ        *      right parenthesis
[1257] A572 06,A9,06        CALL INTARG            Check numeric and convert
[1258] A575 A9,4A,E0        DMUL V@6(@VSPTR),@FAC  Compute result length
       A578 06,6E
[1259] A57A 8F,4B           DCZ  @FAC1
[1260] A57C 65,86           BS   GA649
[1261] A57E 06,6A,82 WRNST2 CALL WARNZZ            Give truncation message
[1262] A581 13              BYTE 19                * STRING TRUNCATED message
[1263] A582 BF,4C,00        DST  255,@FAC2         Make it a maximum string
       A585 FF
[1264] A586 BD,0C,4C GA649  DST  @FAC2,@BYTES      Copy requested string length
[1265] A589 0F,71           XML  GETSTR            Get the new string
[1266] A58B 0F,78           XML  VPOP              Retrieve the original string
[1267]               * At this point BYTES should still contain the length
[1268] A58D BD,5C,50        DST  @FAC6,@ARG        Copy original length in ARG
[1269] A590 8F,0C           DCZ  @BYTES            Zero copies requested
[1270] A592 45,96           BR   GA659
[1271] A594 87,5C           DCLR @ARG              So we copy zero!!!!!!!
[1272] A596 C1,0C,5C GA659  DEX  @ARG,@BYTES       Original length to BYTE
[1273] A599 BD,66,4E        DST  @FAC4,@TEMP5      And also original start addr
[1274] A59C 86,52           CLR  @FAC8             Clear flag for LITS08

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0022 
RXB 2024
[1275] A59E 06,A3,45        CALL LITS08            Create FAC and copy on copy
[1276]               * ARG contains total length now.
[1277] A5A1 BD,50,5C        DST  @ARG,@FAC6        Store new length
[1278] A5A4 A5,5C,0C RPTZ02 DSUB @BYTES,@ARG       Subtract one copy
[1279] A5A7 8F,5C           DCZ  @ARG              <<<<<THE WAY OUT
[1280] A5A9 65,C1           BS   XMLCON
[1281] A5AB A1,1C,0C        DADD @BYTES,@SREF      Compute new start address
[1282] A5AE C5,0C,5C        DCH  @ARG,@BYTES
[1283] A5B1 45,B6           BR   GA679
[1284] A5B3 BD,0C,5C        DST  @ARG,@BYTES       Truncate string
[1285] A5B6 34,0C,B0 GA679  MOVE @BYTES,V*TEMP5,V*SREF
       A5B9 1C,B0,66
[1286] A5BC 45,A4           BR   RPTZ02
[1287]               ***********************************************************
[1288]               *                   TRACE STATEMENT
[1289]               ***********************************************************
[1290] A5BE B6,45,10 NTRACE OR   >10,@FLAG         Set the trace bit
[1291] A5C1 0F,75    XMLCON XML  CONT              Continue on
[1292]               ***********************************************************
[1293]               *                 UNTRACE STATEMENT
[1294]               ***********************************************************
[1295] A5C3 B2,45,EF NUNTRC AND  >EF,@FLAG         Reset the trace bit
[1296] A5C6 0F,75           XML  CONT              Continue on
[1297]               ***********************************************************
[1298]               *          BREAK AND UNBREAK STATEMENTS
[1299]               ***********************************************************
[1300] A5C8 BE,5C,FF NBREAK ST   >FF,@ARG          BREAK flag
[1301] A5CB 06,6A,78        CALL CHKEND            Check for end of statement
[1302] A5CE 45,E1           BR   LINEGP            If not goto LINEGP
[1303] A5D0 93,2C           DDEC @PGMPTR           Back up so CON will rescan en
[1304] A5D2 8E,44           CZ   @PRGFLG           Rative without line #
[1305] A5D4 41,1B           BR   EXEC6C
[1306] A5D6 06,6A,84 ERROLP CALL ERRZZ             Only legal in a program
[1307] A5D9 1B              BYTE 27
[1308] A5DA 86,5C    NUNBRK CLR  @ARG              UNBREAK flag for common
[1309] A5DC 06,6A,78        CALL CHKEND            Check for end of statement
[1310] A5DF 66,34           BS   UNBK01            If end then goto UNBK01
[1311] A5E1 06,A8,10 LINEGP CALL LINE              Get line #
[1312] A5E4 BD,5E,32        DST  @ENLN,@ARG2
[1313] A5E7 A7,5E,00        DSUB >03,@ARG2         1st line #
       A5EA 03
[1314] A5EB C9,5E,30 LNGP1  DCHE @STLN,@ARG2       If line not found
[1315] A5EE 46,2E           BR   WRNLNF
[1316] A5F0 06,80,2E        CALL GRSUB3            Read line # of data from ERAM
[1317] A5F3 5E              BYTE >5E           *   (use GREAD1) or VDP
[1318]               * @ARG2: Source addr in ERAM/VDP, reset possible breakpoint
[1319] A5F4 D5,58,4A        DCEQ @FAC,@EEE1        If line found
[1320] A5F7 65,FF           BS   LNGP2
[1321] A5F9 A7,5E,00        DSUB 4,@ARG2           Next line in VDP or ERAM
       A5FC 04
[1322] A5FD 45,EB           BR   LNGP1
[1323]               * JUMP ALWAYS
[1324] A5FF 8E,80,84 LNGP2  CZ   @RAMTOP           If ERAM exists
[1325] A602 66,17           BS   GA6DA
[1326] A604 B2,58,7F        AND  >7F,@EEE1         Assume UNBREAK flag
[1327] A607 8E,5C           CZ   @ARG              If BREAK flag
[1328] A609 66,0E           BS   GA6D1
[1329] A60B B6,58,80        OR   >80,@EEE1         Set the breakpoint
[1330] A60E 06,60,36 GA6D1  CALL GWSUB             Write a few bytes of data to
[1331]               *                              ERAM (use GWRITE)
[1332] A611 5E,58,01        BYTE >5E,>58,>01     * ARG2,EEE1,1
[1333]               *                            @ARG2: Destination addr on ERA
[1334]               *                            @EEE1: Data
[1335]               *                            1    : Byte count

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0023 
RXB 2024
[1336] A614 05,A6,23        B    LNGP2B
[1337] A617 B2,B0,5E GA6DA  AND  >7F,V*ARG2        Assume UNBREAK flag first
       A61A 7F
[1338] A61B 8E,5C           CZ   @ARG              If BREAK flag
[1339] A61D 66,23           BS   LNGP2B
[1340] A61F B6,B0,5E        OR   >80,V*ARG2        Set the breakpoint
       A622 80
[1341] A623 06,6A,78 LNGP2B CALL CHKEND            Check for end of statement
[1342] A626 66,37           BS   LNGP4             If end then continue
[1343] A628 0F,7E           XML  SPEED             Must be
[1344] A62A 00              BYTE SYNCHK         *     at a
[1345] A62B B3              BYTE COMMAZ         *       comma now
[1346] A62C 45,E1           BR   LINEGP
[1347]               * JUMP ALWAYS
[1348] A62E 06,6A,82 WRNLNF CALL WARNZZ            Note: warning not error
[1349] A631 26              BYTE 38             *  'LINE NOT FOUND'
[1350] A632 46,23           BR   LNGP2B            And contiue on
[1351]               * JUMP ALWAYS
[1352] A634 06,A6,39 UNBK01 CALL UBSUB             Clear all bkpt in line # tabl
[1353] A637 0F,75    LNGP4  XML  CONT              Contiue
[1354]               *     CLEAR ALL BREAKPOINTS
[1355] A639 BD,52,30 UBSUB  DST  @STLN,@FAC8       END OF LINE # BUFFER
[1356] A63C 06,A6,49 GA6FF  CALL UBSUB1            Reset one line # at a time
[1357] A63F A3,52,00        DADD 4,@FAC8           Got to the next line
       A642 04
[1358] A643 C5,52,32        DCH  @ENLN,@FAC8       End of table
[1359] A646 46,3C           BR   GA6FF
[1360] A648 00              RTN
[1361] A649 06,80,2E UBSUB1 CALL GRSUB3            Read the line # from ERAM/VDP
[1362]               *                             Reset possible bkpt too
[1363] A64C 52              BYTE >52            *  @FAC8: Source addr on ERAM/VD
[1364] A64D 06,60,36        CALL GWSUB             Write a few bytes of data to
[1365]               *                              ERAM(use GWRITE) or VDP
[1366] A650 52,58,01        BYTE >52,>58,>01    *  FAC8,EEE1,1
[1367]               *                          @FAC8: Destination adr in ERAM/V
[1368]               *                          @EEE1: Data
[1369]               *                          1    : Byte count
[1370] A653 00              RTN
[1371]               ***********************************************************
[1372]               *                USER DEFINED FUNCTIONS
[1373]               * Subroutine to store away the information of the tokens in
[1374]               * a function reference, go into the 'DEF' statement,
[1375]               * calculate the value of the expression and then resume
[1376]               * execution of the user's program after the reference.
[1377]               * An entry in the FAC and on the stack for a function
[1378]               * reference looks like:
[1379]               * +--------+-----+---------------------+--------+---------+
[1380]               * | PGMPTR | >68 | string/numeric flag | SYMTAB | FREPTR  |
[1381]               * +--------+-----+---------------------+--------+---------+
[1382]               *  FAC      FAC2  FAC3                  FAC4     FAC6
[1383]               *
[1384]               * The 'PGMPTR' is where execution resumes after evaluating
[1385]               * the function. String (80)/numeric(00) flag is function
[1386]               * type. SYMTAB is the old symbol table pointer and FREPTR
[1387]               * is the old free space pointer. These are restored after
[1388]               * the function is evaluated.
[1389]               ***********************************************************
[1390] A654 8E,44    UDF    CZ   @PRGFLG           If imperative
[1391] A656 46,5D           BR   GA720
[1392] A658 8E,80,85        CZ   @RAMTOP+1         And ERAM, error
[1393] A65B 45,D6           BR   ERROLP
[1394] A65D 86,51    GA720  CLR  @FAC7             Assume no args
[1395] A65F 87,22           DCLR @ERRCOD           Clear the error code for cont
[1396] A661 86,5E           CLR  @ARG2             Safety for VPUSH

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0024 
RXB 2024
[1397] A663 86,4C           CLR  @FAC2             Sagety for VPUSH
[1398] A665 D6,42,B7        CEQ  LPARZ,@CHAT
[1399] A668 46,78           BR   GA73B
[1400] A66A 0F,77           XML  VPUSH             Save ptr to function definiti
[1401] A66C 0F,74           XML  PARSE             PARSE to get arg value
[1402] A66E FF              BYTE >FF
[1403] A66F 35,00,08        MOVE 8,@FAC,@ARG       Save PARSE result
       A672 5C,4A
[1404] A674 0F,78           XML  VPOP              Get S.T. ptr to function defi
[1405] A676 90,51           INC  @FAC7             Indicate theat we have an arg
[1406] A678 BC,66,51 GA73B  ST   @FAC7,@TEMP5      Move the parmeter count
[1407] A67B BD,64,4A        DST  @FAC,@TEMP4       S.T. ptr to definition
[1408] A67E 0F,77           XML  VPUSH             Allow room for UDF result
[1409] A680 35,00,08        MOVE 8,@ARG,@FAC       Retrieve parse result
       A683 4A,5C
[1410] A685 0F,77           XML  VPUSH             Save parse result
[1411] A687 BC,4C,B0        ST   V*TEMP4,@FAC2     Get S.T. declarations
       A68A 64
[1412] A68B BC,4D,4C        ST   @FAC2,@FAC3       Do this to save string bit
[1413]               * NOTE: THIS IS TO ALLOW THE CHECKING AFTER THE FUNCTION HA
[1414]               *       BEEN EVALUATED TO MAKE SURE THE FUNCTION
[1415]               *       TYPE (STRING/NUMERIC) MATCHES THE RESULT IT PRODUCE
[1416] A68E B2,4C,07        AND  >07,@FAC2         Mask all but # of parameters
[1417] A691 D4,4C,66        CEQ  @TEMP5,@FAC2
[1418] A694 4C,BE           BR   ERRIAL
[1419]               * Incorrect argument list error above.
[1420] A696 BD,4A,2C        DST  @PGMPTR,@FAC      Will resume execution here
[1421] A699 BE,4C,70        ST   >70,@FAC2         Entering parameter into symbo
[1422]               *                    table while in UDF statement executing
[1423] A69C B2,4D,80        AND  >80,@FAC3         Mask all but string bit
[1424] A69F A7,6E,00        DSUB 16,@VSPTR         Get below parse result
       A6A2 10
[1425]                
[1426] A6A3 BD,4E,3E        DST  @SYMTAB,@FAC4     Save current symbol table ptr
[1427] A6A6 BD,50,40        DST  @FREPTR,@FAC6     Save current free space ptr
[1428] A6A9 0F,77           XML  VPUSH             Save the return info
[1429] A6AB A3,6E,00        DADD 8,@VSPTR          Get back to parse result
       A6AE 08
[1430]               *********** SHIFT EXECUTION TO FUNCTION DEFINITION ********
[1431] A6AF BD,2C,E0        DST  V@6(@TEMP4),@PGMPTR    Set text ptr to definiti
       A6B2 06,64
[1432] A6B4 0F,79           XML  PGMCHR            Get 1st character in the defi
[1433] A6B6 C6,73,A4        CH   >A4,@SUBSTK       Stack overflow
[1434] A6B9 6C,96           BS   ERRSO
[1435] A6BB 35,00,18        MOVE 24,@PAD,V@VROAZ   Roll out temporaries
       A6BE A3,C0,00
[1436] A6C1 B6,45,08        OR   >08,@FLAG         Set function flag for ENTER
[1437] A6C4 BE,16,80        ST   >80,@XFLAG        Make calls look like ENTERX
[1438] A6C7 D6,42,BE        CEQ  EQUALZ,@CHAT
[1439] A6CA 46,D9           BR   GA79C
[1440]               * NOTE: This is to keep the global/local variables correct
[1441]               *       the event that a function uses another function in
[1442]               *       its evaluation.
[1443] A6CC 86,59           CLR  @FAC15            Create a dummy entry in table
[1444] A6CE 06,6A,80        CALL ENT09              for no-paremter function
[1445] A6D1 97,2C           DDECT @PGMPTR          Back up to equal sign
[1446] A6D3 86,E0,02        CLR  V@2(@VSPTR)       This is to keep ASSGNV(called
       A6D6 6E
[1447]               *                              below) not to screw up in
[1448]               *                              case FAC2 happens to have a
[1449]               *                              value (greater) >65
[1450] A6D7 46,DC           BR   GA79F
[1451] A6D9 06,6A,7E GA79C  CALL ENTER             Enter the parameter
[1452] A6DC 0F,79    GA79F  XML  PGMCHR            Get the '=' (Checked in PSCAN

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0025 
RXB 2024
[1453] A6DE B2,45,F7        AND  >F7,@FLAG         Reset to normal ENTERs
[1454] A6E1 35,00,18        MOVE 24,V@VROAZ,@>8300
       A6E4 00,A3,C0
[1455] A6E7 BE,EF,FF        ST   >68,V@-6(@VSPTR)  Correct stack entry ID
       A6EA FA,6E,68
[1456] A6ED BD,E0,02        DST  V@SYMBOL,V@2(@SYMTAB)  Fudge link to
       A6F0 3E,A3,76
[1457]               *                                   get global values
[1458] A6F3 BD,4A,3E        DST  @SYMTAB,@FAC      Set up for SMB
[1459] A6F6 0F,7B           XML  SMB               Get value space
[1460] A6F8 35,00,08        MOVE 8,@FAC,@FAC8      Destination
       A6FB 52,4A
[1461] A6FD 0F,78           XML  VPOP              Get arg back
[1462] A6FF 35,00,08        MOVE 8,@FAC,@ARG       Argument value
       A702 5C,4A
[1463] A704 35,00,08        MOVE 8,@FAC8,@FAC      Destination
       A707 4A,52
[1464] A709 0F,77           XML  VPUSH             Push to destination
[1465] A70B 35,00,08        MOVE 8,@ARG,@FAC       Argument value
       A70E 4A,5C
[1466] A710 D6,4C,65        CEQ  >65,@FAC2         If a string
[1467] A713 47,1F           BR   GA7E2
[1468] A715 D7,4A,00        DCEQ >001C,@FAC        If not temp
       A718 1C
[1469] A719 67,1F           BS   GA7E2
[1470] A71B BD,4E,B0        DST  V*FAC,@FAC4       Get new location of string
       A71E 4A
[1471]               *                             Parameter was allocated in S.
[1472] A71F 0F,79    GA7E2  XML  PGMCHR            Skip the '='
[1473] A721 0F,7C           XML  ASSGNV            Assign the value to the param
[1474] A723 0F,74           XML  PARSE             PARSE to end of function defi
[1475] A725 83              BYTE TREMZ
[1476]               **** CHECK FOR TYPE MATCH (STRING/STRING OR NUM/NUM)*******
[1477]               **** BETWEEN THE RESULT AND THE FUNCTION TYPE *************
[1478] A726 D6,4C,65        CEQ  >65,@FAC2         If result string
[1479] A729 47,33           BR   GA7F6
[1480] A72B 8E,E0,03        CZ   V@3(@VSPTR)       If functional
       A72E 6E
[1481] A72F 6C,8A           BS   ERRSNM
[1482] A731 47,39           BR   GA7FC              not a string
[1483] A733 8E,E0,03 GA7F6  CZ   V@3(@VSPTR)       If functional
       A736 6E
[1484] A737 4C,8A           BR   ERRSNM
[1485]               ***** NOW RESTORE SYMBOL TABLE AND RESUME *****************
[1486]               ***** EXECUTION AT THE ORIGINAL LINE **********************
[1487] A739 06,A7,47 GA7FC  CALL DELINK            Delink the parameter entry
[1488] A73C BD,2C,E0        DST  V@8(@VSPTR),@PGMPTR Manual pop to get ptr back
       A73F 08,6E
[1489] A741 93,2C           DDEC @PGMPTR           Back up text pointer
[1490] A743 0F,79           XML  PGMCHR            Get next token
[1491] A745 0F,75           XML  CONT
[1492] A747 BD,66,3E DELINK DST  @SYMTAB,@TEMP5    Save addr of S.T. entry just
[1493]               *                             in case entry is a string
[1494]               *                             (must free the string)
[1495] A74A 35,00,04        MOVE 4,V@4(@VSPTR),@SYMTAB  Restore old symbol table
       A74D 3E,E0,04
       A750 6E
[1496]               *                             pointer and free space pointe
[1497]               *                             This handles the freeing of t
[1498]               *                             string value which was assign
[1499]               *                             to the parameter.
[1500] A751 D2,B0,66        CGE  0,V*TEMP5         If string parmeter
       A754 00
[1501] A755 67,89           BS   GA84C

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0026 
RXB 2024
[1502] A757 BD,66,E0        DST  V@6(@TEMP5),@TEMP5 Where the string is
       A75A 06,66
[1503] A75C 8F,66           DCZ  @TEMP5            If non-null string
[1504] A75E 67,70           BS   GA833
[1505] A760 BD,56,EF        DST  V@-3(@TEMP5),@TEMP2 Get backpointer
       A763 FF,FD,66
[1506] A766 C9,56,3E        DCHE @SYMTAB,@TEMP2    If not used
[1507] A769 67,70           BS   GA833
[1508] A76B 87,EF,FF        DCLR V@-3(@TEMP5)      Free up the string
       A76E FD,66
[1509]               * This handles the special case of F$(X$)=X$
[1510]               * The result, which was permanent, must be made a temp.
[1511] A770 D6,4C,65 GA833  CEQ  >65,@FAC2         If string result
[1512] A773 47,87           BR   GA84A
[1513] A775 C9,4A,3E        DCHE @SYMTAB,@FAC      If came from argument
[1514] A778 67,87           BS   GA84A
[1515] A77A 8F,4E           DCZ  @FAC4             If non-null
[1516] A77C 67,83           BS   GA846
[1517] A77E 87,EF,FF        DCLR V@-3(@FAC4)       Clear the backpointer
       A781 FD,4E
[1518] A783 BF,4A,00 GA846  DST  >001C,@FAC        Make it a temp
       A786 1C
[1519] A787 47,93    GA84A  BR   GA856             If numeric parameter
[1520] A789 8E,80,84 GA84C  CZ   @RAMTOP           If ERAM exist
[1521] A78C 67,93           BS   GA856
[1522] A78E A3,80,86        DADD 8,@RAMFRE         Remove 8 bytes of value
       A791 00,08
[1523] A793 A7,6E,00 GA856  DSUB 8,@VSPTR          Trash the stack entry
       A796 08
[1524] A797 00              RTN                    And retrun
[1525] A798 0F,74    ATTNUT XML  PARSE
[1526] A79A B6              BYTE RPARZ
[1527] A79B 06,A3,2C        CALL CKSTNM            CHECK FOR NUMERIC OR STRING
[1528] A79E 0F,7E           XML  SPEED             Insure argument is in
[1529] A7A0 02              BYTE RANGE          *   range of 0-30
[1530] A7A1 00              BYTE 0
[1531] A7A2 00,1E           DATA 30
[1532] A7A4 E6,4B,01        SRL  1,@FAC1           0,1 : 0000        ATTENUATION
[1533]               *                             2,3 : 0001
[1534]               *                             4,5 : 0010
[1535]               *                             6,7 : 0011        ETC...
[1536] A7A7 B6,4B,F0        OR   >F0,@FAC1         REGISTER BITS
[1537] A7AA 00              RTN
[1538]               ***********************************************************
[1539]               * SUBROUTINE TO SET POINTER TO EACH DATUM
[1540]               ***********************************************************
[1541] A7AB 93,36    DATAST DDEC @LNBUF            Point to 1st byte of line ptr
[1542] A7AD 06,80,2C        CALL GRSUB2            Read 2 bytes from VDP or ERAM
[1543] A7B0 36              BYTE LNBUF           *  (use GREAD1), @LNBUF: Source
[1544]               *                           *  address in ERAM or VDP
[1545] A7B1 BD,34,58        DST  @EEE1,@DATA       Put it in @DATA
[1546] A7B4 06,80,20        CALL SRDATA            Look for 'DATA' on the line
[1547] A7B7 47,C6           BR   DATST1            OK, FOUND ANOTHER 'DATA' STMT
[1548] A7B9 97,36           DDECT @LNBUF           NO
[1549] A7BB D5,36,30        DCEQ  @STLN,@LNBUF
[1550] A7BE 67,C4           BS   GA887
[1551] A7C0 93,36           DDEC @LNBUF            Point to 1st token address
[1552] A7C2 47,AB           BR   DATAST
[1553] A7C4 86,34    GA887  CLR  @DATA             Indicate no data
[1554] A7C6 00       DATST1 RTN
[1555]               ***********************************************************
[1556]               * Subroutine to get line number and goto routine to display
[1557]               * it on the screen.
[1558]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0027 
RXB 2024
[1559] A7C7 8E,80,89 ASC    CZ   @RAMFLG
[1560] A7CA 47,D4           BR   GA897
[1561] A7CC BD,5E,EF        DST  V@-2(@EXTRAM),@ARG2   Get line # in
       A7CF FF,FE,2E
[1562] A7D2 47,E2           BR   GA8A5
[1563] A7D4 BF,56,00 GA897  DST  2,@FFF1           @FFF1 : Byte count
       A7D7 02
[1564] A7D8 BD,54,2E        DST  @EXTRAM,@DDD1     @DDD1 : Source addr in ERAM
[1565] A7DB 97,54           DDECT @DDD1
[1566] A7DD 0F,8C           XML  GREAD1            Read data from ERAM
[1567] A7DF BD,5E,58        DST  @EEE1,@ARG2       @EEE1 : Destination addr on C
[1568] A7E2 B2,5E,7F GA8A5  AND  >7F,@ARG2         Reset the breakpoint if any
[1569] A7E5 05,6A,7C        B    DISO
[1570]               ***********************************************************
[1571]               * Code to decode error returned from ALC
[1572]               ***********************************************************
[1573] A7E8 8A,22    ERORZ  CASE @ERRCOD           DECODE ERROR FROM INTERPRETER
[1574] A7EA 4C,86           BR   ERRSYN            0 SYNTAX ERROR
[1575] A7EC 4C,92           BR   ERRMEM            1 MEMORY FULL
[1576] A7EE 4C,BA           BR   ERRBV             2 BAD VALUE
[1577] A7F0 4C,B2           BR   ERRLNF            3 LINE NOT FOUND
[1578] A7F2 4C,86           BR   ERRSYN            4 SYNTAX
[1579] A7F4 4C,AE           BR   ERRBS             5 BAD SUBSCRIPT
[1580] A7F6 4C,8A           BR   ERRSNM            6 STRING-NUMBER MISMATCH
[1581] A7F8 4C,96           BR   ERRSO             7 STACK OVERFLOW
[1582] A7FA 4C,B6           BR   ERRBA             8 BAD ARGUMENT
[1583] A7FC 4C,AA           BR   ERRRWG            9 RETURN WITHOUT GOSUB
[1584] A7FE 4C,BE           BR   ERRIAL            A INCORRECT ARGUMENT LIST
[1585] A800 4C,9E           BR   ERRFNN            B FOR/NEXT NESTING
[1586] A802 4C,9A           BR   ERRNWF            C NEXT WITHOUT FOR
[1587] A804 4C,8E           BR   ERRMUV            D IMPROPERLY USED NAME
[1588] A806 4C,BE           BR   ERRIAL            E INCORRECT ARGUMENT LIST
[1589] A808 4C,A6           BR   ERRRSC            F RECURSIVE SUBPROGRAM CALL
[1590] A80A 4C,C2           BR   ERRSNF           10 SUBPROGRAM NOT FOUND
[1591] A80C 45,D6           BR   ERROLP           11 ONLY LEGAL IN A PROGRAM
[1592] A80E 4C,A2           BR   ERRSNS           12 MUST BE IN SUBPROGRAM
[1593]               ***********************************************************
[1594]               * SUBROUTINE TO GET LINE # FOLLOWING 'BREAK', 'UNBREAK',
[1595]               * 'RESTORE'
[1596]               ***********************************************************
[1597] A810 D6,42,C9 LINE   CEQ  LNZ,@CHAT         Should be line # reference
[1598] A813 4C,86           BR   ERRSYN
[1599] A815 0F,79           XML  PGMCHR            Get high order line #
[1600] A817 BC,4A,42        ST   @CHAT,@FAC        Build result in FAC, FAC1
[1601] A81A 0F,79           XML  PGMCHR
[1602] A81C BC,4B,42        ST   @CHAT,@FAC1       Low order line #
[1603] A81F 0F,79           XML  PGMCHR            Get token following line #
[1604] A821 00              RTN
[1605] A822 86,54    CONV1  CLR  @FAC10
[1606] A824 0F,10           XML  CSNUM             Convert String to Number
[1607]               ***********************************************************
[1608] A826 BC,A3,BA        ST   @FAC10,V@CSNTP1
       A829 54
[1609] A82A BD,A3,90        DST  @FAC12,V@CSNTMP Save those in temporary, becaus
       A82D 56
[1610]               *                            in ERROV : WARNING routine hav
[1611]               *                            FAC12 and FAC10 values changed
[1612]               ***********************************************************
[1613] A82E 8E,54    WRNNO  CZ   @FAC10            Numeric overflow
[1614] A830 68,36           BS   GA8F9
[1615] A832 06,6A,82        CALL WARNZZ
[1616] A835 02              BYTE 2
[1617] A836 00       GA8F9  RTN
[1618]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0028 
RXB 2024
[1619]               *                SUBROUTINE FOR 'GCHAR'                   *
[1620]               ***********************************************************
[1621]               * CALL GCHAR(row,column,variable,...)                     *
[1622]               ***********************************************************
[1623] A837 BD,02,7F GCHARZ DST  @XPT,@PAD2     Save XPT:YPT
[1624] A83A 06,AB,92 GCHAR1 CALL LPARR          (?
[1625] A83D 0F,7E           XML  SPEED          Insure in range
[1626] A83F 02              BYTE RANGE          *  of 1 - 24
[1627] A840 01              BYTE 1
[1628] A841 00,18           DATA 24
[1629] A843 92,4B           DEC  @FAC1          Adjust to internal range
[1630] A845 BD,02,7F        DST  @XPT,@PAD2     Save old XPT:YPT
[1631] A848 BC,7E,4B        ST   @FAC1,@YPT     Set row pointer
[1632] A84B 0F,7E           XML  SPEED          Get column value
[1633] A84D 01              BYTE PARCOM         *  and insure a comma
[1634] A84E 0F,7E           XML  SPEED          Insure in range
[1635] A850 02              BYTE RANGE          *  of 1 to 32
[1636] A851 01              BYTE 1
[1637] A852 00,20           DATA 32
[1638] A854 92,4B           DEC  @FAC1          Internal range: 0 - 31
[1639] A856 BC,7F,4B        ST   @FAC1,@XPT     Set column pointer
[1640] A859 06,A9,4E GCHAR2 CALL NUMVAR         Get pointer return variable
[1641] A85C 31,00,08        MOVE 8,G@FLT1,@FAC  Clear FAC
       A85F 4A,A3,32
[1642] A862 BC,4B,7D        ST   @CB,@FAC1      Get the character
[1643] A865 A6,4B,60        SUB  OFFSET,@FAC1   Remove screen offset
[1644] A868 CA,4B,64        CHE  100,@FAC1      100>=?
[1645] A86B 48,75           BR   GCHAR3         No, pass value 
[1646] A86D C0,4C,4B        EX   @FAC1,@FAC2    Swap if over offset size
[1647] A870 AE,4B,64        DIV  100,@FAC1      Set correct range
[1648] A873 90,4A           INC  @FAC           Set from Assembly to XB
[1649] A875 BD,7F,02 GCHAR3 DST  @PAD2,@XPT     Restore XPT:YPT
[1650] A878 0F,7C           XML  ASSGNV         Assign the value to the symbol
[1651] A87A D6,42,B3        CEQ  COMMAZ,@CHAT   ,? 
[1652] A87D 68,3A           BS   GCHAR1         Loop
[1653] A87F BD,7F,02        DST  @PAD2,@XPT     Restore XPT:YPT
[1654] A882 0F,7E    LNKRTN XML  SPEED          Must be at
[1655] A884 00              BYTE SYNCHK    *     a right
[1656] A885 B6              BYTE RPARZ     *      parenthesis
[1657] A886 06,6A,78 LNKRT2 CALL CHKEND         Check end of statement
[1658] A889 4C,86           BR   ERRSYN         If not end-of-stmt , error
[1659] A88B 06,00,12        CALL RETURN         Return to caller
[1660]               ***********************************************************
[1661]               * CALL COLOR(ALL,FORGROUND,BACKGROUND,...)                *
[1662]               * CALL COLOR(SET#,FORGROUND,BACKGROUND,... )              *
[1663]               * CALL COLOR(SPRITE#,FORGROUND,...)                       *
[1664]               ***********************************************************
[1665] A88E 0F,7E    COLORZ XML  SPEED             Must be
[1666] A890 00              BYTE SYNCHK        *     at a
[1667] A891 B7              BYTE LPARZ         *       left parenthesis
[1668] A892 87,00    COL08  DCLR @PAD              Clear ALL pointer
[1669] A894 D6,42,EC        CEQ  ALLZ,@CHAT        ALL?
[1670] A897 48,A5           BR   COL09             No.
[1671] A899 BE,00,EC        ST   ALLZ,@PAD         Yes, store it in pointer
[1672] A89C 87,4A           DCLR @FAC              Set 0
[1673] A89E 0F,79           XML  PGMCHR            Skip ALL token.
[1674] A8A0 06,B0,67        CALL COMMA2            Skip comma.
[1675] A8A3 48,C3           BR   COL21             Start ALL RXB routine
[1676] A8A5 D6,42,FD COL09  CEQ  NUMBEZ,@CHAT      If sprite number specified
[1677] A8A8 48,BA           BR   COL20
[1678] A8AA 06,AF,DD        CALL SPNUM3             Check sprite number (SPNUM3)
[1679] A8AD 06,A8,FA COL10  CALL SPCOL             Put the color in SAL
[1680] A8B0 D6,42,B3        CEQ  COMMAZ,@CHAT      More color changes
[1681] A8B3 48,82           BR   LNKRTN

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0029 
RXB 2024
[1682] A8B5 06,AF,D6        CALL SPNUM2             Skip and get sprite number (
[1683] A8B8 48,AD           BR   COL10
[1684]               * This part for regular color change routine
[1685] A8BA 0F,7E    COL20  XML  SPEED             Parse the character
[1686] A8BC 01              BYTE PARCOM         *   set and insure a comma
[1687] A8BD 0F,7E           XML  SPEED             Insure in range of
[1688] A8BF 02              BYTE RANGE          *   0<= x <= 14
[1689] A8C0 00,00,10        BYTE 0,0,16
[1690] A8C3 A3,4A,08 COL21  DADD >080F,@FAC        Color table addr(>0810 - >081
       A8C6 0F
[1691] A8C7 0F,77           XML  VPUSH             Push table set address
[1692] A8C9 0F,7E           XML  SPEED             Parse the foreground color
[1693] A8CB 01              BYTE PARCOM         *   and insure a comma
[1694] A8CC 06,AB,AF        CALL RAN16             Error if >16 or <1
[1695] A8CF BC,0E,4B        ST   @FAC1,@VAR4       Save it
[1696] A8D2 E2,0E,04        SLL  4,@VAR4           Foreground color in 4 MSBits
[1697] A8D5 0F,74           XML  PARSE             Get background color
[1698] A8D7 B6              BYTE RPARZ
[1699] A8D8 06,AB,AF        CALL RAN16             Error if >16 or <1
[1700] A8DB B4,0E,4B        OR   @FAC1,@VAR4       Background color in 4 LSBits
[1701] A8DE 0F,78           XML  VPOP              Get color table address
[1702] A8E0 BC,B0,4A        ST   @VAR4,V*FAC       Load the colors into the tabl
       A8E3 0E
[1703] A8E4 D6,00,EC        CEQ  ALLZ,@PAD         ALL in pointer.
[1704] A8E7 48,F1           BR   COL22             No.
[1705] A8E9 35,00,0E        MOVE 14,V*FAC,V@1(@FAC) Fill color table with values
       A8EC E0,01,4A
       A8EF B0,4A
[1706] A8F1 D6,42,B3 COL22  CEQ  COMMAZ,@CHAT      End of call. Go back.
[1707] A8F4 48,82           BR   LNKRTN
[1708] A8F6 0F,79           XML  PGMCHR            Skip ","
[1709] A8F8 48,92           BR   COL08             Take care of the next set
[1710]               *      CALL SPCOL -- Changes color of sprite.
[1711]               *                    Called also from SPRITE.
[1712] A8FA 0F,74    SPCOL  XML  PARSE
[1713] A8FC B6              BYTE RPARZ          *  Get the color number
[1714] A8FD 06,AB,AF        CALL RAN16             Check range 1 - 16
[1715] A900 BC,E0,03        ST   @FAC1,V@3(@PAD8)  Store in SAL
       A903 08,4B
[1716] A905 00              RTN
[1717]               ***********************************************************
[1718]               * INTARG - Insures that the value in FAC is a numeric,
[1719]               *          converts it to integer, issues error message if
[1720]               *          necessary or returns.
[1721]               ***********************************************************
[1722] A906 C6,4C,63 INTARG CH   >63,@FAC2         If string - error
[1723] A909 6C,8A           BS   ERRSNM      ERROR STRING NUMBER MISMATCH       
[1724] A90B 86,54           CLR  @FAC10            ASSUME NO ERROR OR WARNING
[1725] A90D 87,6C           DCLR @FPERAD
[1726] A90F 0F,12           XML  FLTINT
[1727] A911 8E,54           CZ   @FAC10            If error
[1728] A913 4C,BA           BR   ERRBV
[1729] A915 D2,4A,00        CGE  0,@FAC            Can't be < zero
[1730] A918 4C,BA           BR   ERRBV
[1731] A91A 00              RTN
[1732]               * FAC IS SET UP WITH F.P. 1
[1733] A91B BC,4B,00 JOYXY  ST   @PAD,@FAC1
[1734] A91E 8E,00           CZ   @PAD              If <>0
[1735] A920 49,26           BR   JOYNZ             No, not zero (0)
[1736] A922 86,4A           CLR  @FAC              (>0000000000000000)
[1737] A924 49,2E           BR   JOYAV             Assign value
[1738] A926 D2,00,00 JOYNZ  CGE  0,@PAD            PAD>=0?
[1739] A929 69,2E           BS   JOYAV             Yes assign value
[1740] A92B BE,4A,BF        ST   >BF,@FAC          Negative value

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0030 
RXB 2024
[1741] A92E 0F,7C    JOYAV  XML  ASSGNV            Assign the value
[1742] A930 00              RTN
[1743] A931 BC,00,4B        ST   @FAC1,@PAD        Keyboard selection
[1744] A934 06,A9,4E        CALL NUMVAR            Get variable for key-code
[1745] A937 D6,42,B3        CEQ  COMMAZ,@CHAT      If not comma - error
[1746] A93A 4C,86           BR   ERRSYN
[1747] A93C 0F,79           XML  PGMCHR            Get next character
[1748] A93E 06,A9,4E        CALL NUMVAR            Get variable for key-status
[1749] A941 BC,74,00        ST   @PAD,@KEYBD       Keyboard selection
[1750] A944 31,00,08        MOVE 8,G@FLT1,@FAC     Set up float
       A947 4A,A3,32
[1751] A94A 03              SCAN                   SCAN the keyboard
[1752] A94B 86,74           CLR  @KEYBD            Clear the code(No affect on s
[1753] A94D 01              RTNC                   Return scan condition code
[1754]               *
[1755] A94E 0F,7A    NUMVAR XML  SYM               Get the symbol name
[1756] A950 DA,B0,4A        CLOG >C0,V*FAC         Can't be string or function
       A953 C0
[1757] A954 4C,8E           BR   ERRMUV            It is, IMPROPERLY USED NAME E
[1758] A956 0F,7B           XML  SMB               Get value pointer
[1759] A958 0F,77           XML  VPUSH             Put on stack for ASSGNV
[1760] A95A 00              RTN                    And return
[1761]               *
[1762] A95B 80,00,A0 ATTREG DATA >8000,>A000,>C000,
       A95E 00,C0,00
[1763] A961 9F,BF,DF        BYTE >9F,>BF,>DF,>FF,>00,>06
       A964 FF,00,06
[1764] A967 D6,42,B7 COMB   CEQ  LPARZ,@CHAT       If not '(' - error
[1765] A96A 4C,86           BR   ERRSYN
[1766] A96C 00              RTN
[1767]               *
[1768] A96D 35,00,08 SQUISH MOVE 8,V*FAC8,@FAC     Sneak it out
       A970 4A,B0,52
[1769] A973 BD,58,6E        DST  @VSPTR,@FAC14     Now move stack to squish it
[1770] A976 A5,58,52        DSUB @FAC8,@FAC14        out - # of bytes to move
[1771] A979 69,84           BS   SQU05             If none to move
[1772] A97B 34,58,EF        MOVE @FAC14,V@8(@FAC8),V@-16(@FAC8)
       A97E FF,F0,52
       A981 E0,08,52
[1773] A984 A7,6E,00 SQU05  DSUB 8,@VSPTR
       A987 08
[1774] A988 00              RTN
[1775]               ***********************************************************
[1776]               *                 SUBPROGRAM FOR CLEAR                    *
[1777]               ***********************************************************
[1778]               * CALL CLEAR                                              *
[1779]               ***********************************************************
[1780] A989 07,80    CLEARZ ALL  SPACE+OFFSET      Clear the screen
[1781] A98B BE,7F,03        ST   3,@XPT            Initialize screen pointer
[1782] A98E 48,86           BR   LNKRT2            Return to caller
[1783]               ***********************************************************
[1784]               * CALL CLEARPRINT                                         *
[1785]               ***********************************************************
[1786] A990 86,8F,DD CLRPZ  CLR  @>6004       Set ROM 3 page
       A993 04
[1787] A994 0F,79           XML  CLEARP       Disply them
[1788] A996 48,86           BR   LNKRT2  
[1789]               ***********************************************************
[1790]               * INIALIZATION DATA FOR SOUND
[1791] A998 42,0B,12 FLTS   BYTE >42,>0B,>12,>22,>00,>00,>00,>00
       A99B 22,00,00
       A99E 00,00
[1792] A9A0 01,FF,01 SNDREG BYTE >01,>FF,>01,>04,>9F,>BF,>DF,>FF,>00
       A9A3 04,9F,BF

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0031 
RXB 2024
       A9A6 DF,FF,00
[1793]               ***********************************************************
[1794]               *                SUBPROGRAM FOR 'SOUND'                   *
[1795]               * CALL SOUND(duration,frequency,volume1,...)              *
[1796]               * Builds 2 blocks in VDP RAM                              *
[1797]               * 1st BLOCK : >01,<ATTENUATION FOR NOISE>,<INTERRUPT COUNT>
[1798]               * 2nd BLOCK : >04,>9F,>BF,>DF,>FF,>00                     *
[1799]               ***********************************************************
[1800] A9A9 D7,80,CC XSOUND DCEQ VRMSND,@>83CC     Insure previous sound started
       A9AC 03,79
[1801] A9AE 69,A9           BS   XSOUND
[1802] A9B0 31,00,09        MOVE 9,G@SNDREG,V@VRMSND
       A9B3 A3,79,A9
       A9B6 A0
[1803] A9B7 06,AB,92        CALL LPARR             Duration in milliseconds
[1804] A9BA D2,4A,00        CGE  0,@FAC            Don't wait for completion
[1805] A9BD 69,C4           BS   GAA39
[1806] A9BF 83,4A           DNEG @FAC                of previous sound
[1807] A9C1 87,80,CE        DCLR @PRTNFN           Make GPL interpeters stop pre
[1808] A9C4 0F,7E    GAA39  XML  SPEED             Insure duration
[1809] A9C6 02              BYTE RANGE           *  is in range
[1810] A9C7 01              BYTE 1               *   of 1 - 4250
[1811] A9C8 10,9A           DATA 4250
[1812]               * Convert duration into 1/60s of a second
[1813] A9CA AB,4A,00        DMUL 6,@FAC            Duration * 6
       A9CD 06
[1814] A9CE AF,4A,00        DDIV 100,@FAC          (duration * 6) / 100
       A9D1 64
[1815] A9D2 8E,4B           CZ   @FAC1             If duration =0
[1816] A9D4 49,D8           BR   GAA4D
[1817] A9D6 90,4B           INC  @FAC1             Set it to 1/60th of a second
[1818] A9D8 BC,A3,7B GAA4D  ST   @FAC1,V@VRMSND+2    3rd byte of the 1st block
       A9DB 4B
[1819]               *                          | INTERUPT COUNT
[1820]               ***********************************************************
[1821]               *      SOUND TABLE OF 10 BYTES IN CPU RAM (>00 - >09)
[1822]               * >00 - >05 : FREQUENCY CONTROL
[1823]               * >06 - >08 : ATTENUATION CONTROL
[1824]               * >09       : NOISE CONTROL(non-zero = noise encountered)
[1825]               * >0A       : POINTER FOR CURRENT FREQENCY CONTROL
[1826]               * >0B       : POINTER FOR CURRENT ATTENUATION CONTROL
[1827]               *                    >00 , >01 FOR REG 0;
[1828]               *                    >02 , >03 FOR REG 1;
[1829]               *                    >04 , >05 FOR REG 2;
[1830]               * REG0 : >8000, REG1 : >A000, REG3 : >C000
[1831]               * INITIALIZE ATTENUATION CONTROL
[1832]               * REG0 : >9F, REG1 : >BF, REG2 : >DF
[1833]               ***********************************************************
[1834] A9DC 31,00,0C        MOVE 12,G@ATTREG,@>8300
       A9DF 00,A9,5B
[1835] A9E2 0F,7E    SOUND1 XML  SPEED             Parse the frequency value
[1836] A9E4 01              BYTE PARCOM         *   and insure a comma
[1837] A9E5 06,A3,2C        CALL CKSTNM            Must be a numeric
[1838] A9E8 D2,4A,00        CGE  0,@FAC            Noise if negative
[1839] A9EB 4A,2A           BR   SOUND2
[1840] A9ED 31,00,08        MOVE 8,G@FLTS,@ARG     Constant 111834
       A9F0 5C,A9,98
[1841] A9F3 0F,09           XML  FDIV              P = 111834/FREQUENCY
[1842] A9F5 0F,7E           XML  SPEED             Insure in range
[1843] A9F7 02              BYTE RANGE
[1844] A9F8 03              BYTE 3               * Range: 3 - 1023
[1845] A9F9 03,FF           DATA 1023
[1846]               * GET THE 4 L.S.Bits BITS AND 6 M.S.Bits OF 'P'
[1847] A9FB EB,4A,00        DSRC 4,@FAC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0032 
RXB 2024
       A9FE 04
[1848] A9FF E6,4A,04        SRL  4,@FAC
[1849] AA02 B5,90,0A        DOR  @FAC,*STADDR  1st byte of frequency control byt
       AA05 4A
[1850]               *                         BIT   7   6   5   4   3   2   1
[1851]               *                               1  <REG>    0  <L.S.B. 4 OF
[1852]               *                         2nd byte of frequency control byt
[1853]               *                               0   0   <M.S.B. 6 of 'P'
[1854] AA06 94,0A           INCT @STADDR           Advance ponter for next time
[1855] AA08 06,A7,98        CALL ATTNUT            Get attenuation
[1856]               *                        BIT    7   6   5   4   3   2   1
[1857]               *                               1   <REG>   1   0   0   0
[1858] AA0B B0,90,0B        AND  @FAC1,*PADB         1   <REG>   1   <ATTN/2 DB>
       AA0E 4B
[1859] AA0F 90,0B           INC  @PADB             Advance pointer for next time
[1860]               * CHECK FOR END OF SOUND CALL
[1861] AA11 D6,42,B6 SOUND3 CEQ  RPARZ,@CHAT       End of statement?
[1862] AA14 6A,48           BS   SOUND5
[1863] AA16 0F,7E           XML  SPEED             If not right parenthesis
[1864] AA18 00              BYTE SYNCHK        *    then must be at
[1865] AA19 B3              BYTE COMMAZ        *      a comma
[1866]              
[1867] AA1A D6,0A,06        CEQ  6,@STADDR         If not 3 regs yet
[1868] AA1D 49,E2           BR   SOUND1
[1869]               * 3 sound regs already - so must be noise control
[1870] AA1F 0F,7E           XML  SPEED             Get frequency (should be nois
[1871] AA21 01              BYTE PARCOM        *     and insure a comma
[1872] AA22 06,A3,2C        CALL CKSTNM            Must be a numeric value
[1873] AA25 D2,4A,00        CGE  0,@FAC            If not noise-error
[1874] AA28 6C,BA           BS   ERRBV
[1875]               * NOISE CONTROL
[1876] AA2A D6,09,FF SOUND2 CEQ  >FF,@>8309        * BAD ARGUMENT ERROR
[1877] AA2D 4C,B6           BR   ERRBA
[1878] AA2F 83,4A           DNEG @FAC              -(FREQUENCY)
[1879] AA31 0F,7E           XML  SPEED             Insure in range
[1880] AA33 02              BYTE RANGE         *    of 1 - 8
[1881] AA34 01              BYTE 1             *
[1882] AA35 00,08           DATA 8
[1883] AA37 92,4B           DEC  @FAC1             0 - 7 (2nd BIT: 'T')
[1884]               *                                           OTH, 1ST BITS:
[1885] AA39 BC,09,4B        ST   @FAC1,@>8309
[1886] AA3C B6,09,E0        OR   >E0,@>8309        Noise control byte:
[1887]               *                        BIT  7   6   5   4   3   2   1   0
[1888]               *                             1   1   1   0   0  <T>  < S >
[1889]               * PUT ATTENUATION IN THE 2ND BYTE OF 1ST BLOCK
[1890] AA3F 06,A7,98        CALL ATTNUT
[1891] AA42 BC,A3,7A        ST   @FAC1,V@VRMSND+1
       AA45 4B
[1892]               *                             1   1   1   1   < ATTN/2  DB>
[1893] AA46 4A,11           BR   SOUND3            Go check for end of list
[1894] AA48 86,10    SOUND5 CLR  @VAR5             Pointer to sound table
[1895] AA4A 8E,80,CE SND05  CZ   @PRTNFN           Wait untild previous
[1896] AA4D 6A,59           BS   SOUND6
[1897] AA4F 03              SCAN                   Is finished and
[1898] AA50 4A,4A           BR   SND05              look for a break-key
[1899] AA52 D6,75,02        CEQ  BREAK,@RKEY       If not break-key
[1900] AA55 4A,4A           BR   SND05
[1901] AA57 41,1B           BR   EXEC6C            If BREAK-KEY encountered
[1902]               * LOAD SOUND TABLE
[1903] AA59 BC,81,00 SOUND6 ST   *VAR5,@>8400      SOUND ADDRESS PORT
       AA5C 90,10
[1904] AA5E 90,10           INC  @VAR5             Next byte in table
[1905] AA60 D6,10,0A        CEQ  >0A,@VAR5         If not finished
[1906] AA63 4A,59           BR   SOUND6

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0033 
RXB 2024
[1907] AA65 BF,4A,03        DST  VRMSND,@FAC       Where the 2 blocks are
       AA68 79
[1908] AA69 F6,4A,01        I/O  1,@FAC            Start sound from VDP list
[1909] AA6C 48,82           BR   LNKRTN            Return to caller
[1910]               ***********************************************************
[1911]               * CALL HCHAR(row,column,character#,repetition[,...])      *
[1912]               ***********************************************************
[1913] AA6E 06,A9,67 HCHARZ CALL COMB              (?
[1914] AA71 06,AA,A2 HCHAR1 CALL HVRC              Get X, Y values
[1915] AA74 06,AA,C3        CALL HVCHR             character#
[1916] AA77 8F,4A           DCZ  @FAC              If 0 characters
[1917] AA79 6A,81           BS   HCHAR2
[1918] AA7B 86,8F,DD        CLR  @>6004            Set ROM 3 page
       AA7E 04
[1919] AA7F 0F,74           XML  HCHAR             Disply them
[1920] AA81 D6,42,B3 HCHAR2 CEQ  COMMAZ,@CHAT
[1921] AA84 6A,71           BS   HCHAR1
[1922] AA86 48,82           BR   LNKRTN            Return to XB
[1923]               ***********************************************************
[1924]               * CALL VCHAR(row,column,character#,repetition[,...])      *
[1925]               ***********************************************************
[1926] AA88 06,A9,67 VCHARZ CALL COMB              (?
[1927] AA8B 06,AA,A2 VCHAR1 CALL HVRC              Get X, Y values
[1928] AA8E 06,AA,C3        CALL HVCHR             character#
[1929] AA91 8F,4A           DCZ  @FAC              If 0 characters
[1930] AA93 6A,9B           BS   VCHAR2
[1931] AA95 86,8F,DD        CLR  @>6004            Set ROM 3 page
       AA98 04
[1932] AA99 0F,75           XML  VCHAR             Disply them
[1933] AA9B D6,42,B3 VCHAR2 CEQ  COMMAZ,@CHAT      COMMA?   
[1934] AA9E 6A,8B           BS   VCHAR1            No run again
[1935] AAA0 48,82           BR   LNKRTN            Done
[1936]               ***********************************************************
[1937]               * SUBROUTINE TO GET ROW, COLUMN VALUES
[1938]               ***********************************************************
[1939]               * Get ROW, COLUMN VALUES AND NUMBER OF CHARACTERS
[1940] AAA2 06,A2,BD HVRC   CALL NUMFCH          * Get ROW
[1941] AAA5 0F,7E           XML  SPEED             Insure in range
[1942] AAA7 02              BYTE RANGE           *  of 1 - 24
[1943] AAA8 01              BYTE 1
[1944] AAA9 00,18           DATA 24
[1945] AAAB 92,4B           DEC  @FAC1           * Adjust for Assembly
[1946] AAAD E3,4A,00        DSLL 5,@FAC          * FAC times 32  
       AAB0 05
[1947] AAB1 BD,02,4A        DST  @FAC,@PAD2      * VDP ADDRESS
[1948] AAB4 06,A2,BD        CALL NUMFCH          * Get Column
[1949] AAB7 0F,7E           XML  SPEED           *  Insure in range
[1950] AAB9 02              BYTE RANGE           *  of 1 to 32
[1951] AABA 01              BYTE 1
[1952] AABB 00,20           DATA 32
[1953] AABD 92,4B           DEC  @FAC1           * Adjust for Assembly: 0 - 31
[1954] AABF A1,02,4A        DADD @FAC,@PAD2      * Set column pointer
[1955] AAC2 00              RTN
[1956]               * Get Character minus OFFSET
[1957] AAC3 06,A2,D7 HVCHR  CALL SUBLP3          * Get character number
[1958] AAC6 A2,4B,60        ADD  OFFSET,@FAC1    * Add OFFSET
[1959] AAC9 BD,00,4B        DST  @FAC1,@PAD      * Pass value
[1960] AACC BF,4A,00 HVCHR1 DST  1,@FAC          * ASSUME 1 REPETITION
       AACF 01
[1961] AAD0 D6,42,B6        CEQ  RPARZ,@CHAT     * If not right parenthesis
[1962] AAD3 6A,D8           BS   HVCHS           * Yes return
[1963] AAD5 06,A2,D7        CALL SUBLP3          * Skip comma, Get repetition
[1964] AAD8 00       HVCHS  RTN                  * Return
[1965]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0034 
RXB 2024
[1966] AAD9 06,AB,92 RGPHV  CALL LPARR             Insure '(', parse, insure ','
[1967] AADC 0F,7E    GPHVRC XML  SPEED             Insure in range
[1968] AADE 02              BYTE RANGE           *  of 1 - 24
[1969] AADF 01              BYTE 1
[1970] AAE0 00,18           DATA 24
[1971] AAE2 92,4B           DEC  @FAC1           * Adjust for Assembly
[1972] AAE4 E3,4A,00        DSLL 5,@FAC          * FAC times 32  
       AAE7 05
[1973] AAE8 BD,02,4A        DST  @FAC,@PAD2      * VDP ADDRESS
[1974] AAEB 0F,7E           XML  SPEED           * Get column value
[1975] AAED 01              BYTE PARCOM          *  and insure a comma
[1976] AAEE 0F,7E           XML  SPEED           *  Insure in range
[1977] AAF0 02              BYTE RANGE           *  of 1 to 32
[1978] AAF1 01              BYTE 1
[1979] AAF2 00,20           DATA 32
[1980] AAF4 92,4B           DEC  @FAC1           * Adjust for Assembly: 0 - 31
[1981] AAF6 A1,02,4A        DADD @FAC,@PAD2      * Set column pointer
[1982] AAF9 00              RTN
[1983]               ***********************************************************
[1984]               * CALL CHAR(char#,pattern,...)                            *
[1985]               * CALL CHAR(ALL,pattern,...)                              *
[1986]               ***********************************************************
[1987] AAFA 06,A9,67 CHARLY CALL COMB            (?
[1988] AAFD 0F,79    CHAR5  XML  PGMCHR          Skip "(" or ","
[1989] AAFF D6,42,EC        CEQ  ALLZ,@CHAT      ALL token?
[1990] AB02 4B,13           BR   CHAR2           No
[1991] AB04 0F,79           XML  PGMCHR          Skip ALL token
[1992] AB06 D6,42,B3        CEQ  COMMAZ,@CHAT    ,?
[1993] AB09 4C,86           BR   ERRSYN          SYNTAX ERROR
[1994] AB0B 86,16           CLR  @PAD16          ALL FLAG
[1995] AB0D BF,14,00        DST  >0032,@VAR9     Starting char
       AB10 32
[1996] AB11 4B,1F           BR   CHAR1           Skip normal CHAR
[1997] AB13 BE,16,FF CHAR2  ST   >FF,@PAD16      No ALL flag
[1998] AB16 0F,74           XML  PARSE           Get char number 
[1999] AB18 B6              BYTE RPARZ
[2000] AB19 06,BC,7F        CALL S1ET9F          30 - 159?
[2001] AB1C BD,14,4A        DST  @FAC,@VAR9      Move to PAD2 30 - 159
[2002] AB1F 06,A2,B4 CHAR1  CALL STRGET          Check and get String
[2003] AB22 86,8F,DD CHARLD CLR  @>6004          Set ROM 3 page
       AB25 04
[2004] AB26 0F,81           XML  DCHAR 
[2005] AB28 D7,5C,99        DCEQ >994A,@ARG
       AB2B 4A
[2006] AB2C 6C,B6           BS   ERRBA           ERROR BAD ARGUEMENT
[2007] AB2E 8E,16           CZ   @PAD16          ALL FLAG?
[2008] AB30 4B,47           BR   CHARL4          NO
[2009] AB32 BF,16,04        DST  >0400,@PAD16    SET UP INDEX COUNTER
       AB35 00
[2010] AB36 35,00,08 CHRFIL MOVE 8,@>8300,V@0(@PAD16)
       AB39 E0,00,16
       AB3C 00
[2011] AB3D A3,16,00        DADD 8,@PAD16          COUNTER+8
       AB40 08
[2012] AB41 D7,16,07        DCEQ >0780,@PAD16     End of Char Table? 
       AB44 80
[2013] AB45 4B,36           BR   CHRFIL          No, loop
[2014] AB47 D6,42,B3 CHARL4 CEQ  COMMAZ,@CHAT    More specified?
[2015] AB4A 6A,FD           BS   CHAR5
[2016] AB4C 48,82           BR   LNKRTN          Return
[2017]               ***********************************************************
[2018]               *              SUBPROGRAM FOR 'KEY'                       *
[2019]               ***********************************************************
[2020]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0035 
RXB 2024
[2021]               * CALL KEY(key-unit,return-variable,status-variable,...)   
[2022]               * CALL KEY(string,key-unit,return-variable,status-variable,
[2023]               ***********************************************************
[2024] AB4E 06,BA,21 KEY    CALL SPAR              GET KEY UNIT
[2025]               * RXB PATCH LABEL ************
[2026] AB51 0F,7E    GABD1  XML  SPEED             Insure in range
[2027] AB53 02              BYTE RANGE          *   of 0 - 5
[2028] AB54 00              BYTE 0
[2029] AB55 00,05           DATA 5
[2030] AB57 06,B8,AB        CALL KEYJOY            Get variables for code and st
[2031]               *                              and scan keyboard
[2032]               *                             KEYJOY returns key status
[2033] AB5A 6B,65           BS   KEY1B             KEY STATUS = 1
[2034] AB5C 83,4A           DNEG @FAC              Assume status = -1
[2035] AB5E D6,75,FF        CEQ  >FF,@RKEY         But correct if = 0
[2036] AB61 4B,65           BR   KEY1B
[2037] AB63 87,4A           DCLR @FAC              KEY STATUS = 0
[2038] AB65 0F,7C    KEY1B  XML  ASSGNV            Assign value in variable
[2039] AB67 BF,4A,40        DST  >4001,@FAC        Re-store F.P. 1 in FAC
       AB6A 01
[2040] AB6B 8E,75           CZ   @RKEY             If key-code = 0
[2041] AB6D 6B,8D           BS   KEY2
[2042] AB6F D6,75,FF        CEQ  >FF,@RKEY         No key depressed,
[2043] AB72 6B,89           BS   KEY1C              key code assigned to -1
[2044]               * FORMAT FOR KEYCODES ABOVE 99 ADDED FOR 99/4A HIGHEST
[2045]               * KEYCODE (OTHER THAN >FF) IS >C6=198
[2046]               * 5/7/81
[2047] AB74 CA,75,64        CHE  100,@RKEY
[2048] AB77 4B,84           BR   GAC04
[2049] AB79 90,4A           INC  @FAC
[2050] AB7B A6,75,64        SUB  100,@RKEY
[2051] AB7E BC,4C,75        ST   @RKEY,@FAC2       FLOATING FORMAT (>4001__00000
[2052] AB81 05,AB,87        B    GAC07
[2053] AB84 BC,4B,75 GAC04  ST   @RKEY,@FAC1       FLOATING FORMAT (>40__0000000
[2054] AB87 4B,8F    GAC07  BR   KEY2A
[2055] AB89 83,4A    KEY1C  DNEG @FAC              KEY CODE ASSIGNED TO -1
[2056] AB8B 4B,8F           BR   KEY2A
[2057] AB8D 87,4A    KEY2   DCLR @FAC              (>000000000000000)
[2058] AB8F 0F,7C    KEY2A  XML  ASSGNV            ASSIGN VALUE TO VARIABLE
[2059]               * RXB PATCH CODE *************
[2060]               *      BR   LNKRTN
[2061] AB91 00              RTN
[2062]               ***********************************************************
[2063]               * INSURE LEFT PARENTHESIS AND THEN PARSE TO A COMMA
[2064]               ***********************************************************
[2065]               * RXB PATCH CODE
[2066] AB92 D6,42,B3 LPARR  CEQ  COMMAZ,@CHAT
[2067] AB95 6B,9D           BS   CPAR
[2068] AB97 0F,7E           XML  SPEED           *  Must be
[2069] AB99 00              BYTE SYNCHK          *  at a
[2070] AB9A B7              BYTE LPARZ           *    left parenthesis
[2071] AB9B 4B,A1           BR   CPAR2
[2072] AB9D 0F,7E    CPAR   XML  SPEED
[2073] AB9F 00              BYTE SYNCHK
[2074] ABA0 B3              BYTE COMMAZ
[2075]               * RXB PATCH LABEL ***********
[2076] ABA1 0F,74    CPAR2  XML  PARSE             Do the parse
[2077] ABA3 B3              BYTE COMMAZ          * Stop on a comma
[2078] ABA4 0F,7E           XML  SPEED           *  Must be
[2079] ABA6 00              BYTE SYNCHK          *  at a
[2080] ABA7 B3              BYTE COMMAZ          *    left comma
[2081] ABA8 00              RTN
[2082]               *****************************
[2083] ABA9 0F,7E    CPAR3  XML  SPEED           * Similar to LPARR

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0036 
RXB 2024
[2084] ABAB 00,B3           DATA COMMAZ          * Syntax check ,
[2085] ABAD 4B,A1           BR   CPAR2           * Parse value
[2086]               ***********************************************************
[2087]               * SUBROUTINE FOR 'RANGE' USED IN ALL SOUND AND GRAPHICS
[2088]               ***********************************************************
[2089] ABAF 0F,7E    RAN16  XML  SPEED             Insure in range
[2090] ABB1 02              BYTE RANGE          *   of 1 to 16
[2091] ABB2 01              BYTE 1
[2092] ABB3 00,10           DATA 16
[2093] ABB5 92,4B           DEC  @FAC1             Adjust to internal range
[2094] ABB7 00              RTN
[2095]               ***********************************************************
[2096]               *  Subroutine to control border color
[2097]               * Character background is also affected since transparent
[2098]               *  is used.
[2099] ABB8 06,A4,A4 BORDER CALL PARFF             Insure '(' , and parse
[2100] ABBB 06,AB,AF        CALL RAN16             Check 1 - 16 & put in interna
[2101] ABBE 3D,00,01        MOVE 1,@FAC1,#7        Load VDP register
       ABC1 07,4B
[2102] ABC3 48,86           BR   LNKRT2            Return to XB program
[2103]               ***********************************************************
[2104]               * ERRWXY - Is the subroutine for CALL ERR(W,X,Y,Z)
[2105]               *  The parameters indicate:
[2106]               *   W - The error code # of the error
[2107]               *   X - Indicates whether execution(-1) error or
[2108]               *       I/O (0-255) error on LUNO 0-255
[2109]               *   Y - Indicates the severity code of the error
[2110]               *   Z - Line number of the error
[2111]               *   ERR Can be called with 2 forms:
[2112]               *       CALL ERR(W,X,Y,Z) and CALL ERR(W,X)
[2113]               *   If ERR is called and no error has occured then all
[2114]               *   values returned are zero.
[2115]               ***********************************************************
[2116] ABC5 BD,52,6E ERRWXY DST  @VSPTR,@FAC8      Get a temp VSPTR
[2117] ABC8 C5,52,24 GAC99  DCH  @STVSPT,@FAC8     While not a bottom of stack
[2118] ABCB 4B,FF           BR   GACD0
[2119] ABCD BC,5C,E0        ST   V@2(@FAC8),@ARG   Keep ID code in ARG area
       ABD0 02,52
[2120] ABD2 D6,5C,69        CEQ  >69,@ARG          *** ERROR entry
[2121] ABD5 4B,DE           BR   GACAF
[2122] ABD7 06,A9,6D        CALL SQUISH            Squish it out of the stack
[2123] ABDA 0F,77           XML  VPUSH             Put permanent copy of error
[2124]               *                              entry on stack
[2125] ABDC 4C,0B           BR   ERR10             Jump out now
[2126]               * Jump always
[2127] ABDE D6,5C,67 GACAF  CEQ  >67,@ARG          *** FOR entry
[2128] ABE1 4B,E9           BR   GACBA
[2129] ABE3 A7,52,00        DSUB 32,@FAC8          Skip it
       ABE6 20
[2130] ABE7 4B,FD           BR   GACCE
[2131] ABE9 D6,5C,66 GACBA  CEQ  >66,@ARG          *** GOSUB entry
[2132] ABEC 4B,F4           BR   GACC5
[2133] ABEE A7,52,00        DSUB 8,@FAC8           Skip it
       ABF1 08
[2134] ABF2 4B,FD           BR   GACCE
[2135] ABF4 D6,5C,6A GACC5  CEQ  >6A,@ARG          * SYNTAX ERROR
[2136] ABF7 4C,86           BR   ERRSYN
[2137] ABF9 A7,52,00        DSUB 16,@FAC8          Skip it
       ABFC 10
[2138] ABFD 4B,C8    GACCE  BR   GAC99
[2139] ABFF BF,4A,00 GACD0  DST  >0080,@FAC        No error entry there so
       AC02 80
[2140] AC03 BF,4C,69        DST  >6900,@FAC2        fake one
       AC06 00

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0037 
RXB 2024
[2141] AC07 87,4E           DCLR @FAC4
[2142] AC09 87,50           DCLR @FAC6
[2143] AC0B 0F,77    ERR10  XML  VPUSH             Push the temporary entry on
[2144]               *                              top of stack
[2145]               * Code to get "W" in
[2146] AC0D 06,A9,67        CALL COMB              Check for left parenthesis
[2147] AC10 06,AC,7B        CALL ERRC05            Pick up user's symbol
[2148] AC13 BC,4B,EF        ST   V@-8(@VSPTR),@FAC1 Get error code
       AC16 FF,F8,6E
[2149] AC19 0F,80           XML  CIF               Convert it to floating
[2150] AC1B 0F,7C           XML  ASSGNV            Assign it
[2151]               * Code to get "X" in
[2152] AC1D 06,AC,76        CALL ERRCOM            Check syntax & get user's sym
[2153] AC20 DA,EF,FF        CLOG >80,V@-7(@VSPTR)  If execution
       AC23 F9,6E,80
[2154] AC26 4C,32           BR   GAD03
[2155] AC28 31,00,08        MOVE 8,G@FLT1,@FAC     Make it such
       AC2B 4A,A3,32
[2156] AC2E 83,4A           DNEG @FAC              Make it a negative
[2157] AC30 4C,3A           BR   GAD0B
[2158] AC32 BC,4B,EF GAD03  ST   V@-5(@VSPTR),@FAC1 Get I/O LUNO number
       AC35 FF,FB,6E
[2159] AC38 0F,80           XML  CIF               Convert it to floating
[2160] AC3A 0F,7C    GAD0B  XML  ASSGNV
[2161]               * Code to get "Y" in
[2162] AC3C D6,42,B6        CEQ  RPARZ,@CHAT       If long form of CALL ERR
[2163] AC3F 6C,71           BS   GAD42
[2164] AC41 06,AC,76        CALL ERRCOM            Check syntax & get user's sym
[2165] AC44 BC,4B,EF        ST   V@-7(@VSPTR),@FAC1 Get severity code
       AC47 FF,F9,6E
[2166] AC4A B2,4B,7F        AND  >7F,@FAC1         Reset execution  /  I/O flag
[2167] AC4D 0F,80           XML  CIF               Convert it
[2168] AC4F 0F,7C           XML  ASSGNV            Assign it
[2169]               * Code to get "Z" in
[2170] AC51 06,AC,76        CALL ERRCOM            Check syntax & get symbol
[2171] AC54 BD,4C,EF        DST  V@-2(@VSPTR),@FAC2 Get line pointer
       AC57 FF,FE,6E
[2172] AC5A BD,4A,4C        DST  @FAC2,@FAC
[2173] AC5D 8F,4C           DCZ  @FAC2             If line number exists
[2174] AC5F 6C,6D           BS   GAD3E
[2175] AC61 97,4C           DDECT @FAC2            Point to the line #
[2176] AC63 06,60,34        CALL GRSUB1            Read line # (2 bytes) from VD
[2177]               *                              or ERAM (use GREAD)
[2178] AC66 4C              BYTE >4C             * @FAC2: Source addr on ERAM/VD
[2179] AC67 BD,4A,50        DST  @EEE,@FAC         Put the line # in FAC
[2180] AC6A B2,4A,7F        AND  >7F,@FAC          Reset the breakpoint if any
[2181] AC6D 0F,80    GAD3E  XML  CIF               Convert it
[2182] AC6F 0F,7C           XML  ASSGNV            Assign it
[2183] AC71 0F,78    GAD42  XML  VPOP              Trash the temporary entry
[2184] AC73 05,A8,82        B    LNKRTN            Return from subprogram
[2185]               * Must be long branch because of AND above
[2186] AC76 D6,42,B3 ERRCOM CEQ  COMMAZ,@CHAT      Check for comma
[2187] AC79 4C,86           BR   ERRSYN
[2188] AC7B 0F,79    ERRC05 XML  PGMCHR            Get the next character
[2189] AC7D 0F,7A           XML  SYM               Collect name & s.t. entry
[2190] AC7F 0F,7B           XML  SMB               Get value space
[2191] AC81 0F,77           XML  VPUSH             Push it
[2192] AC83 86,4A           CLR  @FAC              Set up for conversion
[2193] AC85 00              RTN
[2194]               * CHANGE IN ADDRESS OF THE ERROR CALLS WILL AFFECT
[2195]               * THE FILE SUBS.....
[2196]               *     ERROR messages called from this file
[2197] AC86 06,6A,84 ERRSYN CALL ERRZZ             * SYNTAX ERROR
[2198] AC89 03              BYTE 3             *   (shared by SUBS)

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0038 
RXB 2024
[2199] AC8A 06,6A,84 ERRSNM CALL ERRZZ             * STRING-NUMBER MISMATCH
[2200] AC8D 07              BYTE 7             *   (shared by SUBS)
[2201] AC8E 06,6A,84 ERRMUV CALL ERRZZ             * IMPROPERLY USED NAME
[2202] AC91 09              BYTE 9
[2203] AC92 06,6A,84 ERRMEM CALL ERRZZ             * MEMORY FULL
[2204] AC95 0B              BYTE 11
[2205] AC96 06,6A,84 ERRSO  CALL ERRZZ             * STACK OVERFLOW
[2206] AC99 0C              BYTE 12
[2207] AC9A 06,6A,84 ERRNWF CALL ERRZZ             * NEXT WITHOUT FOR
[2208] AC9D 0D              BYTE 13
[2209] AC9E 06,6A,84 ERRFNN CALL ERRZZ             * FOR/NEXT NESTING
[2210] ACA1 0E              BYTE 14
[2211] ACA2 06,6A,84 ERRSNS CALL ERRZZ             * MUST BE IN SUBPROGRAM
[2212] ACA5 0F              BYTE 15
[2213] ACA6 06,6A,84 ERRRSC CALL ERRZZ             * RECURSIVE SUBPROGRAM CALL
[2214] ACA9 10              BYTE 16
[2215] ACAA 06,6A,84 ERRRWG CALL ERRZZ             * RETURN WITHOUT GOSUB
[2216] ACAD 12              BYTE 18
[2217] ACAE 06,6A,84 ERRBS  CALL ERRZZ             * BAD SUBSCRIPT
[2218] ACB1 14              BYTE 20
[2219] ACB2 06,6A,84 ERRLNF CALL ERRZZ             * LINE NOT FOUND
[2220] ACB5 16              BYTE 22
[2221] ACB6 06,6A,84 ERRBA  CALL ERRZZ             * BAD ARGUMENTS
[2222] ACB9 1C              BYTE 28
[2223] ACBA 06,6A,84 ERRBV  CALL ERRZZ             * BAD VALUE
[2224] ACBD 1E              BYTE 30            *   (shared by SUBS)
[2225] ACBE 06,6A,84 ERRIAL CALL ERRZZ             * INCORRECT ARGUMENT LIST
[2226] ACC1 1F              BYTE 31            *   (shared by SUBS)
[2227] ACC2 06,6A,84 ERRSNF CALL ERRZZ             * SUBPROGRAM NOT FOUND
[2228] ACC5 25              BYTE 37
[2229]               * Other error messages appear in this program
[2230]               * ERRRDY      * READY                        DATA 0
[2231]               * ERRBRK      * BREAK POINT                  DATA 1
[2232]               * ERROLP      * ONLY LEGAL IN A PROGRAM      DATA 27
[2233]               *
[2234]               * WRNN01      * NUMERIC OVERFLOW             DATA 2
[2235]               * WRNS02
[2236]               * WRNST1      * STRING TRUNCATED             DATA 19
[2237]               * WRNST2
[2238]               * WRNLNF      * LINE NOT FOUND               DATA 38
[2239]               *
[2240]               ***********************************************************
[2241]               * SUBROUTINE LINK LIST
[2242] ACC6 AC,D1    LINKS1 DATA LINKS2
[2243] ACC8 06,53,50        STRI 'SPRITE'         SPRITE
       ACCB 52,49,54
       ACCE 45
[2244] ACCF AE,0C           DATA SPRTE
[2245] ACD1 AC,DF    LINKS2 DATA LINKS3
[2246] ACD3 09,44,45        STRI 'DELSPRITE'      DELSPRITE
       ACD6 4C,53,50
       ACD9 52,49,54
       ACDC 45
[2247] ACDD AE,3D           DATA SPRDEL
[2248] ACDF AC,EC    LINKS3 DATA LINKS4
[2249] ACE1 08,50,4F        STRI 'POSITION'       POSITION
       ACE4 53,49,54
       ACE7 49,4F,4E
[2250] ACEA AE,65           DATA SPRPOS
[2251] ACEC AC,F6    LINKS4 DATA LINKS5
[2252] ACEE 05,43,4F        STRI 'COINC'          CONIC
       ACF1 49,4E,43
[2253] ACF4 B8,85           DATA ZSCOI
[2254] ACF6 AD,02    LINKS5 DATA LINKS6

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0039 
RXB 2024
[2255] ACF8 07,4D,41        STRI 'MAGNIFY'        MAGNIFY
       ACFB 47,4E,49
       ACFE 46,59
[2256] AD00 AE,DB           DATA SPRMAG
[2257] AD02 AD,0D    LINKS6 DATA LINKS7
[2258] AD04 06,4D,4F        STRI 'MOTION'         MOTION
       AD07 54,49,4F
       AD0A 4E
[2259] AD0B AE,F8           DATA SPRMOV
[2260] AD0D AD,18    LINKS7 DATA LINKS8
[2261] AD0F 06,4C,4F        STRI 'LOCATE'         LOCATE
       AD12 43,41,54
       AD15 45
[2262] AD16 AF,08           DATA SPRLOC
[2263] AD18 AD,24    LINKS8 DATA LINKS9
[2264] AD1A 07,50,41        STRI 'PATTERN'        PATTERN
       AD1D 54,54,45
       AD20 52,4E
[2265] AD22 AF,1C           DATA SPRPAT
[2266] AD24 AD,31    LINKS9 DATA LINKSA
[2267] AD26 08,44,49        STRI 'DISTANCE'       DISTANCE
       AD29 53,54,41
       AD2C 4E,43,45
[2268] AD2F B8,94           DATA ZDIST
[2269] AD31 AD,39    LINKSA DATA LINKSB
[2270] AD33 03,53,41        STRI 'SAY'            SAY
       AD36 59
[2271] AD37 B0,90           DATA SAY
[2272] AD39 AD,43    LINKSB DATA LINKSC
[2273] AD3B 05,53,50        STRI 'SPGET'          SPGET   
       AD3E 47,45,54
[2274] AD41 B1,E7           DATA SPGET
[2275] AD43 AD,4F    LINKSC DATA LINKSD
[2276] AD45 07,43,48        STRI 'CHARSET'        CHARSET
       AD48 41,52,53
       AD4B 45,54
[2277] AD4D AF,94           DATA CHRSET
[2278] AD4F AD,59    LINKSD DATA LINKSE
[2279] AD51 05,4F,4E        STRI 'ONKEY'          ONKEY
       AD54 4B,45,59
[2280] AD57 B9,0C           DATA  ZONKEY
[2281] AD59 AD,63    LINKSE DATA LINKSF
[2282] AD5B 05,4D,4F        STRI 'MOVES'          MOVES
       AD5E 56,45,53
[2283] AD61 B4,E1           DATA MOVES
[2284] AD63 AD,6C    LINKSF DATA LINKSG
[2285] AD65 04,48,50        STRI 'HPUT'           HPUT
       AD68 55,54
[2286] AD6A B7,60           DATA HPUTZ
[2287] AD6C AD,75    LINKSG DATA LINKSH
[2288] AD6E 04,56,50        STRI 'VPUT'           VPUT
       AD71 55,54
[2289] AD73 B7,70           DATA VPUTZ
[2290] AD75 AD,7E    LINKSH DATA LINKSI
[2291] AD77 04,48,47        STRI 'HGET'           HGET
       AD7A 45,54
[2292] AD7C B7,AD           DATA HGETZ 
[2293] AD7E AD,87    LINKSI DATA LINKSJ
[2294] AD80 04,56,47        STRI 'VGET'           VGET
       AD83 45,54
[2295] AD85 B7,C0           DATA VGETZ
[2296] AD87 AD,93    LINKSJ DATA LINKSK
[2297] AD89 07,47,4D        STRI 'GMOTION'        GMOTION
       AD8C 4F,54,49

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0040 
RXB 2024
       AD8F 4F,4E
[2298] AD91 B7,F2           DATA GMOT
[2299] AD93 AD,9F    LINKSK DATA LINKSL
[2300] AD95 07,52,4D        STRI 'RMOTION'        RMOTION
       AD98 4F,54,49
       AD9B 4F,4E
[2301] AD9D B8,29           DATA RMOT
[2302] AD9F AD,A7    LINKSL DATA LINKSM
[2303] ADA1 03,48,45        STRI 'HEX'            HEX
       ADA4 58
[2304] ADA5 B5,CE           DATA HEX
[2305] ADA7 AD,AE    LINKSM DATA LINKSN
[2306] ADA9 02,49,4F        STRI 'IO'             IO
[2307] ADAC B6,9B           DATA RXBIO
[2308] ADAE AD,BC    LINKSN DATA LINKSO
[2309] ADB0 09,4A,4F        STRI 'JOYMOTION'      JOYMOTION
       ADB3 59,4D,4F
       ADB6 54,49,4F
       ADB9 4E
[2310] ADBA BA,48           DATA ZJOMO
[2311] ADBC AD,CA    LINKSO DATA LINKSP
[2312] ADBE 09,4A,4F        STRI 'JOYLOCATE'      JOYLOCATE 
       ADC1 59,4C,4F
       ADC4 43,41,54
       ADC7 45
[2313] ADC8 BB,02           DATA ZJOLO
[2314] ADCA AD,D6    LINKSP DATA LINKSQ
[2315] ADCC 07,49,4E        STRI 'INVERSE'        INVERSE
       ADCF 56,45,52
       ADD2 53,45
[2316] ADD4 BB,A4           DATA INVERS
[2317] ADD6 AD,E3    LINKSQ DATA LINKSR
[2318] ADD8 08,53,57        STRI 'SWAPCHAR'       SWAPCHAR
       ADDB 41,50,43
       ADDE 48,41,52
[2319] ADE1 BB,E1           DATA SWCHR
[2320] ADE3 AD,F1    LINKSR DATA LINKSS       
[2321] ADE5 09,53,57        STRI 'SWAPCOLOR'      SWAPCOLOR
       ADE8 41,50,43
       ADEB 4F,4C,4F
       ADEE 52
[2322] ADEF BC,13           DATA SWCLR
[2323] ADF1 AE,00    LINKSS DATA LINKST
[2324] ADF3 0A,43,4C        STRI 'CLEARPRINT'     CLEARPRINT       
       ADF6 45,41,52
       ADF9 50,52,49
       ADFC 4E,54
[2325] ADFE A9,90           DATA  CLRPZ
[2326] AE00 C0,10    LINKST DATA >C010  * LINK LIST IN >C000          
[2327] AE02 07,43,4F        STRI 'COLLIDE'        COLLIDE
       AE05 4C,4C,49
       AE08 44,45
[2328] AE0A BC,8D           DATA COLLZ
[2329]               ***********************************************************
[2330]               * CALL SPRITE(#SPRITE,CHAR,COLOR,Y,X,(YSPEED,XSPEED),...) *
[2331]               ***********************************************************
[2332] AE0C 06,A9,67 SPRTE  CALL COMB             Check sprite mode and skip "(
[2333] AE0F 06,AF,D6        CALL SPNUM2            Get sprite number
[2334] AE12 06,B0,0C SPRT3  CALL SPCHR             Put character number for spri
[2335] AE15 0F,7E           XML  SPEED             Check for comma and skip it
[2336] AE17 00              BYTE SYNCHK
[2337] AE18 B3              BYTE COMMAZ        
[2338] AE19 06,A8,FA        CALL SPCOL             Put sprite color in SAL(SPCOL
[2339] AE1C 0F,7E           XML  SPEED             Insure at a comma  

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0041 
RXB 2024
[2340] AE1E 00              BYTE SYNCHK          * Syntax checker
[2341] AE1F B3              BYTE COMMAZ          * Only COMMA is valid
[2342] AE20 06,AF,EF        CALL SPLOC             Put location of sprite in SAL
[2343] AE23 BD,B0,08        DST  @PAD4+1,V*PAD8    Put in location of sprite
       AE26 05
[2344]               * Finish defining SAL. Check if velocity is specified
[2345] AE27 D6,42,B3 SPRT4  CEQ  COMMAZ,@CHAT      Finished!!!!!
[2346] AE2A 48,82           BR   LNKRTN
[2347] AE2C 0F,79           XML  PGMCHR            Skip COMMA
[2348] AE2E D6,42,FD        CEQ  NUMBEZ,@CHAT      Next sprite specified
[2349] AE31 4E,38           BR   GAEBB
[2350] AE33 06,AF,DD        CALL SPNUM3            Get the next sprite number
[2351] AE36 4E,12           BR   SPRT3             And go!
[2352] AE38 06,B0,1E GAEBB  CALL SPMOVE            Get the velocity first
[2353] AE3B 4E,27           BR   SPRT4
[2354]               ***********************************************************
[2355]               * CALL DELSPRITE(#SPR,...)                                *
[2356]               * CALL DESPRITE(ALL)                                      *
[2357]               ***********************************************************
[2358] AE3D 06,A9,67 SPRDEL CALL COMB              Insure at '('
[2359] AE40 0F,79    SPDEL1 XML  PGMCHR            Skip "(" or ","
[2360] AE42 D6,42,FD        CEQ  NUMBEZ,@CHAT      If sprite number
[2361] AE45 4E,5C           BR   GAEF6             No, must be ALL  
[2362] AE47 0F,79           XML  PGMCHR            Skip "#"
[2363] AE49 0F,74           XML  PARSE             Parse the sprite number
[2364] AE4B B6              BYTE RPARZ
[2365] AE4C 06,AF,E2        CALL SPNUM4            Check and convert number
[2366]               * Sprite handling code for speeeding up XB   2/4/2024
[2367] AE4F 86,8F,DD        CLR  @>6004          * SET ROM 3 ON
       AE52 04
[2368] AE53 0F,84           XML  SPDEL           * ASSEMBLY REPLACEMENT
[2369] AE55 D6,42,B3 SPDEL2 CEQ  COMMAZ,@CHAT      If more sprites
[2370] AE58 6E,40           BS   SPDEL1            LOOP
[2371] AE5A 48,82           BR   LNKRTN            Return to caller
[2372] AE5C 0F,7E    GAEF6  XML  SPEED             Must have 'ALL' else error
[2373] AE5E 00              BYTE SYNCHK
[2374] AE5F EC              BYTE ALLZ
[2375] AE60 06,60,16        CALL SPRINT            Reinitialize all sprites
[2376] AE63 48,82    GAEFD  BR   LNKRTN            Return to caller
[2377]               ***********************************************************
[2378]               * CALL POSTION(#SPR,Y,X,...)                              *
[2379]               ***********************************************************
[2380] AE65 06,A9,67 SPRPOS CALL COMB             Check for sprites and skip "(
[2381] AE68 06,AF,D6 SPRP02 CALL SPNUM2            Check sprite number
[2382] AE6B 06,B0,7D        CALL PREPN             Prepare Y-position return v  
[2383] AE6E 0F,7E           XML  SPEED           * SPEED CHECK
[2384] AE70 00              BYTE SYNCHK          * Syntax checker
[2385] AE71 B3              BYTE COMMAZ          * Only COMMA is valid
[2386] AE72 BD,00,B0        DST  V*PAD8,@PAD       Read X, Y position
       AE75 08
[2387] AE76 BC,4B,00        ST   @PAD,@FAC1        Get Y position
[2388] AE79 D6,4B,FE        CEQ  >FE,@FAC1
[2389] AE7C 4E,82           BR   GAF1C
[2390] AE7E 95,4A           DINCT @FAC             Get 256 as an output
[2391] AE80 4E,84           BR   GAF1E
[2392] AE82 94,4B    GAF1C  INCT @FAC1             Regular adjustment for user
[2393] AE84 06,AE,99 GAF1E  CALL SPRP03            Check, convert & assign value
[2394] AE87 06,B0,7D        CALL PREPN             Prepare X-pos return variable
[2395] AE8A BC,4B,01        ST   @PAD+1,@FAC1      Get X position
[2396] AE8D 91,4A           DINC @FAC              Adjust for the user
[2397] AE8F 06,AE,99        CALL SPRP03            Check, convert & assign value
[2398] AE92 D6,42,B3        CEQ  COMMAZ,@CHAT      If not finished
[2399] AE95 6E,68           BS   SPRP02
[2400] AE97 48,82           BR   LNKRTN             

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0042 
RXB 2024
[2401] AE99 0F,80    SPRP03 XML  CIF               Convert integer to float
[2402] AE9B D7,00,C0        DCEQ >C000,@PAD        If hidden sprite
       AE9E 00
[2403] AE9F 4E,A3           BR   GAF3D
[2404] AEA1 87,4A           DCLR @FAC              Return value zero
[2405] AEA3 0F,7C    GAF3D  XML  ASSGNV            Assign to variable
[2406] AEA5 00              RTN
[2407]               ***********************************************************
[2408]               * CALL COINC(#SPR,#SPR,TOLERANCE,CODE,...)                *
[2409]               * CALL COINC(#SPR,YLOC,XLOC,TOLERANCE,CODE,...)           *
[2410]               * CALL COINC(ALL,variable,...)                            *
[2411]               ***********************************************************
[2412] AEA6 06,A9,67 SPRCOI CALL COMB              (?
[2413] AEA9 0F,79           XML  PGMCHR            Skip "("
[2414] AEAB D6,42,EC        CEQ  ALLZ,@CHAT        Check coinc of all sprites
[2415] AEAE 4E,BC           BR   GAF56
[2416] AEB0 0F,79           XML  PGMCHR            Skip "ALL"
[2417] AEB2 06,B0,67        CALL COMMA2            Check and skip ","
[2418] AEB5 DA,7B,20        CLOG >20,@VDPSTT       Check VDP status
[2419] AEB8 70,77           BS   NR
[2420] AEBA 4E,D2           BR   GAF6C
[2421] AEBC 06,AF,54 GAF56  CALL CODIST            Get distance of 2 sprites
[2422] AEBF 06,B0,64        CALL COMMA             Get tolerance level
[2423] AEC2 0F,7E           XML  SPEED
[2424] AEC4 02              BYTE RANGE           * Check against range
[2425] AEC5 00              BYTE 0               * FAC has tolerance level
[2426] AEC6 00,FF           DATA 255
[2427] AEC8 C5,00,4A        DCH  @FAC,@PAD         Y-loc out of range
[2428] AECB 70,77           BS   NR
[2429] AECD C5,04,4A        DCH  @FAC,@PAD4        X-loc out of range
[2430] AED0 70,77           BS   NR
[2431]               * If no conincidence just return zero
[2432] AED2 06,B0,7D GAF6C  CALL PREPN             Prepare for numeric output
[2433] AED5 BF,4A,BF        DST  >BFFF,@FAC        Store -1 in FAC
       AED8 FF
[2434] AED9 50,7A           BR   AR
[2435]               ***********************************************************
[2436]               * CALL MAGNIFY(magnification factor=1 - 4)                *
[2437]               * CALL MAGNIFY(number,number,number)                      *
[2438]               * CALL MAGNIFY(variable,variable,variable)                *
[2439]               ***********************************************************
[2440] AEDB 06,A9,67 SPRMAG CALL COMB             Insure at "("
[2441] AEDE 0F,79    SPRMLP XML  PGMCHR            Skip the "("
[2442] AEE0 0F,74           XML  PARSE             Parse the magnification facto
[2443] AEE2 B6              BYTE RPARZ          
[2444] AEE3 0F,7E           XML  SPEED
[2445] AEE5 02              BYTE RANGE            * Magnification 1 to 4
[2446] AEE6 01              BYTE 1              
[2447] AEE7 00,04           DATA 4
[2448]               * Next statement adding >DF to subtract 1 from FAC
[2449] AEE9 A2,4B,DF        ADD  >DF,@FAC1         Turn on screen and interrupt
[2450] AEEC 3D,00,01        MOVE 1,@FAC1,#1        Store it to VDP register 1
       AEEF 01,4B
[2451] AEF1 D6,42,B3        CEQ  COMMAZ,@CHAT      COMMA?
[2452] AEF4 6E,DE           BS   SPRMLP            Yes, loop
[2453] AEF6 48,82           BR   LNKRTN            Return to XB
[2454]               ***********************************************************
[2455]               * CALL MOTION(#SPR,YSPEED,XSPEED,...)                     *
[2456]               ***********************************************************
[2457] AEF8 06,A9,67 SPRMOV CALL COMB              Insure at "("
[2458] AEFB 05,B9,CF SPRMV2 B    SPGS              # or ALL or GO or STOP
[2459] AEFE 06,B0,1E SPRMV3 CALL SPMOVE            Store velocity
[2460] AF01 D6,42,B3 SPRMV4 CEQ  COMMAZ,@CHAT      Loop if more
[2461] AF04 6E,FB           BS   SPRMV2

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0043 
RXB 2024
[2462] AF06 48,82           BR   LNKRTN
[2463]               ***********************************************************
[2464]               * CALL LOCATE(#SPR,YLOC,XLOC,...)                         *
[2465]               ***********************************************************
[2466] AF08 06,A9,67 SPRLOC CALL COMB              Insure at "("
[2467] AF0B 06,AF,D6 SPRLC2 CALL SPNUM2            Check sprite number
[2468] AF0E 06,AF,EF        CALL SPLOC             Read location
[2469] AF11 BD,B0,08        DST  @PAD4+1,V*PAD8    Put in sprite location
       AF14 05
[2470] AF15 D6,42,B3        CEQ  COMMAZ,@CHAT      Loop if more
[2471] AF18 6F,0B           BS   SPRLC2
[2472] AF1A 48,82           BR   LNKRTN
[2473]               ***********************************************************
[2474]               * CALL PATTERN(#SPR,CHAR,...)                             *
[2475]               ***********************************************************
[2476] AF1C 06,A9,67 SPRPAT CALL COMB             Insure at "("
[2477] AF1F 06,AF,D6 SPRPT2 CALL SPNUM2            Get sprite number
[2478] AF22 06,B0,0C        CALL SPCHR             Set the sprite character
[2479] AF25 D6,42,B3        CEQ  COMMAZ,@CHAT      Loop if more
[2480] AF28 6F,1F           BS   SPRPT2
[2481] AF2A 48,82           BR   LNKRTN
[2482]               ***********************************************************
[2483]               * CALL DISTANCE(#1,#2,DISTANCE,...)                       *
[2484]               * CALL DISTANCE(#1,Y,X,DISTANCE,...)                      *
[2485]               ***********************************************************
[2486] AF2C 06,A9,67 DIST   CALL COMB             Insure at "("
[2487]               * RXB PATCH LABEL ************
[2488] AF2F 0F,79    GAFC4  XML  PGMCHR            Skip "("
[2489] AF31 06,AF,54        CALL CODIST            Get distance in Y and X
[2490] AF34 06,B0,7D        CALL PREPN             Prepare return variable
[2491] AF37 A9,00,00        DMUL @PAD,@PAD         X=X*X
[2492] AF3A A9,04,04        DMUL @PAD4,@PAD4       Y=Y*Y
[2493] AF3D A1,02,06        DADD @PAD6,@PAD2       @PAD2=X*X+Y*Y
[2494] AF40 0D              OVF                    Checking overflow bit
[2495] AF41 6F,4C           BS   OVER              If overflow-indicate maximum
[2496] AF43 BD,4A,02        DST  @PAD2,@FAC        Put distance squared in FAC
[2497] AF46 C7,02,7F        DCH  >7FFF,@PAD2       If bigger then 128
       AF49 FF
[2498] AF4A 4F,50           BR   GAFE5
[2499] AF4C BF,4A,7F OVER   DST  >7FFF,@FAC        Put maximum value
       AF4F FF
[2500] AF50 0F,80    GAFE5  XML  CIF               Convert to floating format
[2501]               * RXB PATCH CODE
[2502]               *      BR   ASSRTN            Assign value and return
[2503] AF52 50,7A           BR   AR
[2504]               ***********************************************************
[2505]               * CODIST routine gets locations of two sprites or one
[2506]               *  sprite and Y and X position specified by a user and
[2507]               *  calculates absolute value of Y and X distance.
[2508]               ***********************************************************
[2509] AF54 86,00    CODIST CLR  @PAD
[2510] AF56 35,00,07        MOVE 7,@PAD,@PAD+1     Clear up first 8 bytes
       AF59 01,00
[2511] AF5B D6,42,FD        CEQ  NUMBEZ,@CHAT      Check for #
[2512] AF5E 4C,86           BR   ERRSYN
[2513] AF60 06,AF,DD        CALL SPNUM3            Get the first sprite
[2514] AF63 BD,01,B0        DST  V*PAD8,@PAD+1     Location of first sprite
       AF66 08
[2515] AF67 90,01           INC  @PAD+1            Increment to make range 1-256
[2516] AF69 BC,03,02        ST   @PAD2,@PAD2+1     Put X in PAD2+1
[2517] AF6C 86,02           CLR  @PAD2             Y in PAD+1
[2518] AF6E D6,42,FD        CEQ  NUMBEZ,@CHAT      Get 2nd sprite
[2519] AF71 4F,7C           BR   CODIS1
[2520] AF73 06,AF,DD        CALL SPNUM3            Get the next sprite

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0044 
RXB 2024
[2521] AF76 BD,05,B0        DST  V*PAD8,@PAD4+1    Location of second sprite
       AF79 08
[2522] AF7A 4F,82           BR   CODIS2
[2523] AF7C 06,AF,EF CODIS1 CALL SPLOC             Get Y and X location
[2524] AF7F 06,B0,67        CALL COMMA2            Check for comma and skip
[2525] AF82 90,05    CODIS2 INC  @PAD4+1           Increment to make range 1-256
[2526] AF84 A5,00,04        DSUB @PAD4,@PAD        Difference in Y at PAD
[2527] AF87 81,00           DABS @PAD              Get absolute value
[2528] AF89 86,05           CLR  @PAD4+1           Clear byte before X
[2529] AF8B A5,05,02        DSUB @PAD2,@PAD4+1     Difference in Y at PAD4
[2530] AF8E 81,05           DABS @PAD4+1           get the absolute value
[2531] AF90 BC,05,06        ST   @PAD6,@PAD4+1     Put in the right place
[2532] AF93 00              RTN
[2533]               ***********************************************************
[2534]               * CHRSET restores the standard character set and the
[2535]               *  standard colors for the standard character set
[2536]               *  (black on transparent)
[2537]               ***********************************************************
[2538]               * CALL CHARSET                                            *
[2539]               * CALL CHARSET(ALL) * RXB ADDITION *                      *
[2540]               ***********************************************************
[2541]               * RXB PATCH CODE ADDTION OF CALL CHARSET(ALL) *************
[2542] AF94 D6,42,B7 CHRSET CEQ  LPARZ,@CHAT   * (?
[2543] AF97 6F,B0           BS   CHRALL        * Yes, CHARSET(ALL)
[2544] AF99 86,8F,DD        CLR  @>6004       * SET ROM 3 ON
       AF9C 04
[2545] AF9D 0F,7F           XML  CHRLDR       * LOAD ROM 3 Definitions
[2546] AF9F BE,A8,0F        ST   >10,V@>080F  * Set 1st black on transparent
       AFA2 10
[2547] AFA3 35,00,10        MOVE 16,V@>080F,V@>0810 * Ripple for rest
       AFA6 A8,10,A8
       AFA9 0F
[2548] AFAA 06,6A,78        CALL CHKEND        * Must be at EOS now
[2549] AFAD 06,00,12        CALL RETURN        * Return to the caller
[2550]               *******************************************************   
[2551] AFB0 0F,79    CHRALL XML  PGMCHR        * Skip (
[2552] AFB2 D6,42,EC        CEQ  ALLZ,@CHAT    * ALL?
[2553] AFB5 4C,86           BR   ERRSYN        * No Syntax error
[2554] AFB7 0F,79           XML  PGMCHR        * Skip ALL token up to )
[2555] AFB9 86,8F,DD        CLR  @>6004        * SET ROM 3 ON
       AFBC 04
[2556] AFBD 0F,7F           XML  CHRLDR        * LOAD ROM 3 Definitions 
[2557] AFBF 86,A7,00        CLR  V@>0700       * Clear byte
[2558] AFC2 35,00,FF        MOVE 255,V@>0700,V@>0701 * Ripple the rest
       AFC5 A7,01,A7
       AFC8 00
[2559] AFC9 BE,A8,0F        ST   >10,V@>080F * Set 1st Black on Transparent
       AFCC 10
[2560] AFCD 35,00,10        MOVE 16,V@>080F,V@>0810 * Ripple the rest
       AFD0 A8,10,A8
       AFD3 0F
[2561] AFD4 48,82           BR   LNKRTN        * RETURN
[2562]               *******************************************************
[2563]               * OLD SPNUM1 REPLACED WITH COMB NOW *
[2564]               *************************************
[2565]               * SPNUM2 ROUTINE             *
[2566]               ******************************
[2567] AFD6 0F,79    SPNUM2 XML  PGMCHR            Get the next character
[2568] AFD8 D6,42,FD SPNUM6 CEQ  NUMBEZ,@CHAT      Must be "#"
[2569] AFDB 4C,86           BR   ERRSYN
[2570] AFDD 0F,79    SPNUM3 XML  PGMCHR            Skip character # or ( or ,
[2571] AFDF 06,B0,64        CALL COMMA             Parse up to comma and skip it
[2572] AFE2 0F,7E    SPNUM4 XML  SPEED
[2573] AFE4 02              BYTE RANGE           * Verify the value is in range

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0045 
RXB 2024
[2574] AFE5 01              BYTE 1               * Sprite number 1 - 28
[2575] AFE6 00,1C           DATA 28
[2576]               *----------------------------------------------------------
[2577]               * Sprite handling code for speeeding up XB   2/4/2024
[2578] AFE8 86,8F,DD SPNUM5 CLR  @>6004          * SET ROM 3 ON
       AFEB 04
[2579] AFEC 0F,83           XML  SPSPD5          * ASSEMBLY REPLACEMENT
[2580] AFEE 00              RTN
[2581]               ******************************
[2582]               * SPLOC ROUTINE              *
[2583]               ******************************
[2584] AFEF 06,B0,64 SPLOC  CALL COMMA             Parse up to comma and skip it
[2585] AFF2 0F,7E    SPLOC2 XML  SPEED
[2586] AFF4 02              BYTE RANGE           * Range of Y: 1 - 256
[2587] AFF5 01              BYTE 1
[2588] AFF6 01,00           DATA 256
[2589] AFF8 96,4B           DECT @FAC1             Adjust for internal use: FF -
[2590] AFFA BD,04,4A        DST  @FAC,@PAD4        Store in PAD4 area
[2591] AFFD 0F,74           XML  PARSE
[2592] AFFF B6              BYTE RPARZ           * Parse to ")" or less
[2593] B000 0F,7E           XML  SPEED
[2594] B002 02              BYTE RANGE           * Get X value. Range: 1 - 256
[2595] B003 01              BYTE 1
[2596] B004 01,00           DATA 256
[2597] B006 92,4B           DEC  @FAC1             Adjust for internal use: 0 -
[2598] B008 BC,06,4B        ST   @FAC1,@PAD6       PAD4+1=Y-loc and PAD6=X-loc
[2599] B00B 00              RTN
[2600]               ******************************
[2601]               * SPCHR ROUTINE              *
[2602]               ******************************
[2603] B00C 0F,74    SPCHR  XML  PARSE
[2604] B00E B6              BYTE RPARZ
[2605] B00F 0F,7E           XML  SPEED
[2606] B011 02              BYTE RANGE           * Check upper range
[2607] B012 1E              BYTE 30
[2608] B013 00,9F           DATA 159
[2609] B015 A2,4B,60        ADD  >60,@FAC1         Add offset to character numbe
[2610] B018 BC,E0,02        ST   @FAC1,V@2(@PAD8)  Store the character value
       B01B 08,4B
[2611] B01D 00              RTN
[2612]               ******************************
[2613]               * SPMOVE ROUTINE             *
[2614]               ******************************
[2615] B01E 06,B0,64 SPMOVE CALL COMMA             Parse up to comma and skip
[2616] B021 06,B0,40        CALL RANGEV            Check if numeric and convert
[2617]               *                              to integer
[2618] B024 BC,0A,4B        ST   @FAC1,@PADA       Store Y velocity
[2619] B027 0F,74           XML  PARSE             Get X velocity
[2620] B029 B6              BYTE RPARZ           * Check for ")" or less
[2621] B02A 06,B0,40        CALL RANGEV            Numeric check and convert
[2622]               *                              to integer
[2623] B02D BC,4A,0A        ST   @PADA,@FAC      * @FAC=Y velocity, @FAC1=X velo
[2624] B030 BD,E4,80        DST  @FAC,V@>0480(@PAD8) Store velocities in SAL
       B033 08,4A
[2625]               *----------------------------------------------------------
[2626]               * Add the following 3 lines for speeding up XB
[2627] B035 C4,A3,AA        CH   @NOMSPR,V@SPNUM   Check current sprite
       B038 7A
[2628] B039 50,3F           BR   SPMOVF             against sprite motion
[2629]               *                               counter
[2630] B03B BC,7A,A3        ST   V@SPNUM,@NOMSPR   higher? Yes, replace it
       B03E AA
[2631]               *----------------------------------------------------------
[2632] B03F 00       SPMOVF RTN

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0046 
RXB 2024
[2633]               *****************************
[2634]               * RANGEV ROUTINE            *
[2635]               *****************************
[2636] B040 C6,4C,63 RANGEV CH   >63,@FAC2         The same as INTARG
[2637] B043 6C,8A           BS   ERRSNM      ERROR STRING NUMBER MISMATCH
[2638] B045 86,54           CLR  @FAC10            For FLTINT
[2639] B047 87,6C           DCLR @FPERAD
[2640] B049 0F,12           XML  FLTINT            FP TO INTEGER
[2641] B04B 8E,54           CZ   @FAC10
[2642] B04D 4C,BA           BR   ERRBV       ERROR BAD VALUE      
[2643] B04F D3,4A,00        DCGE 0,@FAC            If positive number,
       B052 00
[2644] B053 50,5D           BR   GB0DB
[2645] B055 C7,4A,00        DCH  >007F,@FAC         should be 0 - 127
       B058 7F
[2646] B059 6C,BA           BS   ERRBV       ERROR BAD VALUE
[2647] B05B 50,63           BR   GB0E1             If negative number,
[2648] B05D CB,4A,FF GB0DB  DCHE >FF80,@FAC         Should be -1 to -128
       B060 80
[2649] B061 4C,BA           BR   ERRBV       ERROR BAD VALUE
[2650] B063 00       GB0E1  RTN                    Otherwise its ok.
[2651]               ******************************
[2652]               * COMMA ROUTINE              *
[2653]               ******************************
[2654] B064 0F,74    COMMA  XML  PARSE
[2655] B066 B3              BYTE COMMAZ
[2656] B067 D6,42,B3 COMMA2 CEQ  COMMAZ,@CHAT
[2657] B06A 4C,86           BR   ERRSYN            ERROR SYNTAX 
[2658] B06C 0F,79           XML  PGMCHR            Skip COMMA
[2659] B06E 00              RTN
[2660]               ******************************
[2661]               * LINK BACK TO XB            *
[2662]               ******************************
[2663] B06F 06,B0,7D NULRTN CALL PREPN
[2664] B072 0F,7C    ASSRTN XML  ASSGNV
[2665] B074 05,A8,82        B    LNKRTN
[2666]               *******************************
[2667]               * LINK RETURN TO GPL          *
[2668]               *******************************
[2669] B077 06,B0,7D NR     CALL PREPN
[2670] B07A 0F,7C    AR     XML  ASSGNV
[2671] B07C 00              RTN
[2672]               *******************************
[2673]               * PREPARE FOR PASSING ARGUMENT*
[2674]               *******************************
[2675] B07D 0F,7A    PREPN  XML  SYM               Pick up name & search table
[2676] B07F 0F,7B           XML  SMB               Evaluate any subscripts
[2677] B081 C6,4C,63        CH   >63,@FAC2         If not numeric, error
[2678] B084 6C,BE           BS   ERRIAL
[2679] B086 0F,77           XML  VPUSH             Save entry on stack
[2680] B088 86,4A           CLR  @FAC              Clear FAC for new value
[2681] B08A 35,00,07        MOVE 7,@FAC,@FAC1
       B08D 4B,4A
[2682] B08F 00              RTN
[2683]               ***********************************************************
[2684]               * CALL SAY(....................)                          *
[2685]               *  Decode given parameter(s). Store all data first, then  *
[2686]               *   go speak it all at once.                              *
[2687]               ***********************************************************
[2688] B090 06,A9,67 SAY    CALL COMB              Must start with "("
[2689] B093 BD,4C,6E        DST  @VSPTR,@FAC2      Save current top of stack on
[2690] B096 0F,77           XML  VPUSH              the stack
[2691] B098 BF,0C,00        DST  255,@BYTES        255 bytes = 85 3 byte entires
       B09B FF

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0047 
RXB 2024
[2692] B09C 0F,71           XML  GETSTR            Get temp speech list string
[2693] B09E BF,4A,00        DST  >001C,@FAC        Indicate it is temp string (S
       B0A1 1C
[2694] B0A2 BF,4C,65        DST  >6500,@FAC2       Indicate it is string entry
       B0A5 00
[2695] B0A6 BD,4E,1C        DST  @SREF,@FAC4       Save pointer to temp string
[2696] B0A9 BD,50,0C        DST  @BYTES,@FAC6      Length is 255
[2697] B0AC 0F,77           XML  VPUSH             Make it semi-permenant
[2698]               * Set up pointers into the speak list
[2699] B0AE BD,00,4E        DST  @FAC4,@PTFBSL     Front points to begining
[2700] B0B1 BD,02,4E        DST  @FAC4,@PTLBSL     Last now points to beginning
[2701] B0B4 BD,04,00        DST  @PTFBSL,@PTEBSL
[2702] B0B7 A1,04,50        DADD @FAC6,@PTEBSL     End points to the end+1
[2703] B0BA 06,B4,D6        CALL SETRW             Set PHROM read/write address
[2704] B0BD 06,B4,CB        CALL WAIT              Wait till no one is speaking
[2705] B0C0 06,B2,A3 DIRSPK CALL GETPRM            Get next parameter
[2706] B0C3 71,37           BS   NEXT1             If non-null ASCII string
[2707] B0C5 BD,06,4E        DST  @FAC4,@PTFCIS     Set up pointer to first char
[2708] B0C8 BD,0A,50        DST  @FAC6,@PTLCIS     Set ptr-to-last-char-in-strin
[2709] B0CB A1,0A,06        DADD @PTFCIS,@PTLCIS    by adding length-of-string
[2710] B0CE 93,0A           DDEC @PTLCIS            and subtracting 1
[2711]               * Make a speech list
[2712] B0D0 06,B4,D6        CALL SETRW             Set speech read/write addrs
[2713] B0D3 BD,08,06        DST  @PTFCIS,@PTCCIS   Start at beginning of string
[2714] B0D6 86,4C           CLR  @TOTTIM           Clear total time delay
[2715] B0D8 06,B3,20        CALL GETTIM            Get first timing mark
[2716] B0DB 06,B3,10        CALL TIMING            Get any subsequent marks
[2717]               * The total first time delay is in TOTTIM now
[2718] B0DE C5,08,0A GB158  DCH  @PTLCIS,@PTCCIS   While more string
[2719] B0E1 71,2D           BS   GB1A7
[2720] B0E3 06,B2,B9        CALL PHRASE            Get next phrase
[2721]               * If spell flag is 0, try to look the phrase up. If it
[2722]               * can not be found, then set the spell flag, and it will be
[2723]               * spelled out. If found, save on speak list.
[2724] B0E6 8E,4B           CZ   @SPLFLG           There is a phrase
[2725] B0E8 50,F9           BR   GB173
[2726] B0EA 06,B3,B5        CALL LOOKUP            Try to look it up in the PHRO
[2727] B0ED 8F,4D           DCZ  @DATAAD           If not found then
[2728] B0EF 50,F6           BR   GB170
[2729] B0F1 BE,4B,01        ST   1,@SPLFLG         Set the spell flag
[2730] B0F4 50,F9           BR   GB173
[2731] B0F6 06,B4,BB GB170  CALL STDATA            Store data in list
[2732]               * If spell flag is 1, set time delay to >3C, and take the
[2733]               * phrase one character at a time (spell it). Look up each
[2734]               * character: if not found, use 'UHOH' data instead.
[2735]               * Regardless, store data on speak list.
[2736] B0F9 D6,4B,01 GB173  CEQ  1,@SPLFLG         Need to spell it out?
[2737] B0FC 51,26           BR   GB1A0
[2738] B0FE BD,4F,10        DST  @PTLCIP,@PTLCIL   Est last char to spell out
[2739] B101 BE,4C,3C        ST   >3C,@TOTTIM       >3C used because sounds good
[2740]               *                      Take each single character
[2741]               * Skip over any embedded spaces encountered in a phrase
[2742] B104 D6,B0,0C GB17E  CEQ  SPACE,V*PTFCIP
       B107 20
[2743] B108 51,0E           BR   GB188
[2744] B10A 91,0C           DINC @PTFCIP
[2745] B10C 51,04           BR   GB17E
[2746]               * Set first and last pointers to same one character
[2747] B10E BD,10,0C GB188  DST  @PTFCIP,@PTLCIP
[2748] B111 06,B3,B5        CALL LOOKUP            Try to look it up
[2749]               * If not found, use data to 'UHOH'
[2750] B114 8F,4D           DCZ  @DATAAD
[2751] B116 51,1C           BR   GB196
[2752] B118 BF,4D,71        DST  >71F4,@DATAAD     Put addr of 'UHOH' in

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0048 
RXB 2024
       B11B F4
[2753] B11C 06,B4,BB GB196  CALL STDATA            Store data on speak list
[2754] B11F 91,0C           DINC @PTFCIP           Go on to next character
[2755] B121 C5,0C,4F        DCH  @PTLCIL,@PTFCIP   Until done all
[2756] B124 51,04           BR   GB17E
[2757]               * At this point, get next timing group. The first timing
[2758]               * character has already been found, and it's value is still
[2759]               * in TIMLEN. Therefore, initiatory call to GETTIM not
[2760]               * needed. Simply clear TOTTIM and call TIMING.
[2761] B126 86,4C    GB1A0  CLR  @TOTTIM
[2762] B128 06,B3,10        CALL TIMING
[2763] B12B 50,DE           BR   GB158
[2764]               * At this point, finished all the phrases in this string.
[2765]               * TOTTIM should equal >FE, it indicate end of sting If it
[2766]               * doesn't equal >FE, it indicates that a timing group was
[2767]               * put on the end of the string. Therefore, save the timing
[2768]               * group with a null data address to show it is only timing.
[2769] B12D D6,4C,FE GB1A7  CEQ  >FE,@TOTTIM
[2770] B130 71,37           BS   NEXT1
[2771] B132 87,4D           DCLR @DATAAD
[2772] B134 06,B4,BB        CALL STDATA
[2773]               * Next item could be direct string.
[2774] B137 D6,42,B3 NEXT1  CEQ  COMMAZ,@CHAT      If direct string present
[2775] B13A 51,51           BR   SPEAK
[2776] B13C 06,B2,A3        CALL GETPRM            Get the next parameter
[2777] B13F 71,4C           BS   NEXT2             If non-null direct string
[2778] B141 BE,4C,FF        ST   >FF,@TOTTIM       Mark TOTTIM as direct string
[2779] B144 0F,77           XML  VPUSH             Save direct string on stack
[2780] B146 BD,4D,6E        DST  @VSPTR,@DATAAD    Store stack addr on string
[2781] B149 06,B4,BB        CALL STDATA            And add to the speak list
[2782]               * If the next character is a comma, loop thru it again
[2783] B14C D6,42,B3 NEXT2  CEQ  COMMAZ,@CHAT
[2784] B14F 70,C0           BS   DIRSPK
[2785]               * If end fall into SPEAK
[2786]               ***********************************************************
[2787]               * SPEAK will actually speak the speech list. It tests the
[2788]               * timing byte to see if it is an >FF. If it is, then the
[2789]               * data following it points to a direct speech data string
[2790]               * in VDP. If it is not, then the data following it points
[2791]               * to a PHROM speech data list. In the first case, this
[2792]               * routine will issue a speak external command to the PHROM
[2793]               * and then feed bytes out to the PHROM as it requests them.
[2794]               * In the second case, the address will be loaded out to the
[2795]               * PHROM, and then a speak command will be issued.
[2796]               ***********************************************************
[2797] B151 06,B4,D6 SPEAK  CALL SETRW             Set read/write address
[2798] B154 C9,00,02 GB1CE  DCHE @PTLBSL,@PTFBSL   More speech list to go
[2799] B157 71,DE           BS   GB258
[2800] B159 06,B4,CB        CALL WAIT              Yes, wait until previous
[2801]               *                              speech is though
[2802] B15C D6,B0,00        CEQ  >FF,V*PTFBSL      External speech data
       B15F FF
[2803] B160 71,84           BS   GB1FE
[2804] B162 BC,79,B0        ST   V*PTFBSL,@TIMER   No, load timer
       B165 00
[2805] B166 82,79           NEG  @TIMER             and neg it to correct
[2806] B168 BD,12,E0        DST  V@1(@PTFBSL),@PTFBPH   Put addr into PTFBPH
       B16B 01,00
[2807] B16D A3,00,00        DADD 3,@PTFBSL               and skip to next node
       B170 03
[2808] B171 D2,79,00 LOOP1  CGE  0,@TIMER          Wait for time delay
[2809] B174 51,71           BR   LOOP1
[2810] B176 8E,12           CZ   @PTFBPH           If there is data
[2811] B178 71,82           BS   GB1FC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0049 
RXB 2024
[2812] B17A 06,B4,71        CALL LOADAD            Load the addr to PHROM
[2813] B17D BE,C0,00        ST   >50,@PAD(@WRITE)   and issue speak command
       B180 5A,50
[2814] B182 51,DB    GB1FC  BR   CONTIN
[2815] B184 91,00    GB1FE  DINC @PTFBSL           Speak external, skip over >FF
[2816] B186 BD,5E,B0        DST  V*PTFBSL,@PTCBED  Set up pointer to 1st byte
       B189 00
[2817] B18A BD,5E,E0        DST  V@4(@PTCBED),@PTCBED    in external speech data
       B18D 04,5E
[2818] B18F 95,00           DINCT @PTFBSL          Skip addr bytes
[2819] B191 BC,62,EF        ST   V@-1(@PTCBED),@LENWST  Get Len of whole string
       B194 FF,FF,5E
[2820] B197 A6,62,03 DIRSPH SUB  3,@LENWST         Minus 3 bytes overhead
[2821]               * All external speech strings start with a >60
[2822] B19A D6,B0,5E        CEQ  >60,V*PTCBED      Bad speech string
       B19D 60
[2823] B19E 4C,BA           BR   ERRBV
[2824] B1A0 06,B4,CB        CALL WAIT              Wait for go ahead
[2825] B1A3 95,5E           DINCT @PTCBED          Skip spk ext & 1st byte len
[2826] B1A5 BC,60,B0        ST   V*PTCBED,@LENCST  Get len of current string
       B1A8 5E
[2827] B1A9 91,5E           DINC @PTCBED           Skip len byte to 1st real byt
[2828] B1AB BE,56,10        ST   16,@TEMP2         Do 1st 16 bytes (fill buff)
[2829] B1AE BE,C0,00        ST   >60,@PAD(@WRITE)  Start Speak External
       B1B1 5A,60
[2830] B1B3 BC,C0,00 LOOPR  ST   V*PTCBED,@PAD(@WRITE) Write byte to PHROM
       B1B6 5A,B0,5E
[2831] B1B9 91,5E           DINC @PTCBED           Go to next byte
[2832] B1BB 92,62           DEC  @LENWST           1 less char in whole string
[2833] B1BD 71,DB           BS   CONTIN            Finished whole string?
[2834] B1BF 92,60           DEC  @LENCST           1 less char in curr string
[2835] B1C1 71,97           BS   DIRSPH            Finished current string?
[2836] B1C3 92,56           DEC  @TEMP2            1 less char in this loop
[2837] B1C5 51,B3           BR   LOOPR             Not finished curr loop yet?
[2838] B1C7 BC,69,C0 GB241  ST   @PAD(@READ),@SPKSTS Read status from PHROM
       B1CA 00,58
[2839]                
[2840]               * If the next statement is true, it means that speak was
[2841]               * probably interupted and that it is shot at this point.
[2842]               * Therefore, we are going to quit now.
[2843] B1CC DA,69,80        CLOG >80,@SPKSTS
[2844] B1CF 71,DB           BS   CONTIN
[2845] B1D1 DA,69,40        CLOG >40,@SPKSTS       Loop till buff below half
[2846] B1D4 71,C7           BS   GB241
[2847] B1D6 BE,56,08        ST   8,@TEMP2          Put 8 more bytes to PHROM
[2848] B1D9 51,B3           BR   LOOPR              and go do these
[2849] B1DB 05,B1,54 CONTIN B    GB1CE             We've said it all!!
[2850]               * Now pop all entries off stack that we put on!
[2851] B1DE 0F,78    GB258  XML  VPOP              Free up a temporary string
[2852] B1E0 D5,6E,4C        DCEQ @FAC2,@VSPTR
[2853] B1E3 51,DE           BR   GB258
[2854] B1E5 48,82           BR   LNKRTN       
[2855]               ***********************************************************
[2856]               * SPGET subprogram. Load speech data from external device.
[2857]               *       Use standard file I/O
[2858]               ***********************************************************
[2859]               * CALL SAY(word-string,return-string)                     *
[2860]               ***********************************************************
[2861] B1E7 06,A9,67 SPGET  CALL COMB             Must have left parenthesis
[2862] B1EA 06,B4,D6        CALL SETRW             Set PHROM read/write address
[2863] B1ED 06,B4,CB        CALL WAIT              Wait till no one is speaking
[2864] B1F0 06,B2,A3 NXTPAR CALL GETPRM            Get the next parameter
[2865] B1F3 8F,50           DCZ  @FAC6             If non-null ASCII string
[2866] B1F5 72,9C           BS   GB318

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0050 
RXB 2024
[2867] B1F7 BD,06,4E        DST  @FAC4,@PTFCIS     Pointer to 1st char in string
[2868] B1FA BD,0A,50        DST  @FAC6,@PTLCIS     Pointer to last-char-in-strin
[2869] B1FD A1,0A,06        DADD @PTFCIS,@PTLCIS    by adding length-of-string
[2870] B200 93,0A           DDEC @PTLCIS             and subtracting 1
[2871] B202 06,B4,D6        CALL SETRW             Set the speech read/write add
[2872] B205 BD,08,06        DST  @PTFCIS,@PTCCIS   Set curr char to first char
[2873] B208 86,4C           CLR  @TOTTIM           Clear total time delay
[2874] B20A 06,B3,20        CALL GETTIM            Get first timing mark
[2875] B20D 06,B3,10        CALL TIMING            Get any subsquent marks
[2876]               * Get one phrase, and look it up. If the phrase is not foun
[2877]               * substitute in 'UHOH'.
[2878] B210 C5,08,0A        DCH  @PTLCIS,@PTCCIS   Possible phrase
[2879] B213 72,9C           BS   GB318
[2880] B215 06,B2,B9        CALL PHRASE            Yes, go get it
[2881] B218 D6,4B,01        CEQ  1,@SPLFLG         Spell flag set then set
[2882] B21B 52,20           BR   GB29C
[2883] B21D BD,10,0C        DST  @PTFCIP,@PTLCIP    last ptr to first (1 char)
[2884] B220 06,B3,B5 GB29C  CALL LOOKUP            Look up the phrase
[2885] B223 8F,4D           DCZ  @DATAAD           If not there,
[2886] B225 52,2E           BR   GB2AA
[2887] B227 BF,4D,71        DST  >71F4,@DATAAD      use 'UHOH' data addr
       B22A F4
[2888] B22B BE,64,51        ST   >51,@STRLEN        'UHOH' data length
[2889]               * Data must be in PHRADD and PHLEN, so move it
[2890] B22E BD,01,4D GB2AA  DST  @DATAAD,@PHRADD
[2891] B231 BC,00,64        ST   @STRLEN,@PHLEN
[2892] B234 A2,00,03        ADD  3,@PHLEN          For overhead info
[2893]               * There must be a variable to put this data in. If not, err
[2894] B237 0F,7E           XML  SPEED
[2895] B239 00              BYTE SYNCHK
[2896] B23A B3              BYTE COMMAZ
[2897] B23B 0F,7A           XML  SYM               Find symbol in table
[2898] B23D 0F,7B           XML  SMB               Evaluate andy subscripts
[2899] B23F 0F,77           XML  VPUSH             Save for assignment
[2900] B241 86,0C           CLR  @BYTES            Two byte value
[2901] B243 BC,0D,00        ST   @PHLEN,@BYTES+1   Length of string needed
[2902] B246 0F,71           XML  GETSTR            Get a string for the data
[2903] B248 06,B4,D6        CALL SETRW             Set up speech read/write addr
[2904] B24B BF,4A,00        DST  >001C,@FAC        Now build string FAC entry
       B24E 1C
[2905] B24F BF,4C,65        DST  >6500,@FAC2       String ID
       B252 00
[2906] B253 BD,4E,1C        DST  @SREF,@FAC4       Pointer to string
[2907] B256 BD,50,0C        DST  @BYTES,@FAC6      Length of string
[2908] B259 BF,B0,1C        DST  >6000,V*SREF      Mark string as speech data
       B25C 60,00
[2909] B25E BC,E0,02        ST   @PHLEN,V@2(@SREF) Put in string length
       B261 1C,00
[2910] B263 A7,E0,01        DSUB 3,V@1(@SREF)       minus thei info
       B266 1C,00,03
[2911]               * LOADAD expects addr to be in PTFBPH, so move it.
[2912] B269 BD,12,01        DST  @PHRADD,@PTFBPH
[2913] B26C 06,B4,71        CALL LOADAD
[2914]               * Going to copy string from PHROM to VDP. The actual data
[2915]               * from PHROM is in bit-reversed order, so must reverse the
[2916]               * order after reading in the order. Remember that 3 bytes
[2917]               * PHLEN are our own overhead, so don't copy all
[2918] B26F C6,00,03 GB2EB  CH   3,@PHLEN
[2919] B272 52,9A           BR   GB316
[2920] B274 BE,C0,00        ST   >10,@PAD(@WRITE)   Issue read byte command
       B277 5A,10
[2921] B279 BC,68,C0        ST   @PAD(@READ),@BYTE3 Read the byte
       B27C 00,58
[2922]               * the following code is somewhat tricky. It will bit

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0051 
RXB 2024
[2923]               * reverse the contents of BYTE3 into BYTE1 through
[2924]               * BYTE2 by means of word shifts. Note the definition of
[2925]               * BYTE1 , BYTE2, and BYTE3 in EQU's. You might try an
[2926]               * example if it isn't clear what is going on.
[2927] B27E 86,67           CLR  @BYTE2
[2928] B280 BE,54,08        ST   >08,@TEMP1
[2929] B283 EB,67,00 RNDAG  DSRC 1,@BYTE2
       B286 01
[2930] B287 E3,66,00        DSLL 1,@BYTE1
       B28A 01
[2931] B28B 92,54           DEC  @TEMP1
[2932] B28D 52,83           BR   RNDAG
[2933]               * Store the bit-corrected byte into the string & inc str pt
[2934] B28F BC,E0,03        ST   @BYTE1,V@3(@SREF)
       B292 1C,66
[2935] B294 91,1C           DINC @SREF
[2936] B296 92,00           DEC  @PHLEN            Dec the string length
[2937] B298 52,6F           BR   GB2EB             Go do next char if there is o
[2938] B29A 0F,7C    GB316  XML  ASSGNV            Assign the string to variable
[2939] B29C D6,42,B3 GB318  CEQ  COMMAZ,@CHAT      If more go do
[2940] B29F 71,F0           BS   NXTPAR
[2941] B2A1 48,82           BR   LNKRTN
[2942]               ***********************************************************
[2943]               * GETPAM gets the next string paameter passed to the
[2944]               * routine. If that parameter is non-exist or null, then
[2945]               * condition bit is set. If the parameter is there then
[2946]               * condition bit is reset and the FAC entry describes the
[2947]               * string. In either case, return with condition is done.
[2948]               ***********************************************************
[2949] B2A3 0F,79    GETPRM XML  PGMCHR            Get next token
[2950] B2A5 D6,42,B3        CEQ  COMMAZ,@CHAT      Go set condition no parm
[2951] B2A8 72,B5           BS   SETCB
[2952] B2AA 0F,74           XML  PARSE
[2953] B2AC B6              BYTE RPARZ
[2954] B2AD D6,4C,65        CEQ  >65,@FAC2         If not string, error
[2955] B2B0 4C,8A           BR   ERRSNM
[2956] B2B2 8F,50           DCZ  @FAC6             Set cond if null string
[2957] B2B4 01              RTNC                   Else return
[2958] B2B5 D4,00,00 SETCB  CEQ  @PAD,@PAD         Set condition bit
[2959] B2B8 01              RTNC
[2960]               ***********************************************************
[2961]               * Get the next phrase out of the current string. The phrase
[2962]               * may begin with a #, which means it will continue to the
[2963]               * next #, or it many begin with an ordinary character, in
[2964]               * which case it will end with the character just before the
[2965]               * first timing character encountered. In either case, the
[2966]               * end of the string will indicate a legal end of phrase if
[2967]               * it occurs before the usual indicator!
[2968]               ***********************************************************
[2969] B2B9 D6,4A,23 PHRASE CEQ  NUMBER,@CCHAR     Phrase start with #?
[2970] B2BC 52,F4           BR   GB370
[2971] B2BE 91,08           DINC @PTCCIS           Yes, inc CC ptr past #
[2972] B2C0 D6,B0,08 GB33C  CEQ  SPACE,V*PTCCIS    Skip spaces
       B2C3 20
[2973] B2C4 52,CA           BR   GB346
[2974] B2C6 91,08           DINC @PTCCIS
[2975] B2C8 52,C0           BR   GB33C
[2976] B2CA D6,B0,08 GB346  CEQ  NUMBER,V*PTCCIS   All spaces?
       B2CD 23
[2977] B2CE 52,D3           BR   GB34F
[2978] B2D0 91,08           DINC @PTCCIS           Yes, skip this # too
[2979] B2D2 00              RTN                    And ignore this phrase
[2980] B2D3 BD,0C,08 GB34F  DST  @PTCCIS,@PTFCIP   Save 1st char in phrase
[2981] B2D6 91,08    GB352  DINC @PTCCIS           Go on to next char

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0052 
RXB 2024
[2982]               * Got to watch for end of string. If encountered before a
[2983]               * #, act like char after string is #. Then last char will
[2984]               * be char before, or the last char in the string!!
[2985] B2D8 C5,08,0A        DCH  @PTLCIS,@PTCCIS
[2986] B2DB 72,E6           BS   FNDNUM
[2987] B2DD BC,4A,B0        ST   V*PTCCIS,@CCHAR   No, get char in CCHAR
       B2E0 08
[2988] B2E1 D6,4A,23        CEQ  NUMBER,@CCHAR     If not # continue looking
[2989] B2E4 52,D6           BR   GB352
[2990] B2E6 BD,10,08 FNDNUM DST  @PTCCIS,@PTLCIP   Last char in phrase is one
[2991] B2E9 93,10           DDEC @PTLCIP            before the #
[2992] B2EB 91,08           DINC @PTCCIS           Point to char after #
[2993] B2ED 06,B3,20        CALL GETTIM            Get 1st timing char after phr
[2994] B2F0 86,4B           CLR  @SPLFLG           Indicate don't spell
[2995] B2F2 53,0F           BR   GB38B             No # as 1st char in phrase
[2996] B2F4 BD,0C,08 GB370  DST  @PTCCIS,@PTFCIP   Curr char is 1st char phrase
[2997] B2F7 86,4B           CLR  @SPLFLG           Assume don't spell
[2998] B2F9 CA,4A,41        CHE  >41,@CCHAR        If not alphabetic   (>41="A")
[2999] B2FC 73,00           BS   GB37C
[3000] B2FE 90,4B           INC  @SPLFLG            set spell flag
[3001]               * Need to find end of phrase, which is char before next
[3002]               * timing char we find. Therefore, look for a timing char!
[3003] B300 91,08    GB37C  DINC @PTCCIS
[3004] B302 06,B3,20        CALL GETTIM
[3005] B305 D6,51,FF        CEQ  >FF,@TIMLEN       If not timing, loop
[3006] B308 73,00           BS   GB37C
[3007] B30A BD,10,08        DST  @PTCCIS,@PTLCIP   Char before curr char is
[3008] B30D 93,10           DDEC @PTLCIP            the last char in phrase
[3009] B30F 00       GB38B  RTN
[3010]               ***********************************************************
[3011]               * TIMING will loop through chars in string until it finds
[3012]               * non-timing char. Non-timing chars have TIMLEN values of
[3013]               * >FE or >FF. GETTIM must be called before this routine to
[3014]               * establish a correct value of TIMLEN. Also, most likely
[3015]               * TOTTIM should have been cleared.
[3016]               ***********************************************************
[3017] B310 CA,51,FE TIMING CHE  >FE,@TIMLEN
[3018] B313 73,1F           BS   GB39B
[3019] B315 A1,4C,51        DADD @TIMLEN,@TOTTIM
[3020] B318 91,08           DINC @PTCCIS
[3021] B31A 06,B3,20        CALL GETTIM
[3022] B31D 53,10           BR   TIMING
[3023] B31F 00       GB39B  RTN
[3024]               ***********************************************************
[3025]               * GETTIM will examine the current char in the string and
[3026]               * set TIMLEN to the appropriate time delay value. TIMLEN
[3027]               * can take on the following values:
[3028]               *           >00 if char is timing '+'
[3029]               *           >06 if char is timing ' '
[3030]               *           >0C if char is timing '-'
[3031]               *           >12 if char is timing ','
[3032]               *           >1E if char is timing ';'
[3033]               *           >30 if char is timing ':'
[3034]               *           >3C if char is timing '.'
[3035]               *           >FE if char is out of stirng bounds
[3036]               *           >FF if char is not timing
[3037]               * Note that to test timing, some manipulation of PTCCIS
[3038]               * would be neccesary, so it is stored and used in TEMP1
[3039]               ***********************************************************
[3040] B320 BC,4A,B0 GETTIM ST   V*PTCCIS,@CCHAR   Get the char
       B323 08
[3041] B324 BD,54,08        DST  @PTCCIS,@TEMP1     store curr ptr in TEMP1
[3042] B327 C5,54,0A        DCH  @PTLCIS,@TEMP1     out of string bounds?
[3043] B32A 53,30           BR   GB3AC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0053 
RXB 2024
[3044] B32C BE,51,FE        ST   >FE,@TIMLEN       Yes, load value and return
[3045] B32F 00              RTN
[3046] B330 C6,4A,3B GB3AC  CH   SEMICO,@CCHAR     Can not be timing
[3047] B333 73,9A           BS   NOTIME
[3048] B335 D6,4A,20        CEQ  SPACE,@CCHAR
[3049] B338 53,49           BR   GB3C5
[3050] B33A BE,51,06        ST   6,@TIMLEN
[3051] B33D D6,E0,01 GB3B9  CEQ  SPACE,V@1(@PTCCIS) While spaces
       B340 08,20
[3052] B342 53,48           BR   GB3C4
[3053] B344 91,08           DINC @PTCCIS           Skip them
[3054] B346 53,3D           BR   GB3B9
[3055] B348 00       GB3C4  RTN
[3056] B349 D6,4A,2B GB3C5  CEQ  PLUS,@CCHAR
[3057] B34C 53,58           BR   GB3D4
[3058] B34E 91,54           DINC @TEMP1            Need to test the next char
[3059] B350 06,B3,9E        CALL NUMERC            Is it numeric
[3060] B353 73,9A           BS   NOTIME            Was numeric => not timing cha
[3061] B355 86,51           CLR  @TIMLEN           Not numeric => set as no timi
[3062] B357 00              RTN
[3063] B358 D6,4A,2C GB3D4  CEQ  COMMAT,@CCHAR
[3064] B35B 53,61           BR   GB3DD
[3065] B35D BE,51,12        ST   >12,@TIMLEN
[3066] B360 00              RTN
[3067] B361 D6,4A,2E GB3DD  CEQ  PERIOD,@CCHAR
[3068] B364 53,78           BR   GB3F4
[3069] B366 93,54           DDEC @TEMP1            Go back to preceding char
[3070] B368 06,B3,9E        CALL NUMERC            Is it numeric?
[3071] B36B 53,74           BR   PTIME             No, so it is timing
[3072] B36D 95,54           DINCT @TEMP1           Yes, on to following char
[3073] B36F 06,B3,9E        CALL NUMERC            Is it numeric too?
[3074] B372 73,9A           BS   NOTIME            Yes, both numeric => not timi
[3075] B374 BE,51,3C PTIME  ST   >3C,@TIMLEN       Both not numeric  => timing
[3076] B377 00              RTN
[3077] B378 D6,4A,2D GB3F4  CEQ  HYPEN,@CCHAR
[3078] B37B 53,88           BR   GB404
[3079] B37D 91,54           DINC @TEMP1            Check next char
[3080] B37F 06,B3,9E        CALL NUMERC            Is it numeric?
[3081] B382 73,9A           BS   NOTIME            Was numeric => not a timing c
[3082] B384 BE,51,0C        ST   >0C,@TIMLEN       Was not numeric => set as tim
[3083] B387 00              RTN
[3084] B388 D6,4A,3A GB404  CEQ  COLON,@CCHAR
[3085] B38B 53,91           BR   GB40D
[3086] B38D BE,51,30        ST   >30,@TIMLEN
[3087] B390 00              RTN
[3088] B391 D6,4A,3B GB40D  CEQ  SEMICO,@CCHAR
[3089] B394 53,9A           BR   NOTIME
[3090] B396 BE,51,1E        ST   >1E,@TIMLEN
[3091] B399 00              RTN
[3092] B39A BE,51,FF NOTIME ST   >FF,@TIMLEN       Set as no timing char present
[3093] B39D 00              RTN
[3094]               ***********************************************************
[3095]               * NUMERC tests the char pointed to by PTCCIS and verifies
[3096]               * the following:
[3097]               *  1 - it is within the current string boundaries
[3098]               *  2 - it is numeric (i.e. between '0' and '9')
[3099]               * If both of the above conditions are true, COND is set
[3100]               * upon return, otherwise COND is reset
[3101]               ***********************************************************
[3102] B39E C5,54,0A NUMERC DCH  @PTLCIS,@TEMP1
[3103] B3A1 73,B4           BS   GB430
[3104] B3A3 C5,06,54        DCH  @TEMP1,@PTFCIS
[3105] B3A6 73,B4           BS   GB430
[3106] B3A8 CA,B0,54        CHE  >30,V*TEMP1

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0054 
RXB 2024
       B3AB 30
[3107] B3AC 53,B4           BR   GB430
[3108] B3AE C6,B0,54        CH   >39,V*TEMP1
       B3B1 39
[3109] B3B2 52,B5           BR   SETCB
[3110] B3B4 01       GB430  RTNC
[3111]               ***********************************************************
[3112]               * LOOKUP is a prolong routine to SEARCH. In each PHROM,
[3113]               * there may be 2 trees, one starting at >0000 and the other
[3114]               * at >8000. Either may or may not be present. Presences is
[3115]               * determined if a >AA byte is at the starting location.
[3116]               * LOOKUP determines if the tree at >0000 is in, and if so,
[3117]               * calls SEARCH with that addr. If that tree is not present
[3118]               * or the phrase couldn't be found in it, LOOKUP then checks
[3119]               * if the tree at >8000 is present, and again, if so, calls
[3120]               * SEARCH with that tree address. If the word was found in
[3121]               * the first tree, or after searching the second tree, the
[3122]               * routine will return.
[3123]               ***********************************************************
[3124] B3B5 87,66    LOOKUP DCLR @BYTE1            BYTE1 contains addr of curr t
[3125] B3B7 BD,12,66 TRYAGN DST  @BYTE1,@PTFBPH    Look for >AA tree header
[3126] B3BA 06,B4,71        CALL LOADAD            LOADAD expects addr in PTFBPH
[3127] B3BD BE,C0,00        ST   >10,@PAD(@WRITE)  Put out read byte command
       B3C0 5A,10
[3128] B3C2 D6,C0,00        CEQ  >AA,@PAD(@READ)   Tree out there?
       B3C5 58,AA
[3129] B3C7 53,D2           BR   GB44E
[3130] B3C9 91,12           DINC @PTFBPH           Skip the tree header
[3131] B3CB 06,B3,DD        CALL SEARCH            Go search this PHROM tree
[3132] B3CE 8F,4D           DCZ  @DATAAD           Phrase found => exit
[3133] B3D0 53,DC           BR   FOUND
[3134] B3D2 A3,66,80 GB44E  DADD >8000,@BYTE1      Go to start of next PHROM tre
       B3D5 00
[3135]               * Note >8000 + >8000 = >0000 => tried both trees
[3136] B3D6 8F,66           DCZ  @BYTE1
[3137] B3D8 53,B7           BR   TRYAGN
[3138] B3DA 87,4D           DCLR @DATAAD           Didnt find phrase in either t
[3139] B3DC 00       FOUND  RTN
[3140]               ***********************************************************
[3141]               * SEARCH actually searches the PHROM tree for the phrase.
[3142]               * The PHROM tree organization is as follows:
[3143]               *        (i.e. this is one phrase node)
[3144]               *              phrase ASCII length      1 byte
[3145]               *              actual ASCII characters  n bytes
[3146]               *              less then pointer        2 bytes
[3147]               *              greater then pointer     2 bytes
[3148]               *              speech data pointer      3 bytes
[3149]               *              speech data length       1 byte
[3150]               * The comparison of two words proceeds on a char by char
[3151]               * basis, where length is secondary to char values, i.e.
[3152]               * move > answer; number < we; eight < eighty; etc...
[3153]               ***********************************************************
[3154] B3DD 06,B4,71 SEARCH CALL LOADAD            Set PHROM to start phrase nod
[3155] B3E0 BE,C0,00        ST   >10,@PAD(@WRITE)  Issue read byte command
       B3E3 5A,10
[3156] B3E5 86,16           CLR  @PTLCPH           Length of phrase => PTLCPH
[3157] B3E7 BC,17,C0        ST   @PAD(@READ),@PTLCPH+1 (stored as 2 byte value
       B3EA 00,58
[3158] B3EC A1,16,12        DADD @PTFBPH,@PTLCPH   Add front ptr giving end ptr
[3159] B3EF BD,14,12        DST  @PTFBPH,@PTCCPH   Set up curr char as 1 beyond
[3160] B3F2 91,14           DINC @PTCCPH            length byte
[3161] B3F4 BD,0E,0C        DST  @PTFCIP,@PTCCIP   Reset current ptr into phrase
[3162]               * Compare two characters
[3163] B3F7 BE,C0,00 NEXT   ST   >10,@PAD(@WRITE)  Issue read byte command

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0055 
RXB 2024
       B3FA 5A,10
[3164] B3FC BC,5D,C0        ST   @PAD(@READ),@PHDATA Get char in from PHROM
       B3FF 00,58
[3165] B401 D4,5D,B0        CEQ  V*PTCCIP,@PHDATA  Compare the char
       B404 0E
[3166] B405 54,55           BR   GB4D1
[3167] B407 91,14           DINC @PTCCPH           Equal, advance both pointers
[3168] B409 91,0E           DINC @PTCCIP
[3169] B40B D6,B0,0E        CEQ  SPACE,V*PTCCIP    Skip extra spaces
       B40E 20
[3170] B40F 54,25           BR   GB4A1
[3171] B411 D6,E0,01 GB48D  CEQ  SPACE,V@1(@PTCCIP) While spaces
       B414 0E,20
[3172] B416 54,1C           BR   GB498
[3173] B418 91,0E           DINC @PTCCIP           Skip them
[3174] B41A 54,11           BR   GB48D
[3175]               * By skipping extra spaces, might have reached end of phras
[3176]               * If this is true, next char in phrase = #. If so, advance
[3177]               * the pointer to be beyond end of phrase.
[3178] B41C D6,E0,01 GB498  CEQ  NUMBER,V@1(@PTCCIP)
       B41F 0E,23
[3179] B421 54,25           BR   GB4A1
[3180] B423 91,0E           DINC @PTCCIP
[3181] B425 C5,14,16 GB4A1  DCH  @PTLCPH,@PTCCPH   End of PHROM word?
[3182] B428 54,4A           BR   GB4C6
[3183] B42A C5,0E,10        DCH  @PTLCIP,@PTCCIP   Yes, end of phrase
[3184] B42D 54,44           BR   GB4C0
[3185] B42F BD,12,16        DST  @PTLCPH,@PTFBPH   Yes, word found
[3186]               * Skip 5 bytes down from last char to data pointer
[3187] B432 A3,12,00        DADD 6,@PTFBPH
       B435 06
[3188] B436 06,B4,A3        CALL READAD            Set data addr => DATAAD
[3189] B439 BE,C0,00        ST   >10,@PAD(@WRITE)  Issue read byte command
       B43C 5A,10
[3190] B43E BC,64,C0        ST   @PAD(@READ),@STRLEN Get length of speech data
       B441 00,58
[3191] B443 00              RTN
[3192] B444 BF,12,00 GB4C0  DST  3,@PTFBPH         Move 3 bytes past PTLCPH
       B447 03
[3193] B448 54,61           BR   NXTPHR
[3194] B44A C5,0E,10 GB4C6  DCH  @PTLCIP,@PTCCIP   2 characters
[3195] B44D 53,F7           BR   NEXT
[3196] B44F BF,12,00        DST  1,@PTFBPH         Phrase linger: use LT ptr
       B452 01
[3197] B453 54,61           BR   NXTPHR
[3198]               * Two characters compared were not equal
[3199] B455 BF,12,00 GB4D1  DST  3,@PTFBPH         3 bytes past last to GT
       B458 03
[3200] B459 C4,5D,B0        CH   V*PTCCIP,@PHDATA  After phrase
       B45C 0E
[3201] B45D 54,61           BR   NXTPHR
[3202] B45F 97,12           DDECT @PTFBPH          Back up 2 bytes to LT link
[3203]               * Go get next phrase out of the PHROM to compare
[3204] B461 A1,12,16 NXTPHR DADD @PTLCPH,@PTFBPH   Add displacement to last char
[3205] B464 06,B4,A3        CALL READAD             and get the new address
[3206] B467 8F,4D           DCZ  @DATAAD           More leaves on this tree
[3207] B469 54,6C           BR   GB4E8
[3208] B46B 00              RTN                    No, return empty handed
[3209] B46C BD,12,4D GB4E8  DST  @DATAAD,@PTFBPH   Store new addr in PTFBPH
[3210] B46F 53,DD           BR   SEARCH            Go compare this new word!
[3211]               * The program should never reach this point!! It should
[3212]               * return somewhere up above.
[3213]               ***********************************************************
[3214]               * LOADAD will set the addr out in the PHROM to the addr

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0056 
RXB 2024
[3215]               * found in PTFBPH. Note that the PHROM is expecting five
[3216]               * nybbles to be written out as the address.
[3217]               ***********************************************************
[3218] B471 BD,54,12 LOADAD DST  @PTFBPH,@TEMP1    This is destructive, so copy
[3219] B474 BD,56,12        DST  @PTFBPH,@TEMP2     address into temporary areas
[3220] B477 E6,54,04        SRL  4,@TEMP1          Isolate the MSN of the MSB
[3221] B47A E6,55,04        SRL  4,@TEMP1+1        Isolate the MSN of the LSB
[3222] B47D B3,56,0F        DAND >0F0F,@TEMP2      Isolate the LSN of the MSB, L
       B480 0F
[3223] B481 B7,54,40        DOR  >4040,@TEMP1      Include a 4 as MSN of all 4 n
       B484 40
[3224] B485 B7,56,40        DOR  >4040,@TEMP2       to indicate a Load Address C
       B488 40
[3225] B489 BC,C0,00        ST   @TEMP2+1,@PAD(@WRITE) Write out the LSN of th
       B48C 5A,57
[3226] B48E BC,C0,00        ST   @TEMP1+1,@PAD(@WRITE) Write out the LSN of th
       B491 5A,55
[3227] B493 BC,C0,00        ST   @TEMP2,@PAD(@WRITE)   Write out the MSN of th
       B496 5A,56
[3228] B498 BC,C0,00        ST   @TEMP1,@PAD(@WRITE)   Write out the MSN of th
       B49B 5A,54
[3229] B49D BE,C0,00        ST   >40,@PAD(@WRITE)      Write out 0 as fifth ny
       B4A0 5A,40
[3230] B4A2 00              RTN
[3231]               ***********************************************************
[3232]               * READAD will read an address from the PHROM and store it
[3233]               * in DATAAD. Note that PTFBPH should contain the addr of
[3234]               * the PHROM location to be read so LOADAD will work.
[3235]               ***********************************************************
[3236] B4A3 06,B4,71 READAD CALL LOADAD            Set the addr of the PHROM
[3237] B4A6 BE,C0,00        ST   >10,@PAD(@WRITE)  Get high byte of addr
       B4A9 5A,10
[3238] B4AB BC,4D,C0        ST   @PAD(@READ),@DATAAD Store it in DATAAD
       B4AE 00,58
[3239] B4B0 BE,C0,00        ST   >10,@PAD(@WRITE)  Get low byte of addr
       B4B3 5A,10
[3240] B4B5 BC,4E,C0        ST   @PAD(@READ),@DATAAD+1 Store it in DATAAD+1
       B4B8 00,58
[3241] B4BA 00              RTN
[3242]               ***********************************************************
[3243]               * STDATA will store the data in DATAAD and TOTTIM onto the
[3244]               * speech list. It will also check that there is room on the
[3245]               * speech list for this entry, and abort with error if not.
[3246]               ***********************************************************
[3247] B4BB D5,02,04 STDATA DCEQ @PTEBSL,@PTLBSL   Is there room?
[3248] B4BE 74,DD           BS   ERRSSL
[3249] B4C0 35,00,03        MOVE 3,@TOTTIM,V*PTLBSL   Put data in list
       B4C3 B0,02,4C
[3250] B4C6 A3,02,00        DADD 3,@PTLBSL              and inc top of list
       B4C9 03
[3251] B4CA 00              RTN
[3252]               ***********************************************************
[3253]               * WAIT loops until the speech peripheral goes idle.
[3254]               ***********************************************************
[3255]               *    ( Loop until nobody is talking)
[3256] B4CB BC,69,C0 WAIT   ST   @PAD(@READ),@SPKSTS  Read status from PHROM
       B4CE 00,58
[3257] B4D0 DA,69,80        CLOG >80,@SPKSTS
[3258] B4D3 54,CB           BR   WAIT
[3259] B4D5 00              RTN
[3260]               ***********************************************************
[3261]               * SETRW moves addrs of speech read/write from GROM to VDP
[3262]               ***********************************************************
[3263] B4D6 31,00,04 SETRW  MOVE 4,G@>0046,@READ

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0057 
RXB 2024
       B4D9 58,00,46
[3264] B4DC 00              RTN
[3265]               ***********************************************************
[3266]               *                    ERROR MESSAGES
[3267]               ***********************************************************
[3268]               *      The following calls are in EXECS file.
[3269]               * ERRSYN CALL ERRZZ           * SYNTAX ERROR
[3270]               *        BYTE 3
[3271]               * ERRSNM CALL ERRZZ           * STRING-NUMBER MISMATCH
[3272]               *        BYTE 7
[3273]               * ERRBV  CALL ERRZZ           * BAD VALUE
[3274]               *        BYTE 30
[3275]               * ERRIAL CALL ERRZZ           * INCORRECT ARGUMENT LIST
[3276]               *        BYTE 31
[3277]               ***********************************************************
[3278] B4DD 06,6A,84 ERRSSL  CALL ERRZZ          * SPEECH STRING TOO LONG
[3279] B4E0 15               BYTE 21
[3280]               ***********************************************************
[3281]               * CALL MOVES("$$",bytes,$variable,$variable,...)          *
[3282]               * CALL MOVES(type$,bytes,from-address,to-address,...)     *
[3283]               * CALL MOVES(type$,bytes,from-address,$variable,...)      *
[3284]               * CALL MOVES(type$,bytes,$variable,to-address,...)        *
[3285]               * type$:R=RAM, V=VDP, G=GRAM/GROM, $=string variable      *
[3286]               ***********************************************************
[3287] B4E1 06,A9,67 MOVES   CALL COMB           MOVES(TYPE$,BYTES,$,TO)
[3288]               *                            or MOVES(TYPE$,BYTES,FROM,$)
[3289] B4E4 06,A2,B4 MOVESA CALL STRGET          * ( or ,
[3290] B4E7 BD,10,B0        DST  V*FAC4,@VAR5    * TYPE "VRG$"
       B4EA 4E
[3291] B4EB 06,A2,CE        CALL GETNUM          * ,BYTES
[3292] B4EE 8F,4A           DCZ  @FAC            0?
[3293] B4F0 6C,BA           BS   ERRBV           BAD VALUE
[3294] B4F2 BD,0C,4A        DST  @FAC,@BYTES     SAVE NUMBER OF BYTES
[3295] B4F5 06,A2,AE        CALL STRFCH          * ,FROM
[3296] B4F8 D6,10,24        CEQ  36,@VAR5        * $? VDP STRING VARIABLE?      
[3297] B4FB 55,09           BR   MOVESX
[3298] B4FD C8,0D,50        CHE  @FAC6,@BYTES+1
[3299] B500 75,0F           BS   MOVESB
[3300] B502 86,0C           CLR  @BYTES
[3301] B504 BC,0D,50        ST   @FAC6,@BYTES+1
[3302] B507 55,0F           BR   MOVESB
[3303] B509 06,A2,C6 MOVESX CALL CFIFCH
[3304] B50C BD,4E,4A        DST  @FAC,@FAC4
[3305] B50F BD,04,4E MOVESB DST  @FAC4,@VARY
[3306] B512 D6,11,24        CEQ  36,@VAR6        * $? VDP STRING VARIABLE?   
[3307] B515 55,27           BR   MOVESN
[3308] B517 CB,0C,01        DCHE 256,@BYTES
       B51A 00
[3309] B51B 6C,BA           BS   ERRBV
[3310] B51D 0F,71           XML  GETSTR
[3311] B51F 06,A2,E6        CALL NGOOD
[3312] B522 BD,4A,1C        DST  @SREF,@FAC
[3313] B525 55,2A           BR   MOVESC
[3314] B527 06,A2,D7 MOVESN CALL SUBLP3          * ,TO
[3315] B52A BD,06,4A MOVESC DST  @FAC,@VARY2
[3316] B52D D6,10,24        CEQ  36,@VAR5        * $? VDP STRING VARIABLE? 
[3317] B530 55,35           BR   MTYPES
[3318] B532 BE,10,56        ST   86,@VAR5        * V? VDP ADDRESS?
[3319] B535 D6,11,24 MTYPES CEQ  36,@VAR6        * $? VDP STRING VARIABLE? 
[3320] B538 55,3D           BR   MTYPE
[3321] B53A BE,11,56        ST   86,@VAR6        * VDP 
[3322] B53D D6,10,56 MTYPE  CEQ  86,@VAR5        * V? VDP FROM
[3323] B540 55,6A           BR   MTYPE3
[3324] B542 D6,11,56        CEQ  86,@VAR6        * V? VDP TO

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0058 
RXB 2024
[3325] B545 55,4F           BR   MTYPE1
[3326] B547 34,0C,E0 MTYPE0 MOVE @BYTES,V@0(@VARY),V@0(@VARY2)
       B54A 00,06,E0
       B54D 00,04
[3327] B54F D6,11,52 MTYPE1 CEQ  82,@VAR6        * R? RAM TO
[3328] B552 55,5D           BR   MTYPE2
[3329] B554 34,0C,CF        MOVE @BYTES,V@0(@VARY),@0(@VARY2)
       B557 7D,00,06
       B55A E0,00,04
[3330] B55D D6,11,47 MTYPE2 CEQ  71,@VAR6        * G? GRAM TO
[3331] B560 55,6A           BR   MTYPE3
[3332] B562 2C,0C,00        MOVE @BYTES,V@0(@VARY),G@0(@VARY2)
       B565 00,06,E0
       B568 00,04
[3333] B56A D6,10,52 MTYPE3 CEQ  82,@VAR5        * R? RAM FROM
[3334] B56D 55,9A           BR   MTYPE7
[3335] B56F D6,11,56        CEQ  86,@VAR6        * V? VDP TO
[3336] B572 55,7D           BR   MTYPE5
[3337] B574 34,0C,E0 MTYPE4 MOVE @BYTES,@0(@VARY),V@0(@VARY2)
       B577 00,06,CF
       B57A 7D,00,04
[3338] B57D D6,11,52 MTYPE5 CEQ  82,@VAR6        * R? RAM TO
[3339] B580 55,8C           BR   MTYPE6
[3340] B582 34,0C,CF        MOVE @BYTES,@0(@VARY),@0(@VARY2)
       B585 7D,00,06
       B588 CF,7D,00
       B58B 04
[3341] B58C D6,11,47 MTYPE6 CEQ  71,@VAR6        * G? GRAM TO
[3342] B58F 55,9A           BR   MTYPE7
[3343] B591 2C,0C,00        MOVE @BYTES,@0(@VARY),G@0(@VARY2)
       B594 00,06,CF
       B597 7D,00,04
[3344] B59A D6,10,47 MTYPE7 CEQ  71,@VAR5        * G? GRAM FROM
[3345] B59D 55,C7           BR   MOVESD
[3346] B59F D6,11,56        CEQ  86,@VAR6        * V? VDP TO
[3347] B5A2 55,AC           BR   MTYPE9
[3348] B5A4 32,0C,E0 MTYPE8 MOVE @BYTES,G@0(@VARY),V@0(@VARY2)
       B5A7 00,06,00
       B5AA 00,04
[3349] B5AC D6,11,52 MTYPE9 CEQ  82,@VAR6        * R? RAM TO
[3350] B5AF 55,BA           BR   MTYPEA
[3351] B5B1 32,0C,CF        MOVE @BYTES,G@0(@VARY),@0(@VARY2)
       B5B4 7D,00,06
       B5B7 00,00,04
[3352] B5BA D6,11,47 MTYPEA CEQ  71,@VAR6        * G? GRAM TO
[3353] B5BD 55,C7           BR   MOVESD
[3354] B5BF 2A,0C,00        MOVE @BYTES,G@0(@VARY),G@0(@VARY2)
       B5C2 00,06,00
       B5C5 00,04
[3355] B5C7 D6,42,B3 MOVESD CEQ  >B3,@CHAT       * COMMA?  
[3356] B5CA 74,E4           BS   MOVESA
[3357] B5CC 48,82           BR   LNKRTN
[3358]               **********************************************************
[3359]               * CALL HEX($variable,variable,...)                       *
[3360]               * CALL HEX(variable,$variable,...)                       *
[3361]               **********************************************************
[3362] B5CE 06,A9,67 HEX    CALL COMB             * HEX(variable,variable)
[3363] B5D1 06,A2,AE HEXAGN CALL STRFCH            Get STRING or NUMBER
[3364] B5D4 D6,4C,65        CEQ  >65,@FAC2         STRING?
[3365] B5D7 76,2E           BS   HEX00             Yes
[3366]               ****************************** Number to HEX String
[3367] B5D9 06,A2,C6        CALL CFIFCH            Turn from DEC to HEX
[3368] B5DC BD,56,4A        DST  @FAC,@TEMP2       Save it
[3369] B5DF BF,0C,00        DST  >0004,@BYTES      Number of byte for string

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0059 
RXB 2024
       B5E2 04
[3370] B5E3 0F,71           XML  GETSTR            Get String 
[3371] B5E5 BD,12,1C        DST  @SREF,@STRPTR     Save string location 
[3372] B5E8 BC,00,56        ST   @TEMP2,@PAD       Get one byte in PAD
[3373] B5EB E6,00,04        SRL  4,@PAD            Strip off low bits
[3374] B5EE 06,B6,1C        CALL HEXNS             Convert to ASCII
[3375] B5F1 BC,00,56        ST   @TEMP2,@PAD       Get one byte in PAD
[3376] B5F4 E2,00,04        SLL  4,@PAD            Strip off high bits
[3377] B5F7 E6,00,04        SRL  4,@PAD            Put back now high bits gone
[3378] B5FA 06,B6,1C        CALL HEXNS             Convert to ASCII
[3379] B5FD BC,00,57        ST   @TEMP2+1,@PAD     Get one byte in PAD 
[3380] B600 E6,00,04        SRL  4,@PAD            Strip off low bits
[3381] B603 06,B6,1C        CALL HEXNS             Convert to ASCII
[3382] B606 BC,00,57        ST   @TEMP2+1,@PAD     Get one byte in PAD 
[3383] B609 E2,00,04        SLL  4,@PAD            Strip off high bits
[3384] B60C E6,00,04        SRL  4,@PAD            Put back now high bits gone
[3385] B60F 06,B6,1C        CALL HEXNS             Convert to ASCII
[3386] B612 D6,42,B3        CEQ  COMMAZ,@CHAT      , COMMA?
[3387] B615 4C,86           BR   ERRSYN            ERROR SYNTAX
[3388] B617 06,A2,E6        CALL NGOOD             Assign to Variable
[3389] B61A 56,48           BR   HEXDON            Go check for COMMA
[3390] B61C CA,00,0A HEXNS  CHE  >0A,@PAD          10 or higher?
[3391] B61F 56,24           BR   HEXNS2            No
[3392] B621 A2,00,07        ADD  >07,@PAD          Add 7
[3393] B624 A2,00,30 HEXNS2 ADD  >30,@PAD          Add 48
[3394] B627 BC,B0,12        ST   @PAD,V*STRPTR     Save new byte
       B62A 00
[3395] B62B 91,12           DINC @STRPTR           Next Character
[3396] B62D 00              RTN
[3397]               ***************************** HEX String to NUMBER
[3398] B62E 06,B6,4F HEX00  CALL HEXSTR            ASC to HEX
[3399] B631 0F,79           XML  PGMCHR            Next value?
[3400] B633 06,A3,01        CALL SNDER             Send value
[3401] B636 06,A3,0D        CALL CLRFAC            Clear FAC
[3402] B639 86,8F,DD        CLR  @>6004            Set ROM 3 page
       B63C 04
[3403] B63D 0F,76           XML  ASCHEX            Convert ASC to HEX
[3404] B63F D7,5C,99        DCEQ >994A,@ARG        ERROR FLAG?
       B642 4A
[3405] B643 6C,B6           BS   ERRBA             ERROR BAD ARGUMENT
[3406] B645 06,A3,08        CALL CIFSND            Convert Integer to FP send
[3407] B648 D6,42,B3 HEXDON CEQ  COMMAZ,@CHAT      , COMMA?  
[3408] B64B 75,D1           BS   HEXAGN            Next set to run
[3409] B64D 48,82           BR   LNKRTN            Return to XB
[3410]               ******************************
[3411] B64F 8F,50    HEXSTR DCZ  @FAC6         Zero length string?
[3412] B651 6C,B6           BS   ERRBA         ERROR BAD ARGUMENT
[3413] B653 D6,B0,4E        CEQ  62,V*FAC4     > ?
       B656 3E
[3414] B657 56,61           BR   HEX01         No
[3415] B659 91,4E           DINC @FAC4         Add 1 to ignore >
[3416] B65B 92,51           DEC  @FAC7         Length -1 ignore >
[3417] B65D 8E,51           CZ   @FAC7
[3418] B65F 6C,B6           BS   ERRBA         ERROR BAD ARGUMENT
[3419] B661 BF,00,30 HEX01  DST  >3030,@PAD    ZERO BUFFER
       B664 30
[3420] B665 BF,02,30        DST  >3030,@PAD2   ZERO BUFFER
       B668 30
[3421] B669 D6,51,01        CEQ 1,@FAC7        1 to move
[3422] B66C 56,77           BR   HEX02         No
[3423] B66E 35,00,01        MOVE 1,V@0(@FAC4),@PAD3 Get 1 chr
       B671 03,E0,00
       B674 4E
[3424] B675 56,9A           BR   HEX05         Check valid

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0060 
RXB 2024
[3425] B677 D6,51,02 HEX02  CEQ  2,@FAC7       2 to move 
[3426] B67A 56,85           BR   HEX03         No
[3427] B67C 35,00,02        MOVE 2,V@0(@FAC4),@PAD2 Get 2 chr
       B67F 02,E0,00
       B682 4E
[3428] B683 56,9A           BR   HEX05         Check valid
[3429] B685 D6,51,03 HEX03  CEQ  3,@FAC7       3 to move
[3430] B688 56,93           BR   HEX04         No
[3431] B68A 35,00,03        MOVE 3,V@0(@FAC4),@PAD1 Get 3 chr
       B68D 01,E0,00
       B690 4E
[3432] B691 56,9A           BR   HEX05         Check valid
[3433] B693 35,00,04 HEX04  MOVE 4,V@0(@FAC4),@PAD Get 4 chr
       B696 00,E0,00
       B699 4E
[3434] B69A 00       HEX05  RTN                Return to caller
[3435]               *********************************************************
[3436]               * CALL IO(type,address,...)                             *
[3437]               * CALL IO(type,bits,cru-base,variable,variable,...)     *
[3438]               * CALL IO(type,length,VDP-address,...)                  *
[3439]               *********************************************************
[3440] B69B 06,A9,67 RXBIO  CALL COMB         * IO
[3441] B69E 06,A2,CE IOAGN  CALL GETNUM       * TYPE 0-6
[3442] B6A1 CA,4B,07        CHE  >07,@FAC1
[3443] B6A4 6C,BA           BS   ERRBV
[3444] B6A6 BC,04,4B        ST   @FAC1,@VARY
[3445] B6A9 06,A2,D7        CALL SUBLP3       * ADDRESS/
[3446] B6AC 8A,04           CASE @VARY        * BITS/BYTES
[3447] B6AE 56,BC           BR   SOG
[3448] B6B0 56,C1           BR   SOV
[3449] B6B2 56,C6           BR   CRUI
[3450] B6B4 56,F1           BR   CRUO
[3451] B6B6 57,1B           BR   CSW
[3452] B6B8 57,23           BR   CSR
[3453] B6BA 57,2B           BR   CSV
[3454] B6BC F6,4A,00 SOG    I/O  0,@FAC
[3455] B6BF 57,31           BR   IODONE
[3456] B6C1 F6,4A,01 SOV    I/O  1,@FAC
[3457] B6C4 57,31           BR   IODONE
[3458] B6C6 06,B7,40 CRUI   CALL CRUSET
[3459] B6C9 F6,0E,02        I/O  2,@VAR4
[3460] B6CC 0F,79           XML  PGMCHR
[3461] B6CE 06,A3,01        CALL SNDER
[3462] B6D1 06,A3,0D        CALL CLRFAC
[3463] B6D4 BC,4B,00        ST   @PAD,@FAC1
[3464] B6D7 06,A3,08        CALL CIFSND       * VARIABLE1
[3465] B6DA CA,04,09        CHE  >09,@VARY
[3466] B6DD 76,E1           BS   CRUI16
[3467] B6DF 57,31           BR   IODONE
[3468] B6E1 0F,79    CRUI16 XML  PGMCHR
[3469] B6E3 06,A3,01        CALL SNDER
[3470] B6E6 06,A3,0D        CALL CLRFAC
[3471] B6E9 BC,4B,01        ST   @PAD1,@FAC1
[3472] B6EC 06,A3,08        CALL CIFSND       * VARIABLE2
[3473] B6EF 57,31           BR   IODONE
[3474] B6F1 06,B7,40 CRUO   CALL CRUSET
[3475] B6F4 06,A2,D7        CALL SUBLP3       * VARIABLE1
[3476] B6F7 CB,4A,01        DCHE >0100,@FAC
       B6FA 00
[3477] B6FB 6C,BA           BS   ERRBV
[3478] B6FD CA,04,09        CHE  >09,@VARY
[3479] B700 77,07           BS   CRUO16
[3480] B702 BC,00,4B        ST   @FAC1,@PAD
[3481] B705 57,16           BR   CRUO8

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0061 
RXB 2024
[3482] B707 BD,00,4A CRUO16 DST  @FAC,@PAD
[3483] B70A 06,A2,D7        CALL SUBLP3       * VARIABLE2
[3484] B70D CB,4A,01        DCHE >0100,@FAC
       B710 00
[3485] B711 6C,BA           BS   ERRBV
[3486] B713 BC,01,4B        ST   @FAC1,@PAD1
[3487] B716 F6,0E,03 CRUO8  I/O  3,@VAR4
[3488] B719 57,31           BR   IODONE
[3489] B71B 06,B7,56 CSW    CALL CSLOAD
[3490] B71E F6,0E,04        I/O  4,@VAR4
[3491] B721 57,31           BR   IODONE
[3492] B723 06,B7,56 CSR    CALL CSLOAD
[3493] B726 F6,0E,05        I/O  5,@VAR4
[3494] B729 57,31           BR   IODONE
[3495] B72B 06,B7,56 CSV    CALL CSLOAD
[3496] B72E F6,0E,06        I/O  6,@VAR4
[3497] B731 D6,42,B3 IODONE CEQ  >B3,@CHAT
[3498] B734 76,9E           BS   IOAGN
[3499] B736 48,82           BR   LNKRTN
[3500] B738 BD,0E,4A CRUTMP DST  @FAC,@VAR4
[3501] B73B 87,10           DCLR @VAR5
[3502] B73D 87,00           DCLR @PAD
[3503] B73F 00              RTN
[3504] B740 8E,4B    CRUSET CZ   @FAC1
[3505] B742 6C,BA           BS   ERRBV
[3506] B744 CA,4A,11        CHE  >11,@FAC
[3507] B747 6C,BA           BS   ERRBV
[3508] B749 BC,04,4B        ST   @FAC1,@VARY
[3509] B74C 06,A2,D7        CALL SUBLP3       * CRU-ADDRESS
[3510] B74F 06,B7,38        CALL CRUTMP
[3511] B752 BC,10,04        ST   @VARY,@VAR5
[3512] B755 00              RTN
[3513] B756 06,B7,38 CSLOAD CALL CRUTMP
[3514] B759 06,A2,D7        CALL SUBLP3       * ADDRESS
[3515] B75C BD,10,4A        DST  @FAC,@VAR5
[3516] B75F 00              RTN
[3517]               *********************************************************
[3518]               * CALL HPUT(row,column,$variable,...)                    *
[3519]               * CALL HPUT(row,column,number-variable,...)              *
[3520]               **********************************************************
[3521] B760 06,B7,80 HPUTZ  CALL PUTZ    
[3522] B763 86,8F,DD HPUTS  CLR  @>6004        Set ROM 3 page
       B766 04
[3523] B767 0F,77           XML  HPUT
[3524] B769 D6,42,B3 HPOUT  CEQ  COMMAZ,@CHAT
[3525] B76C 77,60           BS   HPUTZ
[3526] B76E 48,82           BR   LNKRTN
[3527]               **********************************************************
[3528]               * CALL VPUT(row,column,$variable,...)                    *
[3529]               * CALL VPUT(row,column,number-variable,...)              *
[3530]               **********************************************************
[3531] B770 06,B7,80 VPUTZ  CALL PUTZ              Get ( and ROW         No, CNS
[3532] B773 86,8F,DD VPUTS  CLR  @>6004        Set ROM 3 page
       B776 04
[3533] B777 0F,78           XML  VPUT
[3534] B779 D6,42,B3 VPOUT  CEQ  COMMAZ,@CHAT
[3535] B77C 77,70           BS   VPUTZ
[3536] B77E 48,82           BR   LNKRTN
[3537]               *******************************
[3538] B780 06,AA,D9 PUTZ   CALL RGPHV
[3539] B783 06,A2,B0        CALL STRPAR
[3540] B786 D6,4C,65        CEQ  >65,@FAC2
[3541] B789 77,AC           BS   PUTZ1
[3542] B78B 86,55           CLR  @FAC11            Select XB FLP

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0062 
RXB 2024
[3543] B78D 0F,73           XML  XBCNS             Convert Number to String
[3544] B78F D6,90,55        CEQ  SPACE,*FAC11      Leading space?
       B792 20
[3545] B793 57,99           BR   HVPUTN
[3546] B795 90,55           INC  @FAC11            Supress space out
[3547] B797 92,56           DEC  @FAC12            Shorten length
[3548] B799 86,0C    HVPUTN CLR  @BYTES
[3549] B79B BC,0D,56        ST   @FAC12,@BYTES+1        Length
[3550] B79E 0F,71           XML  GETSTR                 Get string
[3551] B7A0 34,0C,B0        MOVE @BYTES,*FAC11,V*SREF   Store in VDP rollout
       B7A3 1C,90,55
[3552] B7A6 BD,4E,1C        DST  @SREF,@FAC4            VDP rollout address
[3553] B7A9 BD,50,0C        DST  @BYTES,@FAC6           Store length
[3554] B7AC 00       PUTZ1  RTN
[3555]               **********************************************************
[3556]               * CALL HGET(row,column,length,$variable,...)             *
[3557]               **********************************************************
[3558] B7AD 06,A9,67 HGETZ  CALL COMB              (?
[3559] B7B0 06,B7,D3 HGETS  CALL HVGETS            Get Row:Column,Length,String
[3560] B7B3 86,8F,DD        CLR  @>6004            Set ROM 3 page 
       B7B6 04
[3561] B7B7 0F,7A           XML  HGET              Assembly
[3562] B7B9 D6,42,B3        CEQ  >B3,@CHAT         ,? 
[3563] B7BC 77,B0           BS   HGETS             Yes        
[3564] B7BE 48,82           BR   LNKRTN            Return to XB
[3565]               **********************************************************
[3566]               * CALL VGET(row,column,length,$variable,...)             *
[3567]               **********************************************************
[3568] B7C0 06,A9,67 VGETZ  CALL COMB              (? 
[3569] B7C3 06,B7,D3 VAGAIN CALL HVGETS            Get Row & Column & Length
[3570] B7C6 86,8F,DD        CLR  @>6004            Set ROM 3 page
       B7C9 04
[3571] B7CA 0F,7B           XML  VGET              Assembly
[3572] B7CC D6,42,B3        CEQ  >B3,@CHAT         ,? 
[3573] B7CF 77,C3           BS   VAGAIN            Yes
[3574] B7D1 48,82           BR   LNKRTN            Return to XB
[3575]               ******************************
[3576] B7D3 06,AA,A2 HVGETS CALL HVRC         Get Row & Column (PAD2)
[3577] B7D6 06,A2,D7        CALL SUBLP3       Skip comma get Length 
[3578] B7D9 8F,4A           DCZ  @FAC         0?
[3579] B7DB 6C,BA           BS   ERRBV        ERROR BAD VALUE
[3580] B7DD CF,4A,00        DCGT >00FF,@FAC   Larger then 255?
       B7E0 FF
[3581] B7E1 6C,BA           BS   ERRBV        ERROR BAD VALUE
[3582] B7E3 BD,0C,4A        DST  @FAC,@BYTES
[3583] B7E6 0F,71           XML  GETSTR       Get string location
[3584] B7E8 BD,06,0C        DST  @BYTES,@PAD6 Set string Length (PAD6)
[3585] B7EB BD,04,1C        DST  @SREF,@PAD4  Save String location (PAD4)
[3586] B7EE 06,A2,E6        CALL NGOOD        Skip comma & assign string
[3587] B7F1 00              RTN
[3588]               **********************************************************
[3589]               * CALL GMOTION(#sprite,row-varable,col-variable,...)     *
[3590]               **********************************************************
[3591] B7F2 06,A9,67 GMOT   CALL COMB              * 
[3592] B7F5 06,AF,D6 GMAGN  CALL SPNUM2
[3593] B7F8 BE,54,02        ST   >02,@TEMP1
[3594] B7FB BD,56,E4        DST  V@>0480(@PAD8),@TEMP2
       B7FE 80,08
[3595] B800 06,B0,7D GMO1   CALL PREPN
[3596] B803 BC,4B,56        ST   @TEMP2,@FAC+1
[3597] B806 C6,4B,7F        CH   >7F,@FAC+1
[3598] B809 58,0F           BR   GMO2
[3599] B80B 82,4B           NEG  @FAC+1
[3600] B80D 83,4A           DNEG @FAC

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0063 
RXB 2024
[3601] B80F 06,A3,08 GMO2   CALL CIFSND
[3602] B812 D6,54,01        CEQ  >01,@TEMP1
[3603] B815 78,1B           BS   GMO3
[3604] B817 0F,7E           XML  SPEED
[3605] B819 00,B3           DATA >00B3
[3606] B81B C0,57,56 GMO3   EX   @TEMP2,@TEMP2+1
[3607] B81E 92,54           DEC  @TEMP1
[3608] B820 58,00           BR   GMO1
[3609] B822 D6,42,B3        CEQ  >B3,@CHAT
[3610] B825 77,F5           BS   GMAGN
[3611] B827 48,82           BR   LNKRTN
[3612]               **********************************************************
[3613]               * CALL RMOTION(#sprite,ALL)                              *
[3614]               * CALL RMOTION(#sprite,#sprite,...)                      *
[3615]               **********************************************************
[3616] B829 06,A9,67 RMOT   CALL COMB               *  
[3617] B82C 0F,79    RMAGN  XML  PGMCHR
[3618] B82E D6,42,EC        CEQ  >EC,@CHAT
[3619] B831 58,43           BR   NOALL
[3620] B833 0F,7E           XML  SPEED
[3621] B835 00,EC           DATA >00EC
[3622] B837 BF,00,00        DST  >001C,@PAD
       B83A 1C
[3623] B83B BD,4A,00 NXALL  DST  @PAD,@FAC
[3624] B83E 06,AF,E8        CALL SPNUM5
[3625] B841 58,52           BR   RMALL
[3626] B843 BF,00,00 NOALL  DST  >0001,@PAD
       B846 01
[3627] B847 D6,42,FD        CEQ  NUMBEZ,@CHAT
[3628] B84A 4C,86           BR   ERRSYN
[3629] B84C 06,A2,BD        CALL NUMFCH
[3630] B84F 06,AF,E2        CALL SPNUM4
[3631] B852 BD,54,E4 RMALL  DST  V@>0480(@PAD8),@TEMP1
       B855 80,08
[3632] B857 BE,56,02        ST   >02,@TEMP2
[3633] B85A 8E,54    RMOTLP CZ   @TEMP1
[3634] B85C 78,6E           BS   J2
[3635] B85E D6,54,80        CEQ  >80,@TEMP1
[3636] B861 78,7A           BS   J3
[3637] B863 C6,54,7F        CH   >7F,@TEMP1
[3638] B866 78,6C           BS   J1
[3639] B868 82,54           NEG  @TEMP1
[3640] B86A 58,6E           BR   J2
[3641] B86C 80,54    J1     ABS  @TEMP1
[3642] B86E C0,55,54 J2     EX   @TEMP1,@TEMP1+1
[3643] B871 92,56           DEC  @TEMP2
[3644] B873 58,5A           BR   RMOTLP
[3645] B875 BD,E4,80        DST  @TEMP1,V@>0480(@PAD8)
       B878 08,54
[3646] B87A 93,00    J3     DDEC @PAD
[3647] B87C 58,3B           BR   NXALL
[3648] B87E D6,42,B3        CEQ  >B3,@CHAT
[3649] B881 78,2C           BS   RMAGN
[3650] B883 48,82           BR   LNKRTN
[3651]               ***********************************************************
[3652]               * CALL COINC(#sprite,#sprite,tolerance,variable,...)       
[3653]               * CALL COINC(#sprite,dotrow,dotcol,tolerance,variable,...) 
[3654]               ***********************************************************
[3655] B885 06,AE,A6 ZSCOI  CALL SPRCOI       *    
[3656] B888 D6,42,B3 COINLP CEQ  >B3,@CHAT    *
[3657] B88B 48,82           BR   LNKRTN       *
[3658] B88D 0F,79           XML  PGMCHR       *
[3659] B88F 06,AE,BC        CALL GAF56        *
[3660] B892 58,88           BR   COINLP       *

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0064 
RXB 2024
[3661]               ***********************************************************
[3662]               * CALL DISTANCE(#sprite,#sprite,variable,...)              
[3663]               * CALL DISTANCE(#sprite,dot-row,dot-col,variable,...)      
[3664]               ***********************************************************
[3665] B894 06,AF,2C ZDIST CALL DIST          *    
[3666] B897 D6,42,B3 DISLP  CEQ  >B3,@CHAT    *
[3667] B89A 48,82           BR   LNKRTN       *
[3668] B89C 06,AF,2F        CALL GAFC4        *
[3669] B89F 58,97           BR   DISLP        *
[3670]              
[3671]               ***********************************************************
[3672]               * CALL KEY(string,keyunit,Nvarible,Nvariable...)          *
[3673]               * CALL KEY(keyunit,Nvariable,Nvarible...)                 *
[3674]               ***********************************************************
[3675] B8A1 06,AB,4E ZKEY   CALL KEY               Get key
[3676] B8A4 D6,42,B3        CEQ  COMMAZ,@CHAT
[3677] B8A7 78,A1           BS   ZKEY
[3678] B8A9 48,82           BR   LNKRTN
[3679]               ***********************************************************
[3680] B8AB BC,00,4B KEYJOY ST   @FAC1,@PAD        Keyboard selection
[3681] B8AE 06,A9,4E        CALL NUMVAR            Get variable for key-code
[3682] B8B1 D6,42,B3        CEQ  COMMAZ,@CHAT      If not comma - error
[3683] B8B4 4C,86           BR   ERRSYN            SYNTAX error
[3684] B8B6 0F,79           XML  PGMCHR            Get next character
[3685] B8B8 06,A9,4E        CALL NUMVAR            Get variable for key-status
[3686] B8BB BC,74,00        ST   @PAD,@KEYBD       Keyboard selection
[3687] B8BE 31,00,08        MOVE 8,G@FLT1,@FAC     Set up float
       B8C1 4A,A3,32
[3688] B8C4 06,B8,CB        CALL KEYSTR            * RXB KEY STRING COMPARISON *
[3689] B8C7 BC,04,7C        ST   @STATUS,@VARY     Save stutus
[3690] B8CA 01              RTNC                   Return scan condition co
[3691]               ***********************************************************
[3692] B8CB D7,10,99 KEYSTR DCEQ >994A,@TOPSTK     Flag set?
       B8CE 4A
[3693] B8CF 58,FF           BR   RSCAN3            No.
[3694] B8D1 BD,08,04        DST  @VARY,@PAD8       String address.
[3695] B8D4 BD,02,06        DST  @CCPPTR,@ACCUM    Copy length.
[3696] B8D7 86,68           CLR  @BYTE3            Zero out counter
[3697] B8D9 D6,66,9B RSCAN  CEQ  ONZ,@BYTE1        ON flag?
[3698] B8DC 58,E2           BR   RSCAN0            No
[3699] B8DE 03              SCAN                   Get a key
[3700] B8DF 05,B8,E5        B    RSCAN1            Jump past normal KEY
[3701] B8E2 03       RSCAN0 SCAN                   Any key?
[3702] B8E3 58,E2           BR   RSCAN0            No.
[3703] B8E5 8F,06    RSCAN1 DCZ  @CCPPTR           Length 0?
[3704] B8E7 79,00           BS   RSCAN4            Yes.
[3705] B8E9 90,68    RSCAN2 INC  @BYTE3            Counter +1
[3706] B8EB D4,75,B0        CEQ  V*PAD8,@RKEY      Same?
       B8EE 08
[3707] B8EF 79,05           BS   RSCAN5            Yes.
[3708] B8F1 91,08           DINC @PAD8             Address +1
[3709] B8F3 93,02           DDEC @ACCUM            Length -1
[3710] B8F5 58,E9           BR   RSCAN2            No matcth.
[3711] B8F7 D6,66,9B        CEQ  ONZ,@BYTE1        ON flag?
[3712] B8FA 79,00           BS   RSCAN4            Yes
[3713] B8FC 05,B8,CB        B    KEYSTR            Restart.
[3714] B8FF 03       RSCAN3 SCAN                   Normal key scan.
[3715] B900 86,74    RSCAN4 CLR  @KEYBD            Clear key unit
[3716] B902 87,10           DCLR @TOPSTK           Clear flag.
[3717] B904 01              RTNC                   Return save condition
[3718] B905 06,B9,00 RSCAN5 CALL RSCAN4
[3719] B908 D4,00,00        CEQ  @PAD,@PAD         Force condition bit on
[3720] B90B 01              RTNC                   Return save condition
[3721]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0065 
RXB 2024
[3722]               * CALL ONKEY(string,keyunit,variable,variable)            *
[3723]               * GOTO line#,line#,line#...                               *
[3724]               ***********************************************************
[3725] B90C BE,66,9B ZONKEY ST   ONZ,@BYTE1
[3726] B90F 8E,44           CZ   @PRGFLG           Program mode?
[3727] B911 6C,B2           BS   ERRLNF            ERROR LINE NOT FOUND
[3728] B913 06,AB,4E        CALL KEY               Get normal key,status
[3729] B916 8E,04           CZ   @VARY             Was a key pressed?
[3730] B918 59,1C           BR   GOTON0            No ONZ flag stays set
[3731] B91A 86,66           CLR  @BYTE1            Clear ONZ flag
[3732] B91C D6,42,B6 GOTON0 CEQ  RPARZ,@CHAT       )
[3733] B91F 4C,86           BR   ERRSYN            SYNTAX ERROR
[3734] B921 0F,79           XML  PGMCHR            Skip )
[3735] B923 D6,42,86        CEQ  GOTOZ,@CHAT       GOTO flag?
[3736] B926 4C,86           BR   ERRSYN            SYNTAX ERROR
[3737] B928 86,67           CLR  @BYTE2            Zero out Counter
[3738] B92A 90,67    ONLP   INC  @BYTE2            Counter +1
[3739] B92C 0F,79           XML  PGMCHR            Skip GO
[3740] B92E D6,42,C9        CEQ  LNZ,@CHAT         Line# token?
[3741] B931 4C,86           BR   ERRSYN            SYNTAX ERROR
[3742] B933 0F,79           XML  PGMCHR            Skip line# token
[3743] B935 BC,4A,42        ST   @CHAT,@FAC        Store high byte line#
[3744] B938 0F,79           XML  PGMCHR            Skip high byte line#
[3745] B93A BC,4B,42        ST   @CHAT,@FAC1       Store low byte line#
[3746] B93D 0F,79           XML  PGMCHR            Skip low byte line#
[3747] B93F D4,67,68        CEQ  @BYTE3,@BYTE2     $ counter = line# counter
[3748] B942 59,47           BR   ONKEY1            No
[3749] B944 BD,04,4A        DST  @FAC,@VARY        Save line#
[3750] B947 D6,42,B3 ONKEY1 CEQ  COMMAZ,@CHAT      ,?
[3751] B94A 79,2A           BS   ONLP              Yes, keep going
[3752] B94C BD,4A,04        DST  @VARY,@FAC        Get saved line#
[3753] B94F D6,66,9B        CEQ  ONZ,@BYTE1        ONZ flag?
[3754] B952 79,57           BS   GKEY1             Yes, load line#
[3755] B954 06,00,12        CALL RETURN            Return to XB
[3756]               **********************************************************
[3757] B957 BD,4C,32 GKEY1  DST  @ENLN,@FAC2        Get last address
[3758] B95A A7,4C,00        DSUB 3,@FAC2            Point to first LINE#
       B95D 03
[3759] B95E 06,80,2E GKEY2  CALL GRSUB3             Read from VDP/RAM
[3760] B961 4C              BYTE FAC2
[3761] B962 D5,4A,58        DCEQ @EEE1,@FAC         Same?
[3762] B965 79,72           BS   GKEY3              Yes, found line#
[3763] B967 C5,4C,30        DCH  @STLN,@FAC2        No line# left
[3764] B96A 4C,B2           BR   ERRLNF             ERROR LINE NOT FOUND
[3765] B96C A7,4C,00        DSUB 4,@FAC2            Next LINE#
       B96F 04
[3766] B970 59,5E           BR   GKEY2              Loop
[3767] B972 BD,2E,4C GKEY3  DST  @FAC2,@EXTRAM      Got LINE#
[3768] B975 A3,2E,00        DADD 4,@EXTRAM          Point to begining of line
       B978 04
[3769] B979 95,2E           DINCT @EXTRAM           Point to ADDRESS
[3770] B97B BD,2C,2E        DST  @EXTRAM,@PGMPTR    Set pointer to line to run
[3771] B97E 95,2C           DINCT @PGMPTR           Point to tokens
[3772] B980 06,00,12        CALL RETURN             Return to XB
[3773]               **********************************************************
[3774]               * CALL JOYST(key-unit,x-return,y-return,...)             *
[3775]               **********************************************************
[3776] B983 06,BA,21 GJOYST CALL SPAR              KEY UNIT
[3777] B986 0F,7E    JOYRPT XML  SPEED             Insure in range
[3778] B988 02              BYTE RANGE          *   of 1 - 4
[3779] B989 01              BYTE 1
[3780] B98A 00,04           DATA 4
[3781]               *                             GET VARIABLES FOR X, Y
[3782]               *                              AND SCAN KEYBOARD

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0066 
RXB 2024
[3783] B98C BC,00,4B        ST   @FAC1,@PAD        Keyboard selection
[3784] B98F 06,A9,4E        CALL NUMVAR            Get variable for key-code
[3785] B992 D6,42,B3        CEQ  COMMAZ,@CHAT      If not comma - error
[3786] B995 4C,86           BR   ERRSYN
[3787] B997 0F,79           XML  PGMCHR            Get next character
[3788] B999 06,A9,4E        CALL NUMVAR            Get variable for key-status
[3789] B99C BC,74,00        ST   @PAD,@KEYBD       Keyboard selection
[3790] B99F 31,00,08        MOVE 8,G@FLT1,@FAC     Set up float
       B9A2 4A,A3,32
[3791] B9A5 03              SCAN                   SCAN the keyboard
[3792]               * RXB PATCH CODE SAVE KEY & JOYST
[3793] B9A6 BC,17,75 JOYSTS ST   @RKEY,@FNUM       SAVE KEY VALUE 
[3794] B9A9 BD,14,76        DST  @JOYY,@VAR9       JOYY & JOYX
[3795] B9AC 86,74           CLR  @KEYBD            Clear the code(No affect on s
[3796] B9AE BC,00,76        ST   @JOYY,@PAD        JOYSTICK Y POSITION
[3797] B9B1 06,A9,1B        CALL JOYXY             -4 to +4
[3798] B9B4 BF,4A,40        DST  >4001,@FAC        Re-store F.P. 1 in FAC
       B9B7 01
[3799] B9B8 BC,00,77        ST   @JOYX,@PAD        JOYSTICK X POSITION
[3800] B9BB 06,A9,1B        CALL JOYXY             -4 to +4
[3801] B9BE 00              RTN                    Return 
[3802]               ***********************************************************
[3803] B9BF 06,B9,83 ZJOYST CALL GJOYST
[3804] B9C2 D6,42,B3 JOYAGN CEQ  COMMAZ,@CHAT
[3805] B9C5 48,82           BR   LNKRTN
[3806] B9C7 06,AB,A9        CALL CPAR3
[3807] B9CA 06,B9,86        CALL JOYRPT
[3808] B9CD 59,C2           BR   JOYAGN
[3809]               ***********************************************************
[3810]               * MOTION PATCH for GO and STOP
[3811] B9CF 0F,79    SPGS   XML  PGMCHR            ( or ,
[3812] B9D1 D6,42,EC        CEQ  ALLZ,@CHAT        ALL?
[3813] B9D4 59,FC           BR   SPGS1             No.
[3814] B9D6 0F,79           XML  PGMCHR            Skip ALL
[3815] B9D8 0F,79           XML  PGMCHR            Skip ,
[3816] B9DA BF,4A,00        DST  1,@FAC            First sprite
       B9DD 01
[3817] B9DE 06,AF,E8        CALL SPNUM5            Get sprite table
[3818] B9E1 06,B0,1E        CALL SPMOVE            Store velocity
[3819] B9E4 BE,4A,1C        ST   28,@FAC           Last sprite
[3820] B9E7 87,00           DCLR @PAD              Index
[3821] B9E9 35,00,02 SPGSA  MOVE 2,V@>0780,V@>0780(@PAD)
       B9EC E7,80,00
       B9EF A7,80
[3822] B9F1 A3,00,00        DADD 4,@PAD            Index +4
       B9F4 04
[3823] B9F5 92,4A           DEC  @FAC              Sprite -1
[3824] B9F7 59,E9           BR   SPGSA             Done?
[3825] B9F9 05,AF,01        B    SPRMV4            Done?
[3826]               *
[3827] B9FC D6,42,FD SPGS1  CEQ  NUMBEZ,@CHAT      #?
[3828] B9FF 5A,07           BR   SPGS2             No.
[3829] BA01 06,AF,D8        CALL SPNUM6            Standard routine.
[3830] BA04 05,AE,FE        B    SPRMV3            No.
[3831]               *
[3832] BA07 D6,42,85 SPGS2  CEQ  GOZ,@CHAT         GO?
[3833] BA0A 5A,13           BR   SPGS3             No.
[3834] BA0C B2,80,C2        AND  >BF,@GKFLG        GO!!!
       BA0F BF
[3835] BA10 05,BA,1C        B    SPGS4             Done.
[3836]               *
[3837] BA13 D6,42,98 SPGS3  CEQ  STOPZ,@CHAT       STOP?
[3838] BA16 4C,86           BR   ERRSYN            No
[3839] BA18 B6,80,C2        OR   >40,@GKFLG        STOP!!!

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0067 
RXB 2024
       BA1B 40
[3840] BA1C 0F,79    SPGS4  XML  PGMCHR            Skip GO or STOP
[3841] BA1E 05,AF,01 SPGSE  B    SPRMV4            Done?
[3842]               *********************************************************
[3843]               * RXB KEY & JOYSTICK LEFT PARENTHESES AND CHECK FOR STRING?
[3844] BA21 D6,42,B7 SPAR   CEQ  LPARZ,@CHAT       (?
[3845] BA24 7A,2B           BS   SPAR1             Yes.
[3846] BA26 D6,42,B3        CEQ  COMMAZ,@CHAT      ,?
[3847] BA29 4C,86           BR   ERRSYN            No.
[3848] BA2B 0F,79    SPAR1  XML  PGMCHR            Skip ( or ,
[3849] BA2D 0F,74           XML  PARSE             Get string or value.
[3850] BA2F B6              BYTE RPARZ
[3851] BA30 D6,4C,65        CEQ  >65,@FAC2         RXB version String?
[3852] BA33 5A,43           BR   SPAR2             No normal xb version         
[3853] BA35 BD,04,4E        DST  @FAC4,@VARY       Save string address.
[3854] BA38 BD,06,50        DST  @FAC6,@VARY2      Save string length.
[3855] BA3B BF,10,99        DST  >994A,@TOPSTK     Set RXB flag.
       BA3E 4A
[3856] BA3F 06,AB,92        CALL LPARR           * Left PARENTHESES or COMMA 
[3857]               * RXB Version               * Get String or key value
[3858] BA42 00              RTN
[3859]               *
[3860] BA43 0F,7E    SPAR2  XML  SPEED
[3861] BA45 00              BYTE SYNCHK          * SYNTAX CHECKER
[3862] BA46 B3              BYTE COMMAZ          * ONLY COMMA IS VALID
[3863] BA47 00              RTN
[3864]               ***********************************************************
[3865]               * CALL JOYMOTION(keyunit,X,Y,#sprite,Rindex,Cindex)        
[3866]               * CALL JOYMOTION(keyunit,X,Y,#sprite,Rindex,Cindex,KEY)    
[3867]               * CALL JOYMOTION(keyunit,X,Y,#sprite,Rindex,Cindex,KEY)    
[3868]               * GOTO line-number                                         
[3869]               ***********************************************************
[3870] BA48 06,B9,83 ZJOMO  CALL GJOYST         * Get Key unit, X & Y 
[3871] BA4B D6,42,B3        CEQ  COMMAZ,@CHAT   * COMMA?
[3872] BA4E 4C,86           BR   ERRSYN         * SYNTAX ERROR
[3873] BA50 06,AF,D6        CALL SPNUM2         * PAD8=SPRITE ADDRESS 
[3874] BA53 06,B0,64        CALL COMMA             Parse up to comma and skip
[3875] BA56 06,B0,40        CALL RANGEV            Check if numeric and convert
[3876]               *                              to integer
[3877] BA59 BC,0A,4B        ST   @FAC1,@PADA      Store Y velocity
[3878] BA5C 0F,74           XML  PARSE            Get X velocity
[3879] BA5E B6              BYTE RPARZ          * Check for ")" or less
[3880] BA5F 06,B0,40        CALL RANGEV           Numeric check and convert
[3881]               *                             to integer
[3882] BA62 BC,4A,0A       ST   @PADA,@FAC     * @FAC=Y velocity, @FAC1=X veloci
[3883]               * CHECK DIRECTION OF JOYST AND SET UP FAC FOR LOADING VALUE
[3884] BA65 D7,14,00        DCEQ >0000,@VAR9   * >0000 JOYST
       BA68 00
[3885] BA69 5A,6D           BR   ZJOMO1        * Go UP 
[3886] BA6B 87,4A           DCLR @FAC          * Zero both
[3887] BA6D D7,14,04 ZJOMO1 DCEQ >0400,@VAR9   * UP
       BA70 00
[3888] BA71 5A,77           BR   ZJOMO2        * Go DOWN
[3889] BA73 82,4A           NEG  @FAC          * Negative
[3890] BA75 86,4B           CLR  @FAC1         * Zero
[3891] BA77 D7,14,FC ZJOMO2 DCEQ >FC00,@VAR9   * DOWN
       BA7A 00
[3892] BA7B 5A,81           BR   ZJOMO3        * Go LEFT
[3893] BA7D 80,4A           ABS  @FAC          * Postive
[3894] BA7F 86,4B           CLR  @FAC1         * Zero
[3895] BA81 D7,14,00 ZJOMO3 DCEQ >00FC,@VAR9   * LEFT
       BA84 FC
[3896] BA85 5A,8B           BR   ZJOMO4        * Go RIGHT
[3897] BA87 86,4A           CLR  @FAC          * Zero

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0068 
RXB 2024
[3898] BA89 82,4B           NEG  @FAC1         * Negative
[3899] BA8B D7,14,00 ZJOMO4 DCEQ >0004,@VAR9   * RIGHT
       BA8E 04
[3900] BA8F 5A,95           BR   ZJOMO5        * Go DOWNLEFT
[3901] BA91 86,4A           CLR @FAC           * Zero
[3902] BA93 80,4B           ABS @FAC1          * Postive
[3903] BA95 D7,14,FC ZJOMO5 DCEQ >FCFC,@VAR9   * DOWNLEFT
       BA98 FC
[3904] BA99 5A,9F           BR   ZJOMO6        * Go DOWNRIGHT
[3905] BA9B 80,4A           ABS  @FAC          * Postitive
[3906] BA9D 82,4B           NEG  @FAC1         * Negative
[3907] BA9F D7,14,FC ZJOMO6 DCEQ >FC04,@VAR9   * DOWNRIGHT     
       BAA2 04
[3908] BAA3 5A,A9           BR   ZJOMO7        * Go UPLEFT
[3909] BAA5 80,4A           ABS  @FAC          * Positive
[3910] BAA7 80,4B           ABS  @FAC1         * Postive
[3911] BAA9 D7,14,04 ZJOMO7 DCEQ >04FC,@VAR9   * UPLEFT
       BAAC FC
[3912] BAAD 5A,B3           BR   ZJOMO8        * Go UPRIGHT
[3913] BAAF 82,4A           NEG  @FAC          * Negative
[3914] BAB1 82,4B           NEG  @FAC1         * Negative
[3915] BAB3 D7,14,04 ZJOMO8 DCEQ >0404,@VAR9   * UPRIGHT 
       BAB6 04
[3916] BAB7 5A,BD           BR   ZJOMO9        * Done
[3917] BAB9 82,4A           NEG  @FAC          * Negative
[3918] BABB 80,4B           ABS  @FAC1         * Positive    
[3919] BABD BD,E4,80 ZJOMO9 DST  @FAC,V@>0480(@PAD8) * Store velocities PAD8
       BAC0 08,4A
[3920] BAC2 C4,A3,AA        CH   @NOMSPR,V@SPNUM    * Check current sprite
       BAC5 7A
[3921] BAC6 5A,CC           BR   ZJOKG              *  against sprite motion
[3922]               *                              *   counter
[3923] BAC8 BC,7A,A3        ST   V@SPNUM,@NOMSPR * higher? Yes, replace it
       BACB AA
[3924]               * KEY SECTION
[3925] BACC D6,42,B6 ZJOKG  CEQ  RPARZ,@CHAT   * )?
[3926] BACF 68,82           BS   LNKRTN        * Yes, END RETURN TO XB
[3927] BAD1 06,AC,76        CALL ERRCOM      * Check for comma, push on stack  
[3928] BAD4 BC,4B,17        ST   @FNUM,@FAC1   * KEY         
[3929] BAD7 0F,80           XML  CIF           * Convert to floating point
[3930] BAD9 0F,7C           XML  ASSGNV        * Save KEY to XB      
[3931] BADB D6,42,B6        CEQ  RPARZ,@CHAT   * )?
[3932] BADE 4C,86           BR   ERRSYN        * SYNTAX ERROR
[3933] BAE0 0F,79           XML  PGMCHR        * Skip )
[3934]               * GOTO LINE# SECTION
[3935] BAE2 D6,42,86        CEQ  GOTOZ,@CHAT   * GOTO flag?
[3936] BAE5 5A,FF           BR   ZJOMOR        * No, just RETURN to XB
[3937] BAE7 0F,79           XML  PGMCHR        * Skip GOTO or COMMA
[3938] BAE9 D6,42,C9        CEQ  LNZ,@CHAT     * Line# token?
[3939] BAEC 4C,86           BR   ERRSYN        * SYNTAX ERROR
[3940] BAEE 0F,79           XML  PGMCHR        * Skip line# token
[3941] BAF0 BC,4A,42        ST   @CHAT,@FAC    * Store high byte line#
[3942] BAF3 0F,79           XML  PGMCHR        * Skip high byte line#
[3943] BAF5 BC,4B,42        ST   @CHAT,@FAC1   * Store low byte line#
[3944] BAF8 0F,79           XML  PGMCHR        * Skip low byte line#
[3945] BAFA D6,17,12        CEQ  18,@FNUM      * FIRE BUTTON 1?
[3946] BAFD 79,57           BS   GKEY1         * Yes, find & run line#
[3947] BAFF 06,00,12 ZJOMOR CALL RETURN        * RETURN TO XB
[3948]               ***********************************************************
[3949]               * CALL JOYLOCATE(keyunit,X,Y,Rindex,Cindex,#sprite,dr,dc)  
[3950]               * CALL JOYLOCATE(keyunit,X,Y,Rindex,Cindex,#sprite,dr,dc,K)
[3951]               * CALL JOYLOCATE(keyunit,X,Y,Rindex,Cindex,#sprite,dr,dc,K)
[3952]               * GOTO line-number                                         
[3953]               ***********************************************************

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0069 
RXB 2024
[3954] BB02 06,B9,83 ZJOLO  CALL GJOYST       * Get Key unit, X & Y 
[3955] BB05 D6,42,B3        CEQ  COMMAZ,@CHAT * COMMA?
[3956] BB08 4C,86           BR   ERRSYN       * SYNTAX ERROR
[3957] BB0A 0F,79           XML  PGMCHR       * Skip COMMA
[3958] BB0C 06,AF,EF        CALL SPLOC        * Get index into PAD4 & PAD6
[3959] BB0F BC,00,05        ST   @PAD4+1,@PAD * Get Rindex
[3960] BB12 94,00           INCT @PAD         * RESET VALUE
[3961] BB14 BC,01,06        ST   @PAD6,@PAD1  * Get Cindex
[3962] BB17 90,01           INC  @PAD1        * RESET VALUE
[3963] BB19 D6,42,B3        CEQ  COMMAZ,@CHAT * COMMA?
[3964] BB1C 4C,86           BR   ERRSYN       * SYNTAX ERROR
[3965] BB1E 06,AF,D6        CALL SPNUM2       * PAD8=SPRITE ADDRESS 
[3966] BB21 06,B0,7D        CALL PREPN        * Set up for variable
[3967] BB24 BD,4A,B0        DST  V*PAD8,@FAC  * Get current dr & dc into FAC  
       BB27 08
[3968]               *
[3969]               * CHECK DIRECTION OF JOYST AND SET UP FAC FOR LOADING VALUE
[3970] BB28 D7,14,00        DCEQ >0000,@VAR9   * >0000 JOYST
       BB2B 00
[3971] BB2C 7B,82           BS   ZJOLO9        * No change 
[3972] BB2E D7,14,04 ZJOLO1 DCEQ >0400,@VAR9   * UP
       BB31 00
[3973] BB32 5B,37           BR   ZJOLO2        * Go DOWN
[3974] BB34 A4,4A,00        SUB  @PAD,@FAC     * Negative
[3975] BB37 D7,14,FC ZJOLO2 DCEQ >FC00,@VAR9   * DOWN
       BB3A 00
[3976] BB3B 5B,40           BR   ZJOLO3        * Go LEFT
[3977] BB3D A0,4A,00        ADD  @PAD,@FAC     * Postive
[3978] BB40 D7,14,00 ZJOLO3 DCEQ >00FC,@VAR9   * LEFT
       BB43 FC
[3979] BB44 5B,49           BR   ZJOLO4        * Go RIGHT
[3980] BB46 A4,4B,00        SUB  @PAD,@FAC1    * Negative
[3981] BB49 D7,14,00 ZJOLO4 DCEQ >0004,@VAR9   * RIGHT
       BB4C 04
[3982] BB4D 5B,52           BR   ZJOLO5        * Go DOWNLEFT
[3983] BB4F A0,4B,00        ADD  @PAD,@FAC1    * Postive
[3984] BB52 D7,14,FC ZJOLO5 DCEQ >FCFC,@VAR9   * DOWNLEFT
       BB55 FC
[3985] BB56 5B,5E           BR   ZJOLO6        * Go DOWNRIGHT
[3986] BB58 A0,4A,00        ADD  @PAD,@FAC     * Postitive
[3987] BB5B A4,4B,00        SUB  @PAD,@FAC1    * Negative
[3988] BB5E D7,14,FC ZJOLO6 DCEQ >FC04,@VAR9   * DOWNRIGHT     
       BB61 04
[3989] BB62 5B,6A           BR   ZJOLO7        * Go UPLEFT
[3990] BB64 A0,4A,00        ADD  @PAD,@FAC     * Positive
[3991] BB67 A0,4B,00        ADD  @PAD,@FAC1    * Postive
[3992] BB6A D7,14,04 ZJOLO7 DCEQ >04FC,@VAR9   * UPLEFT
       BB6D FC
[3993] BB6E 5B,76           BR   ZJOLO8        * Go UPRIGHT
[3994] BB70 A4,4A,00        SUB  @PAD,@FAC     * Negative
[3995] BB73 A4,4B,00        SUB  @PAD,@FAC1    * Negative
[3996] BB76 D7,14,04 ZJOLO8 DCEQ >0404,@VAR9   * UPRIGHT 
       BB79 04
[3997] BB7A 5B,82           BR   ZJOLO9        * Done
[3998] BB7C A4,4A,00        SUB  @PAD,@FAC     * Negative
[3999] BB7F A0,4B,00        ADD  @PAD,@FAC1    * Positive  
[4000] BB82 BD,B0,08 ZJOLO9 DST  @FAC,V*PAD8   * Load ROW:COL into Sprite
       BB85 4A
[4001] BB86 BD,0C,4A        DST  @FAC,@BYTES   * Save value
[4002] BB89 06,A3,0D        CALL CLRFAC
[4003] BB8C BC,4B,0C        ST   @BYTES,@FAC1
[4004] BB8F 06,A3,08        CALL CIFSND     * Put into Row
[4005] BB92 06,B0,67        CALL COMMA2     * Next value & skip COMMA
[4006] BB95 06,B0,7D        CALL PREPN      * Prepare X-pos return variable

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0070 
RXB 2024
[4007] BB98 06,A3,0D        CALL CLRFAC
[4008] BB9B BC,4B,0D        ST   @BYTES+1,@FAC1 * Get X position
[4009] BB9E 06,A3,08        CALL CIFSND     * Assign value
[4010]               * KEY SECTION
[4011] BBA1 05,BA,CC        B    ZJOKG
[4012]               ***********************************************************
[4013]               * CALL INVERSE(char#[,...])                                
[4014]               ***********************************************************
[4015] BBA4 06,A9,67 INVERS CALL COMB             * INVERSE(CHAR#)
[4016] BBA7 0F,79    INVAGN XML  PGMCHR
[4017] BBA9 D6,42,EC        CEQ  ALLZ,@CHAT
[4018] BBAC 5B,C0           BR   INOALL
[4019] BBAE 0F,7E           XML  SPEED
[4020] BBB0 00,EC           DATA >00EC
[4021] BBB2 BF,4A,00        DST  >001E,@FAC
       BBB5 1E
[4022] BBB6 E3,4A,00        DSLL 3,@FAC
       BBB9 03
[4023] BBBA BF,54,01        DST  >01C8,@TEMP1
       BBBD C8
[4024] BBBE 5B,CE           BR   INVLP
[4025] BBC0 0F,74    INOALL XML  PARSE
[4026] BBC2 B6              BYTE RPARZ
[4027] BBC3 06,BC,7F        CALL S1ET9F
[4028] BBC6 E3,4A,00        DSLL 3,@FAC
       BBC9 03
[4029] BBCA BF,54,00        DST  >0004,@TEMP1
       BBCD 04
[4030] BBCE 85,E3,00 INVLP  DINV V@>0300(@FAC)
       BBD1 4A
[4031] BBD2 A3,4A,00        DADD >0002,@FAC
       BBD5 02
[4032] BBD6 93,54           DDEC @TEMP1
[4033] BBD8 5B,CE           BR   INVLP
[4034] BBDA D6,42,B3 INVNOK CEQ  COMMAZ,@CHAT
[4035] BBDD 7B,A7           BS   INVAGN
[4036] BBDF 48,82           BR   LNKRTN
[4037]               ***********************************************************
[4038]               * CALL SWAPCHAR(character-code,character-code[,...])       
[4039]               ***********************************************************
[4040] BBE1 06,A9,67 SWCHR  CALL COMB       * SWAPCHAR(CHAR#,CHAR#)
[4041] BBE4 06,BC,74 SWCHAG CALL SSDSLL
[4042] BBE7 BD,0E,4A        DST  @FAC,@VAR4
[4043] BBEA D6,42,B3        CEQ  COMMAZ,@CHAT
[4044] BBED 4C,86           BR   ERRSYN
[4045] BBEF 06,BC,74        CALL SSDSLL
[4046] BBF2 BD,10,4A        DST  @FAC,@VAR5
[4047] BBF5 35,00,08        MOVE 8,V@>0300(@VAR4),@FAC
       BBF8 4A,E3,00
       BBFB 0E
[4048] BBFC 35,00,08        MOVE 8,V@>0300(@VAR5),V@>0300(@VAR4)
       BBFF E3,00,0E
       BC02 E3,00,10
[4049] BC05 35,00,08        MOVE 8,@FAC,V@>0300(@VAR5)
       BC08 E3,00,10
       BC0B 4A
[4050] BC0C D6,42,B3        CEQ  COMMAZ,@CHAT
[4051] BC0F 7B,E4           BS   SWCHAG
[4052] BC11 48,82           BR   LNKRTN
[4053]               ***********************************************************
[4054]               * CALL SWAPCOLOR(#sprite-number,#sprite-number[,...])      
[4055]               * CALL SWAPCOLOR(character-set,character-set[,...])        
[4056]               ***********************************************************
[4057] BC13 0F,7E    SWCLR  XML  SPEED            * Must be

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0071 
RXB 2024
[4058] BC15 00              BYTE SYNCHK           *  at a
[4059] BC16 B7              BYTE LPARZ            *   left parenthesis
[4060] BC17 D6,42,FD SCOL10 CEQ  NUMBEZ,@CHAT
[4061] BC1A 5C,47           BR   SCOL20
[4062] BC1C 06,AF,DD        CALL SPNUM3
[4063] BC1F BC,0E,E0        ST   V@>0003(@FAC),@VAR4
       BC22 03,4A
[4064] BC24 BD,10,4A        DST  @FAC,@VAR5
[4065] BC27 D6,42,FD        CEQ  NUMBEZ,@CHAT
[4066] BC2A 4C,86           BR   ERRSYN
[4067] BC2C 06,A2,AE        CALL STRFCH
[4068] BC2F 06,AF,E2        CALL SPNUM4
[4069] BC32 BC,E0,03        ST   V@>0003(@FAC),V@>0003(@VAR5)
       BC35 10,E0,03
       BC38 4A
[4070] BC39 BC,E0,03        ST   @VAR4,V@>0003(@FAC)
       BC3C 4A,0E
[4071] BC3E D6,42,B3        CEQ  COMMAZ,@CHAT
[4072] BC41 48,82           BR   LNKRTN
[4073] BC43 0F,79           XML  PGMCHR
[4074] BC45 5C,17           BR   SCOL10
[4075] BC47 0F,7E    SCOL20 XML  SPEED
[4076] BC49 01              BYTE >01
[4077] BC4A 06,BC,86        CALL S00T10
[4078] BC4D A3,4A,08        DADD >080F,@FAC
       BC50 0F
[4079] BC51 BD,0E,4A        DST  @FAC,@VAR4
[4080] BC54 0F,74           XML  PARSE
[4081] BC56 B6              BYTE RPARZ
[4082] BC57 06,BC,86        CALL S00T10
[4083] BC5A A3,4A,08        DADD >080F,@FAC
       BC5D 0F
[4084] BC5E BC,00,B0        ST   V*FAC,@PAD
       BC61 4A
[4085] BC62 BC,B0,4A        ST   V*VAR4,V*FAC
       BC65 B0,0E
[4086] BC67 BC,B0,0E        ST   @PAD,V*VAR4
       BC6A 00
[4087] BC6B D6,42,B3        CEQ  COMMAZ,@CHAT
[4088] BC6E 48,82           BR   LNKRTN
[4089] BC70 0F,79           XML  PGMCHR
[4090] BC72 5C,47           BR   SCOL20     
[4091]               *****************************************
[4092] BC74 06,A2,AE SSDSLL CALL STRFCH
[4093] BC77 06,BC,7F        CALL S1ET9F
[4094] BC7A E3,4A,00        DSLL 3,@FAC
       BC7D 03
[4095] BC7E 00              RTN
[4096]               *****************************************
[4097] BC7F 0F,7E    S1ET9F XML  SPEED  * CHECK FROM
[4098] BC81 02,1E           DATA >021E  * 30 TO 159
[4099] BC83 00,9F           DATA >009F  *
[4100] BC85 00              RTN         *
[4101]               ******************************************
[4102] BC86 0F,7E    S00T10 XML  SPEED  * CHECK FROM
[4103] BC88 02,00           DATA >0200  * 0 TO 16
[4104] BC8A 00,10           DATA >0010  *
[4105] BC8C 00              RTN         *
[4106]               ***********************************************************
[4107]               * CALL COLLIDE(#SPR1,#SPR2,TOLERANCE,S1DOTROW,S1DOTCOL)    
[4108]               * CALL COLLIDE(#SPR,DOTROW,DOTCOL,TOLERANCE,DOTROW,DOTCOL) 
[4109]                 
[4110]               ***********************************************************
[4111] BC8D 06,A9,67 COLLZ  CALL COMB              If not '(' - error

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0072 
RXB 2024
[4112] BC90 06,AF,D6 COLL3  CALL SPNUM2            Skip ( or , get SPRITE 1 valu
[4113] BC93 BD,00,B0        DST  V*FAC,@PAD        Read ROW:COL position SPRITE1
       BC96 4A
[4114] BC97 D6,42,C8        CEQ  NUMZ,@CHAT      #?
[4115] BC9A 5C,B0           BR   COLL1             Yes SPRITE not Dot values  
[4116] BC9C 06,A2,DE        CALL SUBLP4            Get DOT ROW
[4117] BC9F 92,4B           DEC  @FAC1             Adjust for Assembly
[4118] BCA1 BC,02,4B        ST   @FAC1,@PAD2       Save DOT ROW
[4119] BCA4 06,A2,CE        CALL GETNUM            Get DOT COL 
[4120] BCA7 92,4B           DEC  @FAC1             Adjust for Assembly
[4121] BCA9 BC,03,4B        ST   @FAC1,@PAD3       Save DOT COL 
[4122] BCAC 0F,79           XML  PGMCHR            Skip COMMA 
[4123] BCAE 5C,B7           BR   COLL2             Go to TOLLERANCE
[4124] BCB0 06,AF,D8 COLL1  CALL SPNUM6            Skip # get SPRITE 2 value
[4125] BCB3 BD,02,B0        DST  V*FAC,@PAD2       Read ROW:COL position SPRITE2
       BCB6 4A
[4126] BCB7 06,A2,DE COLL2  CALL SUBLP4            Get TOLERANCE in FAC     
[4127] BCBA 86,8F,DD        CLR  @>6004            Set ROM 3 page
       BCBD 04
[4128] BCBE 0F,80           XML  COLLSP            COLLIDE SPRITES
[4129] BCC0 0F,79           XML  PGMCHR            Skip COMMA
[4130] BCC2 06,A3,01        CALL SNDER            Get variable info
[4131] BCC5 06,A3,0D        CALL CLRFAC           Clear for FP
[4132] BCC8 BD,4A,00        DST  @PAD,@FAC        Get QUOTIENT
[4133] BCCB 06,A3,08        CALL CIFSND           Send QUOTIENT
[4134] BCCE 0F,79           XML  PGMCHR           Skip COMMA
[4135] BCD0 06,A3,01        CALL SNDER            Get variable info 
[4136] BCD3 06,A3,0D        CALL CLRFAC           Clear for FP       
[4137] BCD6 BD,4A,02        DST  @PAD2,@FAC       REMAINDER
[4138] BCD9 06,A3,08        CALL CIFSND           Send REMAINDER 
[4139] BCDC D6,42,B3        CEQ  COMMAZ,@CHAT     ,?
[4140] BCDF 7C,90           BS   COLL3            Yes loop
[4141] BCE1 48,82           BR   LNKRTN           RETURN TO XB
[4142]               *******************************
[4143] BCE3 0F,7A    SETSND XML  SYM               Pick up name & search table
[4144] BCE5 0F,7B           XML  SMB               Evaluate any subscripts
[4145] BCE7 C6,4C,63        CH   >63,@FAC2         If not numeric, error
[4146] BCEA 6C,BE           BS   ERRIAL            ERROR INCORRECT ARGUMENT LIST
[4147] BCEC 06,A3,0D        CALL CLRFAC            Clear FAC 8 bytes
[4148] BCEF 00              RTN                    Return
[4149]               ***********************************************************
[4150]               * RXB SIZE ADDRESS DISPLAY
[4151] BCF0 0F,83    CASCII XML  SCROLL
[4152] BCF2 BC,00,5C        ST   @ARG,@PAD         * Bit 1
[4153] BCF5 E6,00,04        SRL  4,@PAD            * Strip off Bit 2
[4154] BCF8 CA,00,0A        CHE  >0A,@PAD          * Higher >0A?
[4155] BCFB 7D,02           BS   BIT1D             * Yes
[4156] BCFD A2,00,30        ADD  48,@PAD           * 0 - 9 + "0 ASCII"
[4157] BD00 5D,08           BR   BIT2              * Done Bit 1
[4158] BD02 A6,00,0A BIT1D  SUB  10,@PAD
[4159] BD05 A2,00,41        ADD  65,@PAD           * A - F + "@ ASCII"
[4160] BD08 BC,4A,00 BIT2   ST   @PAD,@FAC         * Save Bit 1 as ASCII
[4161] BD0B BC,00,5C        ST   @ARG,@PAD         * Bit 2
[4162] BD0E E2,00,04        SLL  4,@PAD            * Strip off Bit 1
[4163] BD11 E6,00,04        SRL  4,@PAD            * Reset Bit 2
[4164] BD14 CA,00,0A        CHE  >0A,@PAD          * Higher >0A?
[4165] BD17 7D,1E           BS   BIT2D             * Yes
[4166] BD19 A2,00,30        ADD  48,@PAD           * 0 - 9 + "0 ASCII"
[4167] BD1C 5D,24           BR   BIT3              * Done Bit 2
[4168] BD1E A6,00,0A BIT2D  SUB  10,@PAD
[4169] BD21 A2,00,41        ADD  65,@PAD           * A - F + "@ ASCII"          
[4170] BD24 BC,4B,00 BIT3   ST   @PAD,@FAC1        * Save Bit 2 as ASCII      
[4171] BD27 BC,00,5D        ST   @ARG1,@PAD        * Bit 3
[4172] BD2A E6,00,04        SRL  4,@PAD            * Strip off Bit 4        

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0073 
RXB 2024
[4173] BD2D CA,00,0A        CHE  >0A,@PAD          * Higher >0A?
[4174] BD30 7D,37           BS   BIT3D             * Yes
[4175] BD32 A2,00,30        ADD  48,@PAD           * 0 - 9 + "0 ASCII"
[4176] BD35 5D,3D           BR   BIT4              * Done Bit 3
[4177] BD37 A6,00,0A BIT3D  SUB  10,@PAD
[4178] BD3A A2,00,41        ADD  65,@PAD           * A - F + "@ ASCII"
[4179] BD3D BC,4C,00 BIT4   ST   @PAD,@FAC2        * Save Bit 3 as ASCII
[4180] BD40 BC,00,5D        ST   @ARG1,@PAD        * Bit 4
[4181] BD43 E2,00,04        SLL  4,@PAD            * Strip off Bit 3
[4182] BD46 E6,00,04        SRL  4,@PAD            * Reset Bit 4
[4183] BD49 CA,00,0A        CHE  >0A,@PAD          * Higher >0A?
[4184] BD4C 7D,53           BS   BIT4D             * Yes
[4185] BD4E A2,00,30        ADD  48,@PAD           * 0 - 9 + "0 ASCII"
[4186] BD51 5D,59           BR   BITDI             * Done Bit 2
[4187] BD53 A6,00,0A BIT4D  SUB  10,@PAD
[4188] BD56 A2,00,41        ADD  65,@PAD           * A - F + "@ ASCII"          
[4189] BD59 BC,4D,00 BITDI  ST   @PAD,@FAC3        * Save Bit 2 as ASCII      
[4190] BD5C 08              FMT
[4191] BD5D FC,60            SCRO >60
[4192] BD5F FE,17            ROW 23
[4193] BD61 FF,04            COL 4
[4194] BD63 40,3E            HCHA 1,62
[4195] BD65 FE,17            ROW 23
[4196] BD67 FF,05            COL 5
[4197] BD69 E3,4A            HSTR 4,@FAC   
[4198] BD6B FB              FEND
[4199] BD6C 00              RTN
[4200]               ********************************************************
[4201]              
[4202]                      AORG >1FE0
[4203]               * MOSTLY SUBROUTINES FOR GROM 6
[4204] BFE0 49,67           BR   COMB        * >BFE0
[4205] BFE2 42,AE           BR   STRFCH      * >BFE2
[4206] BFE4 42,B0           BR   STRPAR      * >BFE4
[4207] BFE6 42,B4           BR   STRGET      * >BFE6
[4208] BFE8 42,BD           BR   NUMFCH      * >BFE8
[4209] BFEA 42,C6           BR   CFIFCH      * >BFEA
[4210] BFEC 42,D1           BR   GNRTN       * >BFEC
[4211] BFEE 42,E6           BR   NGOOD       * >BFEE
[4212] BFF0 43,01           BR   SNDER       * >BFF0
[4213] BFF2 43,08           BR   CIFSND      * >BFF2
[4214] BFF4 43,0A           BR   SNDASS      * >BFF4
[4215] BFF6 42,D7           BR   SUBLP3      * >BFF6
[4216] BFF8 42,DE           BR   SUBLP4      * >BFF8
[4217] BFFA 43,0D           BR   CLRFAC      * >BFFA
[4218] BFFC 42,CE           BR   GETNUM      * >BFFC
[4219]               ********************************************************
[4220]                      END

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0074 
RXB 2024
Symbol Table #1 (New,alpha)  
0041 A          00CB ABSZ       801E ACCEPT     A192 ACCEPX     00A4 ACCEPZ     
8302 ACCUM      00EC ALLZ       00BB ANDZ       00F9 APPENZ     B07A AR         
835D ARG1       835E ARG2       8360 ARG4       8362 ARG6       8363 ARG7       
8364 ARG8       A7C7 ASC        A459 ASC01      0076 ASCHEX     00DC ASCZ       
007C ASSGNV     B072 ASSRTN     00CC ATNZ       A798 ATTNUT     A95B ATTREG     
00F0 ATZ        0008 BACK       00F1 BASEZ      00EE BEEPZ      BD02 BIT1D      
BD08 BIT2       BD1E BIT2D      BD24 BIT3       BD37 BIT3D      BD3D BIT4       
BD53 BIT4D      BD59 BITDI      0020 BKGD       ABB8 BORDER     0002 BREAK      
008E BREAKZ     8346 BUFLEV     8366 BYTE1      8367 BYTE2      8368 BYTE3      
830C BYTES      009D CALLZ      BCF0 CASCII     837D CB         834E CCC        
834A CCHAR      8306 CCPPTR     0012 CFI        A2C6 CFIFCH     007D CHAR       
AB1F CHAR1      AB13 CHAR2      AAFD CHAR5      AB47 CHARL4     AB22 CHARLD     
AAFA CHARLY     8342 CHAT       6A78 CHKEND     AFB0 CHRALL     AB36 CHRFIL     
007F CHRLDR     AF94 CHRSET     601C CHRTAB     6018 CHRTBL     000D CHRTN      
A43E CHRZ01     00D6 CHRZZ      0080 CIF        A308 CIFSND     00C5 CIRCUZ     
A32C CKSTNM     0079 CLEARP     A989 CLEARZ     800A CLOSE      A18F CLOSEX     
00A0 CLOSEZ     A30D CLRFAC     0007 CLRLN      A990 CLRPZ      A10A CLRRTN     
8012 CLSALL     AF7C CODIS1     AF82 CODIS2     AF54 CODIST     B888 COINLP     
A892 COL08      A8A5 COL09      A8AD COL10      A8BA COL20      A8C3 COL21      
A8F1 COL22      BCB0 COLL1      BCB7 COLL2      BC90 COLL3      0080 COLLSP     
BC8D COLLZ      003A COLON      00B5 COLONZ     A88E COLORZ     A967 COMB       
B064 COMMA      B067 COMMA2     002C COMMAT     00B3 COMMAZ     A3CD CONC06     
A377 CONCAT     00B8 CONCZ      A244 CONPI      0075 CONT       B1DB CONTIN     
A822 CONV1      00CD COSZ       AB9D CPAR       ABA1 CPAR2      ABA9 CPAR3      
0820 CRNBUF     B6C6 CRUI       B6E1 CRUI16     B6F1 CRUO       B707 CRUO16     
B716 CRUO8      B740 CRUSET     B738 CRUTMP     B756 CSLOAD     0390 CSNTMP     
03BA CSNTP1     0010 CSNUM      B723 CSR        B72B CSV        B71B CSW        
007E CURSOR     8334 DATA       834D DATAAD     A7AB DATAST     0093 DATAZ      
A7C6 DATST1     0081 DCHAR      8354 DDD1       0089 DEFZ       8002 DELET      
A198 DELETX     0099 DELETZ     A747 DELINK     00E9 DIGITZ     008A DIMZ       
B197 DIRSPH     B0C0 DIRSPK     B897 DISLP      6A7C DISO       8000 DISPL1     
A195 DISPLX     00A2 DISPLZ     AF2C DIST       00C4 DIVIZ      0003 DLETE      
0024 DOLLAR     000A DOWN       000A DWNARR     007F EDGECH     8350 EEE        
8358 EEE1       0081 ELSEZ      008B ENDZ       8332 ENLN       6A80 ENT09      
6A7E ENTER      801C EOF        A177 EOFX       00BE EQUALZ     00EF ERASEZ     
837C ERCODE     A7E8 ERORZ      AC0B ERR10      ACB6 ERRBA      A137 ERRBRK     
ACAE ERRBS      ACBA ERRBV      AC7B ERRC05     8322 ERRCOD     AC76 ERRCOM     
AC9E ERRFNN     ACBE ERRIAL     038A ERRLN      ACB2 ERRLNF     AC92 ERRMEM     
AC8E ERRMUV     AC9A ERRNWF     A5D6 ERROLP     00A5 ERRORZ     A0DD ERRRDY     
ACA6 ERRRSC     ACAA ERRRWG     ACC2 ERRSNF     AC8A ERRSNM     ACA2 ERRSNS     
AC96 ERRSO      B4DD ERRSSL     AC86 ERRSYN     ABC5 ERRWXY     6A84 ERRZZ      
A090 EXEC       A09D EXEC1      A0B0 EXEC20     A11B EXEC6C     A11F EXEC6D     
A10E EXECBK     0076 EXECG      A0D3 EXECND     A0E1 EXECTR     00CE EXPZZ      
832E EXTRAM     0046 F          834B FAC1       8354 FAC10      8355 FAC11      
8356 FAC12      8358 FAC14      8359 FAC15      834C FAC2       834D FAC3       
834E FAC4       8350 FAC6       8351 FAC7       8352 FAC8       8353 FAC9       
000A FCOMP      0009 FDIV       834E FFF        8356 FFF1       00FA FIXEDZ     
8345 FLAG       A332 FLT1       0012 FLTINT     A998 FLTS       0008 FMUL       
B2E6 FNDNUM     8317 FNUM       0009 FORW       008C FORZ       B3DC FOUND      
8340 FREPTR     A024 GA024      A0A2 GA0AE      A0A6 GA0B2      A0F6 GA102      
A1AB GA1B7      A1B8 GA1C4      A202 GA20E      A20A GA216      A219 GA225      
A221 GA22D      A257 GA263      A35F GA420      A36A GA42B      A39A GA45B      
A47D GA53E      A4B9 GA57C      A4E1 GA5A4      A4EB GA5AE      A586 GA649      
A596 GA659      A5B6 GA679      A60E GA6D1      A617 GA6DA      A63C GA6FF      
A65D GA720      A678 GA73B      A6D9 GA79C      A6DC GA79F      A71F GA7E2      
A733 GA7F6      A739 GA7FC      A770 GA833      A783 GA846      A787 GA84A      
A789 GA84C      A793 GA856      A7C4 GA887      A7D4 GA897      A7E2 GA8A5      
A836 GA8F9      A9C4 GAA39      A9D8 GAA4D      AB51 GABD1      AB84 GAC04      
AB87 GAC07      ABC8 GAC99      ABDE GACAF      ABE9 GACBA      ABF4 GACC5      
ABFD GACCE      ABFF GACD0      AC32 GAD03      AC3A GAD0B      AC6D GAD3E      
AC71 GAD42      AE38 GAEBB      AE5C GAEF6      AE63 GAEFD      AE82 GAF1C      
AE84 GAF1E      AEA3 GAF3D      AEBC GAF56      AED2 GAF6C      AF2F GAFC4      
AF50 GAFE5      B05D GB0DB      B063 GB0E1      B0DE GB158      B0F6 GB170      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0075 
RXB 2024
B0F9 GB173      B104 GB17E      B10E GB188      B11C GB196      B126 GB1A0      
B12D GB1A7      B154 GB1CE      B182 GB1FC      B184 GB1FE      B1C7 GB241      
B1DE GB258      B220 GB29C      B22E GB2AA      B26F GB2EB      B29A GB316      
B29C GB318      B2C0 GB33C      B2CA GB346      B2D3 GB34F      B2D6 GB352      
B2F4 GB370      B300 GB37C      B30F GB38B      B31F GB39B      B330 GB3AC      
B33D GB3B9      B348 GB3C4      B349 GB3C5      B358 GB3D4      B361 GB3DD      
B378 GB3F4      B388 GB404      B391 GB40D      B3B4 GB430      B3D2 GB44E      
B411 GB48D      B41C GB498      B425 GB4A1      B444 GB4C0      B44A GB4C6      
B455 GB4D1      B46C GB4E8      A83A GCHAR1     A859 GCHAR2     A875 GCHAR3     
A837 GCHARZ     E025 GE025      A2CE GETNUM     B2A3 GETPRM     0071 GETSTR     
B320 GETTIM     B983 GJOYST     B957 GKEY1      B95E GKEY2      B972 GKEY3      
83C2 GKFLG      B7F5 GMAGN      B800 GMO1       B80F GMO2       B81B GMO3       
B7F2 GMOT       A2D1 GNRTN      0087 GOSUBZ     B91C GOTON0     0086 GOTOZ      
0085 GOZ        AADC GPHVRC     A223 GPLCAL     008C GREAD1     003E GREAT      
00C0 GREATZ     0022 GRINT      6034 GRSUB1     802C GRSUB2     802E GRSUB3     
008B GVWITE     6036 GWSUB      0074 HCHAR      AA71 HCHAR1     AA81 HCHAR2     
AA6E HCHARZ     B5CE HEX        B62E HEX00      B661 HEX01      B677 HEX02      
B685 HEX03      B693 HEX04      B69A HEX05      B5D1 HEXAGN     B648 HEXDON     
B61C HEXNS      B624 HEXNS2     B64F HEXSTR     007A HGET       B7B0 HGETS      
B7AD HGETZ      B769 HPOUT      0077 HPUT       B763 HPUTS      B760 HPUTZ      
AAC3 HVCHR      AACC HVCHR1     AAD8 HVCHS      B7D3 HVGETS     B799 HVPUTN     
AAA2 HVRC       002D HYPEN      0084 IFZ        00A3 IMAGEZ     BBC0 INOALL     
8006 INPUT      A189 INPUTX     0092 INPUTZ     0004 INSRT      A906 INTARG     
00F5 INTERZ     A281 INTRND     00CF INTZ       BBA7 INVAGN     BBA4 INVERS     
BBCE INVLP      BBDA INVNOK     B69E IOAGN      B731 IODONE     B86C J1         
B86E J2         B87A J3         B9C2 JOYAGN     A92E JOYAV      A926 JOYNZ      
B986 JOYRPT     B9A6 JOYSTS     8377 JOYX       A91B JOYXY      8376 JOYY       
AB4E KEY        AB65 KEY1B      AB89 KEY1C      AB8D KEY2       AB8F KEY2A      
8374 KEYBD      B8AB KEYJOY     B8CB KEYSTR     A432 LEN01      A43A LEN02      
8360 LENCST     8362 LENWST     00D5 LENZ       003C LESS       00BF LESSZ      
008D LETZ       A810 LINE       A5E1 LINEGP     A026 LINK1      A030 LINK2      
A03A LINK3      A044 LINK4      A04E LINK5      A058 LINK6      A062 LINK7      
A06B LINK8      A073 LINK9      A07D LINKA      A088 LINKB      ACC6 LINKS1     
ACD1 LINKS2     ACDF LINKS3     ACEC LINKS4     ACF6 LINKS5     AD02 LINKS6     
AD0D LINKS7     AD18 LINKS8     AD24 LINKS9     AD31 LINKSA     AD39 LINKSB     
AD43 LINKSC     AD4F LINKSD     AD59 LINKSE     AD63 LINKSF     AD6C LINKSG     
AD75 LINKSH     AD7E LINKSI     AD87 LINKSJ     AD93 LINKSK     AD9F LINKSL     
ADA7 LINKSM     ADAE LINKSN     ADBC LINKSO     ADCA LINKSP     ADD6 LINKSQ     
ADE3 LINKSR     ADF1 LINKSS     AE00 LINKST     8030 LINPUT     A19B LINPUX     
00AA LINPUZ     0002 LISTZ      A33A LITS05     A36B LITS06     A343 LITS07     
A345 LITS08     A350 LITS09     8336 LNBUF      A5EB LNGP1      A5FF LNGP2      
A623 LNGP2B     A637 LNGP4      A886 LNKRT2     A882 LNKRTN     00C9 LNZ        
B471 LOADAD     0371 LODFLG     00D0 LOGZ       B3B5 LOOKUP     B171 LOOP1      
B1B3 LOOPR      AB92 LPARR      00B7 LPARZ      8348 LSUBP      A261 MAXMIN     
00DF MAXZ       0008 MERGEZ     002D MINUS      00C2 MINUSZ     00E0 MINZ       
8302 MNUM       B4E1 MOVES      B4E4 MOVESA     B50F MOVESB     B52A MOVESC     
B5C7 MOVESD     B527 MOVESN     B509 MOVESX     B53D MTYPE      B547 MTYPE0     
B54F MTYPE1     B55D MTYPE2     B56A MTYPE3     B574 MTYPE4     B57D MTYPE5     
B58C MTYPE6     B59A MTYPE7     B5A4 MTYPE8     B5AC MTYPE9     B5BA MTYPEA     
B535 MTYPES     00C3 MULTZ      A5C8 NBREAK     B3F7 NEXT       B137 NEXT1      
B14C NEXT2      0096 NEXTZ      A2E6 NGOOD      A2E8 NGOOD1     0039 NINE       
02E2 NLNADD     A24C NMAX       A252 NMAXZ1     A259 NMIN       B843 NOALL      
837A NOMSPR     B39A NOTIME     00BD NOTZ       A23C NPI        B077 NR         
800E NREAD      A180 NREADX     A287 NRND       A28D NRND1      A29B NRND2      
A29D NRND3      A2AA NRND4      A2AC NRND5      A324 NRNDCT     A315 NRNDMZ     
A5BE NTRACE     8328 NUDTAB     A13B NUDTB      B06F NULRTN     0023 NUMBER     
00FD NUMBEZ     0000 NUMBR      00C8 NUMCOZ     B39E NUMERC     00E8 NUMERZ     
A2BD NUMFCH     A2C0 NUMSNM     A94E NUMVAR     00C8 NUMZ       A5DA NUNBRK     
A5C3 NUNTRC     B83B NXALL      B1F0 NXTPAR     B461 NXTPHR     0060 OFFSET     
0005 OLDZ       A20C ONBRK      0378 ONECHR     A1CE ONERR      A1E6 ONERR2     
A1FA ONERR4     B947 ONKEY1     B92A ONLP       A19E ONWARN     A1C3 ONWRN5     
A1C5 ONWRN7     009B ONZ        8008 OPEN       A18C OPENX      009F OPENZ      
009E OPTIOZ     00BA ORZ        00F7 OUTPUZ     AF4C OVER       8301 PAD1       
8310 PAD10      8312 PAD12      8316 PAD16      8302 PAD2       8303 PAD3       

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0076 
RXB 2024
8304 PAD4       8306 PAD6       8307 PAD7       8308 PAD8       830A PADA       
830B PADB       0001 PARCOM     A4A4 PARFF      0074 PARSE      002E PERIOD     
00FB PERMAZ     0079 PGMCHR     832C PGMPTR     835D PHDATA     8300 PHLEN      
8301 PHRADD     B2B9 PHRASE     00DD PIZ        002B PLUS       00C1 PLUSZ      
A4FA POS01      A535 POS02      A543 POS04      A552 POS06      A554 POS08      
A559 POS10      A561 POS12      00D9 POSZ       B07D PREPN      8344 PRGFLG     
8004 PRINT      A183 PRINTX     009C PRINTZ     83CE PRTNFN     835E PTCBED     
830E PTCCIP     8308 PTCCIS     8314 PTCCPH     8304 PTEBSL     8312 PTFBPH     
8300 PTFBSL     830C PTFCIP     8306 PTFCIS     B374 PTIME      8302 PTLBSL     
834F PTLCIL     8310 PTLCIP     830A PTLCIS     8316 PTLCPH     A36F PUSSTR     
B780 PUTZ       B7AC PUTZ1      0022 QUOTE      8389 RAMFLG     8386 RAMFRE     
8384 RAMTOP     ABAF RAN16      8378 RANDOM     0095 RANDOZ     0002 RANGE      
B040 RANGEV     8358 READ       B4A3 READAD     0097 READZ      8022 REC        
0006 RECALL     A17D RECX       00DE RECZ       00F4 RELATZ     009A REMZ       
0006 RESEQZ     800C RESTOR     A186 RESTOX     0094 RESTOZ     0088 RETURZ     
AAD9 RGPHV      8375 RKEY       B82C RMAGN      B852 RMALL      B829 RMOT       
B85A RMOTLP     B283 RNDAG      A326 RNDM1      00D7 RNDZ       00B6 RPARZ      
A565 RPTZ01     A5A4 RPTZ02     00E1 RPTZZ      B8D9 RSCAN      B8E2 RSCAN0     
B8E5 RSCAN1     B8E9 RSCAN2     B8FF RSCAN3     B900 RSCAN4     B905 RSCAN5     
0082 RTNB       8326 RTNG       A4F6 RTNSET     00A9 RUNZ       B69B RXBIO      
BC86 S00T10     BC7F S1ET9F     0388 SAVEVP     0007 SAVEZ      B090 SAY        
0384 SBUFLV     BC17 SCOL10     BC47 SCOL20     0083 SCROLL     B3DD SEARCH     
A3CF SEGZ01     A413 SEGZ06     A42E SEGZ08     00D8 SEGZZ      003B SEMICO     
00B4 SEMICZ     00F6 SEQUEZ     B2B5 SETCB      B4D6 SETRW      BCE3 SETSND     
0386 SEXTRM     0398 SFLAG      00D1 SGNZZ      00D2 SINZ       00EB SIZEZ      
0396 SLSUBP     007B SMB        AA4A SND05      A30A SNDASS     A301 SNDER      
A9A0 SNDREG     B6BC SOG        A9E2 SOUND1     AA2A SOUND2     AA11 SOUND3     
AA48 SOUND5     AA59 SOUND6     B6C1 SOV        0020 SPACE      BA21 SPAR       
BA2B SPAR1      BA43 SPAR2      B00C SPCHR      A8FA SPCOL      0084 SPDEL      
AE40 SPDEL1     AE55 SPDEL2     B151 SPEAK      007E SPEED      B1E7 SPGET      
0382 SPGMPT     B9CF SPGS       B9FC SPGS1      BA07 SPGS2      BA13 SPGS3      
BA1C SPGS4      B9E9 SPGSA      BA1E SPGSE      8369 SPKSTS     834B SPLFLG     
AFEF SPLOC      AFF2 SPLOC2     B01E SPMOVE     B03F SPMOVF     03AA SPNUM      
AFD6 SPNUM2     AFDD SPNUM3     AFE2 SPNUM4     AFE8 SPNUM5     AFD8 SPNUM6     
AEA6 SPRCOI     AE3D SPRDEL     6016 SPRINT     AF0B SPRLC2     AF08 SPRLOC     
AEDB SPRMAG     AEDE SPRMLP     AEF8 SPRMOV     AEFB SPRMV2     AEFE SPRMV3     
AF01 SPRMV4     AE68 SPRP02     AE99 SPRP03     AF1C SPRPAT     AE65 SPRPOS     
AF1F SPRPT2     0300 SPRSAL     AE12 SPRT3      AE27 SPRT4      AE0C SPRTE      
07FF SPRVB      0083 SPSPD5     00D3 SQRZ       A984 SQU05      A96D SQUISH     
8020 SRDATA     831C SREF       BC74 SSDSLL     0082 SSEPZ      000C SSUB       
830A STADDR     0372 START      B4BB STDATA     00B2 STEPZ      8330 STLN       
0098 STOPZ      A2AE STRFCH     A2B4 STRGET     00C7 STRINZ     8364 STRLEN     
A2B0 STRPAR     8312 STRPTR     0065 STRVAL     A46A STRZ01     00DB STRZZ      
8324 STVSPT     A2D7 SUBLP3     A2DE SUBLP4     00A8 SUBNDZ     00A7 SUBXTZ     
00A1 SUBZ       BBE4 SWCHAG     BBE1 SWCHR      BC13 SWCLR      007A SYM        
0376 SYMBOL     833E SYMTAB     0000 SYNCHK     63A5 SZNEW      601E SZRUN      
A17A SZRUNX     00FC TABZ       00D4 TANZ       8354 TEMP1      8356 TEMP2      
8364 TEMP4      8366 TEMP5      8368 TEMP6      00B0 THENZ      8379 TIMER      
B310 TIMING     8351 TIMLEN     63DD TOPL15     6372 TOPLEV     8310 TOPSTK     
834C TOTTIM     00B1 TOZ        0090 TRACEZ     0083 TREMZ      B3B7 TRYAGN     
00EA UALPHZ     A639 UBSUB      A649 UBSUB1     A654 UDF        A634 UNBK01     
008F UNBREZ     00C8 UNQSTZ     0091 UNTRAZ     000B UPARR      00F8 UPDATZ     
000B UPMV       00ED USINGZ     B7C3 VAGAIN     00DA VAL        A494 VAL01      
A4AE VALCD      00FE VALIDZ     830E VAR4       8310 VAR5       8311 VAR6       
8312 VAR7       8314 VAR9       00F3 VARIAZ     8320 VARW       8304 VARY       
8306 VARY2      0075 VCHAR      AA8B VCHAR1     AA9B VCHAR2     AA88 VCHARZ     
837B VDPSTT     007B VGET       B7C0 VGETZ      0078 VPOP       B779 VPOUT      
0077 VPUSH      0078 VPUT       B773 VPUTS      B770 VPUTZ      0379 VRMSND     
03C0 VROAZ      001C VWIDTH     B4CB WAIT       A0C8 WARNGZ     00A6 WARNZ      
6A82 WARNZZ     835A WRITE      A62E WRNLNF     A0CD WRNN01     A82E WRNNO      
A396 WRNST1     A57E WRNST2     0003 X2         0073 XBCNS      8316 XFLAG      
A5C1 XMLCON     00BC XORZ       A9A9 XSOUND     B894 ZDIST      0030 ZERO       
BACC ZJOKG      BB02 ZJOLO      BB2E ZJOLO1     BB37 ZJOLO2     BB40 ZJOLO3     
BB49 ZJOLO4     BB52 ZJOLO5     BB5E ZJOLO6     BB6A ZJOLO7     BB76 ZJOLO8     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0077 
RXB 2024
BB82 ZJOLO9     BA48 ZJOMO      BA6D ZJOMO1     BA77 ZJOMO2     BA81 ZJOMO3     
BA8B ZJOMO4     BA95 ZJOMO5     BA9F ZJOMO6     BAA9 ZJOMO7     BAB3 ZJOMO8     
BABD ZJOMO9     BAFF ZJOMOR     B9BF ZJOYST     B8A1 ZKEY       B90C ZONKEY     
B885 ZSCOI      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0078 
RXB 2024
Symbol Table #2 (New,value)  
0000 NUMBR      0000 SYNCHK     0001 PARCOM     0002 BREAK      0002 LISTZ      
0002 RANGE      0003 DLETE      0003 X2         0004 INSRT      0005 OLDZ       
0006 RECALL     0006 RESEQZ     0007 CLRLN      0007 SAVEZ      0008 BACK       
0008 FMUL       0008 MERGEZ     0009 FDIV       0009 FORW       000A DOWN       
000A DWNARR     000A FCOMP      000B UPARR      000B UPMV       000C SSUB       
000D CHRTN      0010 CSNUM      0012 CFI        0012 FLTINT     001C VWIDTH     
0020 BKGD       0020 SPACE      0022 GRINT      0022 QUOTE      0023 NUMBER     
0024 DOLLAR     002B PLUS       002C COMMAT     002D HYPEN      002D MINUS      
002E PERIOD     0030 ZERO       0039 NINE       003A COLON      003B SEMICO     
003C LESS       003E GREAT      0041 A          0046 F          0060 OFFSET     
0065 STRVAL     0071 GETSTR     0073 XBCNS      0074 HCHAR      0074 PARSE      
0075 CONT       0075 VCHAR      0076 ASCHEX     0076 EXECG      0077 HPUT       
0077 VPUSH      0078 VPOP       0078 VPUT       0079 CLEARP     0079 PGMCHR     
007A HGET       007A SYM        007B SMB        007B VGET       007C ASSGNV     
007D CHAR       007E CURSOR     007E SPEED      007F CHRLDR     007F EDGECH     
0080 CIF        0080 COLLSP     0081 DCHAR      0081 ELSEZ      0082 RTNB       
0082 SSEPZ      0083 SCROLL     0083 SPSPD5     0083 TREMZ      0084 IFZ        
0084 SPDEL      0085 GOZ        0086 GOTOZ      0087 GOSUBZ     0088 RETURZ     
0089 DEFZ       008A DIMZ       008B ENDZ       008B GVWITE     008C FORZ       
008C GREAD1     008D LETZ       008E BREAKZ     008F UNBREZ     0090 TRACEZ     
0091 UNTRAZ     0092 INPUTZ     0093 DATAZ      0094 RESTOZ     0095 RANDOZ     
0096 NEXTZ      0097 READZ      0098 STOPZ      0099 DELETZ     009A REMZ       
009B ONZ        009C PRINTZ     009D CALLZ      009E OPTIOZ     009F OPENZ      
00A0 CLOSEZ     00A1 SUBZ       00A2 DISPLZ     00A3 IMAGEZ     00A4 ACCEPZ     
00A5 ERRORZ     00A6 WARNZ      00A7 SUBXTZ     00A8 SUBNDZ     00A9 RUNZ       
00AA LINPUZ     00B0 THENZ      00B1 TOZ        00B2 STEPZ      00B3 COMMAZ     
00B4 SEMICZ     00B5 COLONZ     00B6 RPARZ      00B7 LPARZ      00B8 CONCZ      
00BA ORZ        00BB ANDZ       00BC XORZ       00BD NOTZ       00BE EQUALZ     
00BF LESSZ      00C0 GREATZ     00C1 PLUSZ      00C2 MINUSZ     00C3 MULTZ      
00C4 DIVIZ      00C5 CIRCUZ     00C7 STRINZ     00C8 NUMCOZ     00C8 NUMZ       
00C8 UNQSTZ     00C9 LNZ        00CB ABSZ       00CC ATNZ       00CD COSZ       
00CE EXPZZ      00CF INTZ       00D0 LOGZ       00D1 SGNZZ      00D2 SINZ       
00D3 SQRZ       00D4 TANZ       00D5 LENZ       00D6 CHRZZ      00D7 RNDZ       
00D8 SEGZZ      00D9 POSZ       00DA VAL        00DB STRZZ      00DC ASCZ       
00DD PIZ        00DE RECZ       00DF MAXZ       00E0 MINZ       00E1 RPTZZ      
00E8 NUMERZ     00E9 DIGITZ     00EA UALPHZ     00EB SIZEZ      00EC ALLZ       
00ED USINGZ     00EE BEEPZ      00EF ERASEZ     00F0 ATZ        00F1 BASEZ      
00F3 VARIAZ     00F4 RELATZ     00F5 INTERZ     00F6 SEQUEZ     00F7 OUTPUZ     
00F8 UPDATZ     00F9 APPENZ     00FA FIXEDZ     00FB PERMAZ     00FC TABZ       
00FD NUMBEZ     00FE VALIDZ     02E2 NLNADD     0300 SPRSAL     0371 LODFLG     
0372 START      0376 SYMBOL     0378 ONECHR     0379 VRMSND     0382 SPGMPT     
0384 SBUFLV     0386 SEXTRM     0388 SAVEVP     038A ERRLN      0390 CSNTMP     
0396 SLSUBP     0398 SFLAG      03AA SPNUM      03BA CSNTP1     03C0 VROAZ      
07FF SPRVB      0820 CRNBUF     6016 SPRINT     6018 CHRTBL     601C CHRTAB     
601E SZRUN      6034 GRSUB1     6036 GWSUB      6372 TOPLEV     63A5 SZNEW      
63DD TOPL15     6A78 CHKEND     6A7C DISO       6A7E ENTER      6A80 ENT09      
6A82 WARNZZ     6A84 ERRZZ      8000 DISPL1     8002 DELET      8004 PRINT      
8006 INPUT      8008 OPEN       800A CLOSE      800C RESTOR     800E NREAD      
8012 CLSALL     801C EOF        801E ACCEPT     8020 SRDATA     8022 REC        
802C GRSUB2     802E GRSUB3     8030 LINPUT     8300 PHLEN      8300 PTFBSL     
8301 PAD1       8301 PHRADD     8302 ACCUM      8302 MNUM       8302 PAD2       
8302 PTLBSL     8303 PAD3       8304 PAD4       8304 PTEBSL     8304 VARY       
8306 CCPPTR     8306 PAD6       8306 PTFCIS     8306 VARY2      8307 PAD7       
8308 PAD8       8308 PTCCIS     830A PADA       830A PTLCIS     830A STADDR     
830B PADB       830C BYTES      830C PTFCIP     830E PTCCIP     830E VAR4       
8310 PAD10      8310 PTLCIP     8310 TOPSTK     8310 VAR5       8311 VAR6       
8312 PAD12      8312 PTFBPH     8312 STRPTR     8312 VAR7       8314 PTCCPH     
8314 VAR9       8316 PAD16      8316 PTLCPH     8316 XFLAG      8317 FNUM       
831C SREF       8320 VARW       8322 ERRCOD     8324 STVSPT     8326 RTNG       
8328 NUDTAB     832C PGMPTR     832E EXTRAM     8330 STLN       8332 ENLN       
8334 DATA       8336 LNBUF      833E SYMTAB     8340 FREPTR     8342 CHAT       
8344 PRGFLG     8345 FLAG       8346 BUFLEV     8348 LSUBP      834A CCHAR      
834B FAC1       834B SPLFLG     834C FAC2       834C TOTTIM     834D DATAAD     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0079 
RXB 2024
834D FAC3       834E CCC        834E FAC4       834E FFF        834F PTLCIL     
8350 EEE        8350 FAC6       8351 FAC7       8351 TIMLEN     8352 FAC8       
8353 FAC9       8354 DDD1       8354 FAC10      8354 TEMP1      8355 FAC11      
8356 FAC12      8356 FFF1       8356 TEMP2      8358 EEE1       8358 FAC14      
8358 READ       8359 FAC15      835A WRITE      835D ARG1       835D PHDATA     
835E ARG2       835E PTCBED     8360 ARG4       8360 LENCST     8362 ARG6       
8362 LENWST     8363 ARG7       8364 ARG8       8364 STRLEN     8364 TEMP4      
8366 BYTE1      8366 TEMP5      8367 BYTE2      8368 BYTE3      8368 TEMP6      
8369 SPKSTS     8374 KEYBD      8375 RKEY       8376 JOYY       8377 JOYX       
8378 RANDOM     8379 TIMER      837A NOMSPR     837B VDPSTT     837C ERCODE     
837D CB         8384 RAMTOP     8386 RAMFRE     8389 RAMFLG     83C2 GKFLG      
83CE PRTNFN     A024 GA024      A026 LINK1      A030 LINK2      A03A LINK3      
A044 LINK4      A04E LINK5      A058 LINK6      A062 LINK7      A06B LINK8      
A073 LINK9      A07D LINKA      A088 LINKB      A090 EXEC       A09D EXEC1      
A0A2 GA0AE      A0A6 GA0B2      A0B0 EXEC20     A0C8 WARNGZ     A0CD WRNN01     
A0D3 EXECND     A0DD ERRRDY     A0E1 EXECTR     A0F6 GA102      A10A CLRRTN     
A10E EXECBK     A11B EXEC6C     A11F EXEC6D     A137 ERRBRK     A13B NUDTB      
A177 EOFX       A17A SZRUNX     A17D RECX       A180 NREADX     A183 PRINTX     
A186 RESTOX     A189 INPUTX     A18C OPENX      A18F CLOSEX     A192 ACCEPX     
A195 DISPLX     A198 DELETX     A19B LINPUX     A19E ONWARN     A1AB GA1B7      
A1B8 GA1C4      A1C3 ONWRN5     A1C5 ONWRN7     A1CE ONERR      A1E6 ONERR2     
A1FA ONERR4     A202 GA20E      A20A GA216      A20C ONBRK      A219 GA225      
A221 GA22D      A223 GPLCAL     A23C NPI        A244 CONPI      A24C NMAX       
A252 NMAXZ1     A257 GA263      A259 NMIN       A261 MAXMIN     A281 INTRND     
A287 NRND       A28D NRND1      A29B NRND2      A29D NRND3      A2AA NRND4      
A2AC NRND5      A2AE STRFCH     A2B0 STRPAR     A2B4 STRGET     A2BD NUMFCH     
A2C0 NUMSNM     A2C6 CFIFCH     A2CE GETNUM     A2D1 GNRTN      A2D7 SUBLP3     
A2DE SUBLP4     A2E6 NGOOD      A2E8 NGOOD1     A301 SNDER      A308 CIFSND     
A30A SNDASS     A30D CLRFAC     A315 NRNDMZ     A324 NRNDCT     A326 RNDM1      
A32C CKSTNM     A332 FLT1       A33A LITS05     A343 LITS07     A345 LITS08     
A350 LITS09     A35F GA420      A36A GA42B      A36B LITS06     A36F PUSSTR     
A377 CONCAT     A396 WRNST1     A39A GA45B      A3CD CONC06     A3CF SEGZ01     
A413 SEGZ06     A42E SEGZ08     A432 LEN01      A43A LEN02      A43E CHRZ01     
A459 ASC01      A46A STRZ01     A47D GA53E      A494 VAL01      A4A4 PARFF      
A4AE VALCD      A4B9 GA57C      A4E1 GA5A4      A4EB GA5AE      A4F6 RTNSET     
A4FA POS01      A535 POS02      A543 POS04      A552 POS06      A554 POS08      
A559 POS10      A561 POS12      A565 RPTZ01     A57E WRNST2     A586 GA649      
A596 GA659      A5A4 RPTZ02     A5B6 GA679      A5BE NTRACE     A5C1 XMLCON     
A5C3 NUNTRC     A5C8 NBREAK     A5D6 ERROLP     A5DA NUNBRK     A5E1 LINEGP     
A5EB LNGP1      A5FF LNGP2      A60E GA6D1      A617 GA6DA      A623 LNGP2B     
A62E WRNLNF     A634 UNBK01     A637 LNGP4      A639 UBSUB      A63C GA6FF      
A649 UBSUB1     A654 UDF        A65D GA720      A678 GA73B      A6D9 GA79C      
A6DC GA79F      A71F GA7E2      A733 GA7F6      A739 GA7FC      A747 DELINK     
A770 GA833      A783 GA846      A787 GA84A      A789 GA84C      A793 GA856      
A798 ATTNUT     A7AB DATAST     A7C4 GA887      A7C6 DATST1     A7C7 ASC        
A7D4 GA897      A7E2 GA8A5      A7E8 ERORZ      A810 LINE       A822 CONV1      
A82E WRNNO      A836 GA8F9      A837 GCHARZ     A83A GCHAR1     A859 GCHAR2     
A875 GCHAR3     A882 LNKRTN     A886 LNKRT2     A88E COLORZ     A892 COL08      
A8A5 COL09      A8AD COL10      A8BA COL20      A8C3 COL21      A8F1 COL22      
A8FA SPCOL      A906 INTARG     A91B JOYXY      A926 JOYNZ      A92E JOYAV      
A94E NUMVAR     A95B ATTREG     A967 COMB       A96D SQUISH     A984 SQU05      
A989 CLEARZ     A990 CLRPZ      A998 FLTS       A9A0 SNDREG     A9A9 XSOUND     
A9C4 GAA39      A9D8 GAA4D      A9E2 SOUND1     AA11 SOUND3     AA2A SOUND2     
AA48 SOUND5     AA4A SND05      AA59 SOUND6     AA6E HCHARZ     AA71 HCHAR1     
AA81 HCHAR2     AA88 VCHARZ     AA8B VCHAR1     AA9B VCHAR2     AAA2 HVRC       
AAC3 HVCHR      AACC HVCHR1     AAD8 HVCHS      AAD9 RGPHV      AADC GPHVRC     
AAFA CHARLY     AAFD CHAR5      AB13 CHAR2      AB1F CHAR1      AB22 CHARLD     
AB36 CHRFIL     AB47 CHARL4     AB4E KEY        AB51 GABD1      AB65 KEY1B      
AB84 GAC04      AB87 GAC07      AB89 KEY1C      AB8D KEY2       AB8F KEY2A      
AB92 LPARR      AB9D CPAR       ABA1 CPAR2      ABA9 CPAR3      ABAF RAN16      
ABB8 BORDER     ABC5 ERRWXY     ABC8 GAC99      ABDE GACAF      ABE9 GACBA      
ABF4 GACC5      ABFD GACCE      ABFF GACD0      AC0B ERR10      AC32 GAD03      
AC3A GAD0B      AC6D GAD3E      AC71 GAD42      AC76 ERRCOM     AC7B ERRC05     
AC86 ERRSYN     AC8A ERRSNM     AC8E ERRMUV     AC92 ERRMEM     AC96 ERRSO      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0080 
RXB 2024
AC9A ERRNWF     AC9E ERRFNN     ACA2 ERRSNS     ACA6 ERRRSC     ACAA ERRRWG     
ACAE ERRBS      ACB2 ERRLNF     ACB6 ERRBA      ACBA ERRBV      ACBE ERRIAL     
ACC2 ERRSNF     ACC6 LINKS1     ACD1 LINKS2     ACDF LINKS3     ACEC LINKS4     
ACF6 LINKS5     AD02 LINKS6     AD0D LINKS7     AD18 LINKS8     AD24 LINKS9     
AD31 LINKSA     AD39 LINKSB     AD43 LINKSC     AD4F LINKSD     AD59 LINKSE     
AD63 LINKSF     AD6C LINKSG     AD75 LINKSH     AD7E LINKSI     AD87 LINKSJ     
AD93 LINKSK     AD9F LINKSL     ADA7 LINKSM     ADAE LINKSN     ADBC LINKSO     
ADCA LINKSP     ADD6 LINKSQ     ADE3 LINKSR     ADF1 LINKSS     AE00 LINKST     
AE0C SPRTE      AE12 SPRT3      AE27 SPRT4      AE38 GAEBB      AE3D SPRDEL     
AE40 SPDEL1     AE55 SPDEL2     AE5C GAEF6      AE63 GAEFD      AE65 SPRPOS     
AE68 SPRP02     AE82 GAF1C      AE84 GAF1E      AE99 SPRP03     AEA3 GAF3D      
AEA6 SPRCOI     AEBC GAF56      AED2 GAF6C      AEDB SPRMAG     AEDE SPRMLP     
AEF8 SPRMOV     AEFB SPRMV2     AEFE SPRMV3     AF01 SPRMV4     AF08 SPRLOC     
AF0B SPRLC2     AF1C SPRPAT     AF1F SPRPT2     AF2C DIST       AF2F GAFC4      
AF4C OVER       AF50 GAFE5      AF54 CODIST     AF7C CODIS1     AF82 CODIS2     
AF94 CHRSET     AFB0 CHRALL     AFD6 SPNUM2     AFD8 SPNUM6     AFDD SPNUM3     
AFE2 SPNUM4     AFE8 SPNUM5     AFEF SPLOC      AFF2 SPLOC2     B00C SPCHR      
B01E SPMOVE     B03F SPMOVF     B040 RANGEV     B05D GB0DB      B063 GB0E1      
B064 COMMA      B067 COMMA2     B06F NULRTN     B072 ASSRTN     B077 NR         
B07A AR         B07D PREPN      B090 SAY        B0C0 DIRSPK     B0DE GB158      
B0F6 GB170      B0F9 GB173      B104 GB17E      B10E GB188      B11C GB196      
B126 GB1A0      B12D GB1A7      B137 NEXT1      B14C NEXT2      B151 SPEAK      
B154 GB1CE      B171 LOOP1      B182 GB1FC      B184 GB1FE      B197 DIRSPH     
B1B3 LOOPR      B1C7 GB241      B1DB CONTIN     B1DE GB258      B1E7 SPGET      
B1F0 NXTPAR     B220 GB29C      B22E GB2AA      B26F GB2EB      B283 RNDAG      
B29A GB316      B29C GB318      B2A3 GETPRM     B2B5 SETCB      B2B9 PHRASE     
B2C0 GB33C      B2CA GB346      B2D3 GB34F      B2D6 GB352      B2E6 FNDNUM     
B2F4 GB370      B300 GB37C      B30F GB38B      B310 TIMING     B31F GB39B      
B320 GETTIM     B330 GB3AC      B33D GB3B9      B348 GB3C4      B349 GB3C5      
B358 GB3D4      B361 GB3DD      B374 PTIME      B378 GB3F4      B388 GB404      
B391 GB40D      B39A NOTIME     B39E NUMERC     B3B4 GB430      B3B5 LOOKUP     
B3B7 TRYAGN     B3D2 GB44E      B3DC FOUND      B3DD SEARCH     B3F7 NEXT       
B411 GB48D      B41C GB498      B425 GB4A1      B444 GB4C0      B44A GB4C6      
B455 GB4D1      B461 NXTPHR     B46C GB4E8      B471 LOADAD     B4A3 READAD     
B4BB STDATA     B4CB WAIT       B4D6 SETRW      B4DD ERRSSL     B4E1 MOVES      
B4E4 MOVESA     B509 MOVESX     B50F MOVESB     B527 MOVESN     B52A MOVESC     
B535 MTYPES     B53D MTYPE      B547 MTYPE0     B54F MTYPE1     B55D MTYPE2     
B56A MTYPE3     B574 MTYPE4     B57D MTYPE5     B58C MTYPE6     B59A MTYPE7     
B5A4 MTYPE8     B5AC MTYPE9     B5BA MTYPEA     B5C7 MOVESD     B5CE HEX        
B5D1 HEXAGN     B61C HEXNS      B624 HEXNS2     B62E HEX00      B648 HEXDON     
B64F HEXSTR     B661 HEX01      B677 HEX02      B685 HEX03      B693 HEX04      
B69A HEX05      B69B RXBIO      B69E IOAGN      B6BC SOG        B6C1 SOV        
B6C6 CRUI       B6E1 CRUI16     B6F1 CRUO       B707 CRUO16     B716 CRUO8      
B71B CSW        B723 CSR        B72B CSV        B731 IODONE     B738 CRUTMP     
B740 CRUSET     B756 CSLOAD     B760 HPUTZ      B763 HPUTS      B769 HPOUT      
B770 VPUTZ      B773 VPUTS      B779 VPOUT      B780 PUTZ       B799 HVPUTN     
B7AC PUTZ1      B7AD HGETZ      B7B0 HGETS      B7C0 VGETZ      B7C3 VAGAIN     
B7D3 HVGETS     B7F2 GMOT       B7F5 GMAGN      B800 GMO1       B80F GMO2       
B81B GMO3       B829 RMOT       B82C RMAGN      B83B NXALL      B843 NOALL      
B852 RMALL      B85A RMOTLP     B86C J1         B86E J2         B87A J3         
B885 ZSCOI      B888 COINLP     B894 ZDIST      B897 DISLP      B8A1 ZKEY       
B8AB KEYJOY     B8CB KEYSTR     B8D9 RSCAN      B8E2 RSCAN0     B8E5 RSCAN1     
B8E9 RSCAN2     B8FF RSCAN3     B900 RSCAN4     B905 RSCAN5     B90C ZONKEY     
B91C GOTON0     B92A ONLP       B947 ONKEY1     B957 GKEY1      B95E GKEY2      
B972 GKEY3      B983 GJOYST     B986 JOYRPT     B9A6 JOYSTS     B9BF ZJOYST     
B9C2 JOYAGN     B9CF SPGS       B9E9 SPGSA      B9FC SPGS1      BA07 SPGS2      
BA13 SPGS3      BA1C SPGS4      BA1E SPGSE      BA21 SPAR       BA2B SPAR1      
BA43 SPAR2      BA48 ZJOMO      BA6D ZJOMO1     BA77 ZJOMO2     BA81 ZJOMO3     
BA8B ZJOMO4     BA95 ZJOMO5     BA9F ZJOMO6     BAA9 ZJOMO7     BAB3 ZJOMO8     
BABD ZJOMO9     BACC ZJOKG      BAFF ZJOMOR     BB02 ZJOLO      BB2E ZJOLO1     
BB37 ZJOLO2     BB40 ZJOLO3     BB49 ZJOLO4     BB52 ZJOLO5     BB5E ZJOLO6     
BB6A ZJOLO7     BB76 ZJOLO8     BB82 ZJOLO9     BBA4 INVERS     BBA7 INVAGN     
BBC0 INOALL     BBCE INVLP      BBDA INVNOK     BBE1 SWCHR      BBE4 SWCHAG     
BC13 SWCLR      BC17 SCOL10     BC47 SCOL20     BC74 SSDSLL     BC7F S1ET9F     

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0081 
RXB 2024
BC86 S00T10     BC8D COLLZ      BC90 COLL3      BCB0 COLL1      BCB7 COLL2      
BCE3 SETSND     BCF0 CASCII     BD02 BIT1D      BD08 BIT2       BD1E BIT2D      
BD24 BIT3       BD37 BIT3D      BD3D BIT4       BD53 BIT4D      BD59 BITDI      
E025 GE025      

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0082 
RXB 2024
Symbol Table #4 (Def,alpha)  
0034 ACCTON     835C ARG        0032 ATN        0036 BADTON     003B BITREV     
0012 CFI        0014 CNS        002C COS        0010 CSN        8372 DATSTK     
0001 DIVZER     0003 ERRIOV     0006 ERRLOG     0005 ERRNIP     0002 ERRSNN     
0004 ERRSQR     0028 EXP        834A FAC        0006 FADD       000A FCOMP      
0009 FDIV       0008 FMUL       836C FPERAD     0007 FSUB       0038 GETSPACE   
0022 INT        0010 LINK       0018 LOCASE     002A LOG        8370 MEMSIZ     
003D NAMLNK     8300 PAD        0024 PWR        0012 RETURN     000B SADD       
000F SCOMP      000E SDIV       8375 SGN        002E SIN        000D SMUL       
8400 SOUND      0026 SQR        000C SSUB       837C STATUS     0016 STCASE     
8373 SUBSTK     0030 TAN        0007 TRIGER     004A UPCASE     836E VSPTR      
0001 WRNOV      837F XPT        837E YPT        

99/4 GPL-ASSEMBLER (Pass 3) correct                                   PAGE 0083 
RXB 2024
Symbol Table #8 (Def,value)  
0001 DIVZER     0001 WRNOV      0002 ERRSNN     0003 ERRIOV     0004 ERRSQR     
0005 ERRNIP     0006 ERRLOG     0006 FADD       0007 FSUB       0007 TRIGER     
0008 FMUL       0009 FDIV       000A FCOMP      000B SADD       000C SSUB       
000D SMUL       000E SDIV       000F SCOMP      0010 CSN        0010 LINK       
0012 CFI        0012 RETURN     0014 CNS        0016 STCASE     0018 LOCASE     
0022 INT        0024 PWR        0026 SQR        0028 EXP        002A LOG        
002C COS        002E SIN        0030 TAN        0032 ATN        0034 ACCTON     
0036 BADTON     0038 GETSPACE   003B BITREV     003D NAMLNK     004A UPCASE     
8300 PAD        834A FAC        835C ARG        836C FPERAD     836E VSPTR      
8370 MEMSIZ     8372 DATSTK     8373 SUBSTK     8375 SGN        837C STATUS     
837E YPT        837F XPT        8400 SOUND      
